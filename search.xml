<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>什么是context？</title>
    <url>/android/context/</url>
    <content><![CDATA[<h3 id="Context基本概念"><a href="#Context基本概念" class="headerlink" title="Context基本概念"></a>Context基本概念</h3><p>先看一下Context源码，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface to global information about an application environment.  This is</span></span><br><span class="line"><span class="comment"> * an abstract class whose implementation is provided by</span></span><br><span class="line"><span class="comment"> * the Android system.  It</span></span><br><span class="line"><span class="comment"> * allows access to application-specific resources and classes, as well as</span></span><br><span class="line"><span class="comment"> * up-calls for application-level operations such as launching activities,</span></span><br><span class="line"><span class="comment"> * broadcasting and receiving intents, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>解释如下： </p>
<ul>
<li>有关应用程序环境的全局信息的接口。这是一个抽象类，其实现由Android系统提供。, 它允许访问特定于应用程序的资源和类，以及用于应用程序级操作的上调，activity，广播和intent等。</li>
</ul>
<p>下面看看Context的实现类ContextImpl源码注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Common implementation of Context API, which provides the base</span></span><br><span class="line"><span class="comment"> * context object for Activity and other application components.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释如下：</p>
<ul>
<li>Context API的通用实现，它为Activity和其他应用程序组件提供基础上下文对象。</li>
</ul>
<p>再来看看Context的包装类ContextWrapper源码注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Proxying implementation of Context that simply delegates all of its calls to</span></span><br><span class="line"><span class="comment"> * another Context.  Can be subclassed to modify behavior without changing</span></span><br><span class="line"><span class="comment"> * the original Context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Context mBase;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释如下：</p>
<ul>
<li>代理Context的实现，简单地将其所有调用委托给另一个Context。可以进行子类化以修改行为而不更改原始上下文。 </li>
</ul>
<p>该类包括了一个真正的Context对象，也就是ContextImpl。其是ContextImpl的代理模式。</p>
<h3 id="一个应用有多少个Context"><a href="#一个应用有多少个Context" class="headerlink" title="一个应用有多少个Context"></a>一个应用有多少个Context</h3><p>面试最常问的就是一个应用有多少个Context，有多少个Window。<br>Android应用程序只有四大组件，通过源码，我们看出，只有Activity和Service是继承了Context的。当然，每个应用还有额外的一个Application。所以总数为：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">APP Context总数 = Application数(<span class="number">1</span>) + Activity数(<span class="built_in">number</span>) + Service数(<span class="built_in">number</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Context在ActivityThread的实例化"><a href="#Context在ActivityThread的实例化" class="headerlink" title="Context在ActivityThread的实例化"></a>Context在ActivityThread的实例化</h3><p>首先，肯定有人问为什么context是在ActivityThread中实例化的，这边不具体深入启动流程。有兴趣的可以自己去看。</p>
<h4 id="Activity中ContextImpl的实例化"><a href="#Activity中ContextImpl的实例化" class="headerlink" title="Activity中ContextImpl的实例化"></a>Activity中ContextImpl的实例化</h4><p>通过startActivity我们会启动一个新的Activity。它最终会调用ActivityThread的performLaunchActivity方法，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">  </span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ...</span><br><span class="line">              appContext.setOuterContext(activity);</span><br><span class="line">              activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                      r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                      r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                      r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">              ...</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">   <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码差不多就是通过createBaseContextForActivity(r);创建appContext，然后通过activity.attach设置。现在我们看看createBaseContextForActivity的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Context <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">final</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    ...  </span><br><span class="line">     ContextImpl appContext = ContextImpl.createActivityContext(<span class="keyword">this</span>, r.packageInfo, r.token);</span><br><span class="line">     appContext.setOuterContext(activity);</span><br><span class="line">     Context baseContext = appContext;</span><br><span class="line">     ......</span><br><span class="line">     <span class="keyword">return</span> baseContext;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是通过ContextImpl去创建一个activity的上下文，然后通过setOuterContext去将当前的activty和context进行绑定。</p>
<p>在来看看attach方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">          Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">          Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">          CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">          NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">          Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">          Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">      attachBaseContext(context);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过上述代码，我们可以看出通过ContextThemeWrapper类的attachBaseContext方法，将createBaseContextForActivity中实例化的ContextImpl对象传入到ContextWrapper类的mBase变量，这样ContextWrapper（Context子类）类的成员mBase就被实例化为Context的实现类ContextImpl。</p>
<h4 id="Service中的ContextImpl实例化"><a href="#Service中的ContextImpl实例化" class="headerlink" title="Service中的ContextImpl实例化"></a>Service中的ContextImpl实例化</h4><p>通过startService或者bindService我们会启动一个新的Service。它最终会调用ActivityThread的handleCreateService方法，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">       </span><br><span class="line">       Service service = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">           service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ......</span><br><span class="line">           ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">           context.setOuterContext(service);</span><br><span class="line"></span><br><span class="line">           Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">           service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,ActivityManagerNative.getDefault());</span><br><span class="line">           service.onCreate();</span><br><span class="line">           ......</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>具体和上面的activity类型，这边不深入，我们看看service的attach方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">          ActivityThread thread, String className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">          Application application, Object activityManager)</span> </span>&#123;</span><br><span class="line">      attachBaseContext(context);</span><br><span class="line">      .....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出步骤流程和Activity的类似，只是实现细节略有不同而已。</p>
<h4 id="Application中的Context实例化"><a href="#Application中的Context实例化" class="headerlink" title="Application中的Context实例化"></a>Application中的Context实例化</h4><p>前面我们说到一个应用有一个Application，它的生命周期伴随着整个项目。创建Application的过程也是在ActivityThread中的handleBindApplication方法中操作。Application的创建是在该方法中调运LoadedApk类的makeApplication方法中实现，LoadedApk类的makeApplication()方法中源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass, Instrumentation instrumentation)</span> </span>&#123;  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        ContextImpl appContext = <span class="keyword">new</span> ContextImpl();    </span><br><span class="line">        appContext.init(<span class="keyword">this</span>, <span class="keyword">null</span>, mActivityThread);  </span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(  </span><br><span class="line">                cl, appClass, appContext);                   </span><br><span class="line">        appContext.setOuterContext(app); </span><br><span class="line">    &#125;   </span><br><span class="line">    ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>可以看出它将appContext通过Instrumentation的newApplication传进去了，下面我们看看Instrumentation的newApplication方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(ClassLoader cl, String className, Context context)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> InstantiationException, IllegalAccessException, </span></span><br><span class="line"><span class="function">          ClassNotFoundException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> newApplication(cl.loadClass(className), context);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> InstantiationException, IllegalAccessException, </span></span><br><span class="line"><span class="function">          ClassNotFoundException </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      app.attach(context);</span><br><span class="line">      <span class="keyword">return</span> app;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们接着看Application的attach方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，和activity与service类似，只是实现的细节变了。</p>
<h3 id="getApplication和getApplicationContext的区别"><a href="#getApplication和getApplicationContext的区别" class="headerlink" title="getApplication和getApplicationContext的区别"></a>getApplication和getApplicationContext的区别</h3><p>很多人分不清getApplication和getApplicationContext，这其中包括我，于是就去翻了翻源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">ContextThemeWrapper</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory2</span>,</span></span><br><span class="line"><span class="class">        <span class="title">Window</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">OnCreateContextMenuListener</span>, <span class="title">ComponentCallbacks2</span>,</span></span><br><span class="line"><span class="class">        <span class="title">Window</span>.<span class="title">OnWindowDismissedCallback</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Application <span class="title">getApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mPackageInfo != <span class="keyword">null</span>) ?</span><br><span class="line">                mPackageInfo.getApplication() : mMainThread.getApplication();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到getApplicationContext方法是Context的方法，而且返回值是Context类型，返回对象和上面通过Service或者Activity的getApplication返回的是一个对象。</p>
<p>所以说对于客户化的第三方应用来说两个方法返回值一样，只是返回值类型不同，还有就是依附的对象不同而已。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>从上面我们分析了context，但我们要合理的利用的context对象，context与其所关联的对象生命周期相同，所以我们需要避免出现没有必要的内存泄漏。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>2020年度总结</title>
    <url>/conclusion/2020/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不知不觉又到了写年度总结的时候，细翻了下，去年我居然没去写年度总结，想了想，可能当时也的确没什么总结的，可能就算有也不知道咋写吧。当然了这都是借口，不过现在就总结下2020的内容吧。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>今年工作对比19年来说，相对来说轻松一点，19年除了相关业务开发。因为是新项目所以我还负责管理android小组，虽然总共没几个人。不过要对接PMO，PM，QA等等。在这情况下，还需要负责业务开发，往往忙的只有晚上才能开始写代码。而今年除了业务的开发，其他的到没啥，所以我更注重于自我的成长，以及在团队内部推动相关技术，进行落地。</p>
<p>不过对比上面这些，可能还需要在团队中给自己定位。比如领导对我说的一句话：“你工作很辛苦，也很努力，工时也是团队中最多的，不过做东西都是缩起来，其他同事也不知道你在干嘛。东西做完了，别人认可你做的内容么，有没有和同事讨论你这套东西是不是最实用的，能不能再浓缩一下”。</p>
<p>后来自己想想，的确之前一个技术方案的确定—落地—实施。好像都是自己一个人去进行的。于是后面我就改变了思路，从草稿—沟通确定方案—落地任务细分到人—实施。对比之前的，相对自己会轻松很多，而且团队成员也知道我要做什么，并且方案确定了，细分到人去完成这个任务。自己反而会有成就感。</p>
<h3 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h3><p>身为一个技术人，个人成长是绝不能落下的。比如今年疫情放小长假的情况下，我在家自学了flutter了。并用泓洋的开放API开发了一个flutter项目<a href="https://github.com/sw950729/WanAndroid_Flutter">WanAndroid_Flutter</a>。并在团队内部做flutter相关的分享，以及推动使用flutter进行业务开发。</p>
<p>为了倒逼自己进步，我退掉了一些无关紧要的群，甚至关闭了朋友圈，淡出了朋友们的朋友圈。另外，今年在拉钩教育上买了六门课，完整的看完了三门课，包括一些课反复的看。进行知识点的吸收以及内化。</p>
<p>对于blog的输出，我发现我上次更新blog还是18年的9月份。目前这家公司是18年11月入职的，也就是入职到这边之后，我几乎没有对外输出过blog。几乎可能证明两点，一个是懒、一个是没有成长所以不好输出blog。所以为了学习的内容不容易忘，也为了忘了可以快速查笔记巩固回来。近期我开始慢慢的同步更新了blog。同步地址是个人博客：silencedev.cn。今年已经更新的blog如下：<br><img src="https://s3.ax1x.com/2021/01/26/sjveoR.jpg" alt="image"></p>
<p>后面我还会持续输出，尽可能保证一周一篇左右。毕竟，不逼自己一把，你永远不知道你会有多努力。</p>
<p>如何确定自己是否有成长，当然除了本身技术的上的提升，还有工作上的成长，主要参考如下几个方面：</p>
<ul>
<li>是否愿意主要承担更多工作</li>
<li>是否具备Owner意识</li>
<li>在团队中其他成员是否认同你做的内容</li>
<li>是否可以通过技术推进业务发展</li>
<li>跨部门的沟通、协作</li>
<li>在团队中的影响力，在部门中的影响力。</li>
</ul>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>今年后半年发福了，原本体重一直很稳定，今年下半年突然间的就胖了十斤。不过今年体验的时候，发现还好，各个指标都在正常范围内。</p>
<p>今年外出游玩了两次，去了很久想去但一直没去的黄山，觉得工作太累，出门去厦门度假了一周。</p>
<p>作息变得越来越晚，前两年基本12点半之前就入睡了，近两年稳定在一点到两点之间，不过相对起的比较晚，所以整体还好，不过晚睡的毛病还是要改。</p>
<p>剩下的就是一直被催婚，停不下来的那种。于是，我就决定今年过年不回家了。虽然这个想法在去年年初就和父母沟通过了，但是刚好这次疫情回家要做检测，也刚好遂了不回家愿。毕竟也不是第一次不在家过年了。</p>
<h3 id="2021规划"><a href="#2021规划" class="headerlink" title="2021规划"></a>2021规划</h3><ul>
<li>减肥</li>
<li>技术沉淀</li>
<li>看书（一个月一本）</li>
<li>出门玩一圈</li>
<li>找个对象（年年在说，年年放最后一个）</li>
</ul>
]]></content>
      <categories>
        <category>人生</category>
      </categories>
  </entry>
  <entry>
    <title>算法复杂度</title>
    <url>/data_structure/algorithmic_complexity/</url>
    <content><![CDATA[<p>算法复杂度分为时间复杂度和空间复杂度。其作用：时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用”O”来表示数量级，给出算法的时间复杂度。 T(n)=O(f(n));<br>它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界。</p>
<p>时间复杂度的分析方法：<br>1、时间复杂度就是函数中基本操作所执行的次数<br>2、一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数<br>3、忽略掉常数项<br>4、关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数<br>5、计算时间复杂度是估算随着n的增长函数执行次数的增长趋势<br>6、递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数  </p>
<p>常用的时间复杂度有以下七种，算法时间复杂度依次增加：O(1)常数型、O(log2 n)对数型、O(n)线性型、O(nlog2n)二维型、O(n^2^)平方型、O(n^3^)立方型、O(2^n^)指数型.</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级。<br>S(n)=O(f(n))  若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1);<br>递归算法的空间复杂度：递归深度N*每次递归所要的辅助空间，如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N).</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>树组与链表</title>
    <url>/data_structure/arrays_and_stack/</url>
    <content><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在java中，数组定义为一种基本类型，其可以通过下标获取到对应位置的数据。那么这种结构的数据，在内存中是怎么存放的呢？  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604231852160.png" alt="image">  </p>
<p>正如上图所示，数组在内存中是一段连续的存储单元，每个数据依次放在每个单元中。分析这种结构，我们可以得出以下几个结论：</p>
<ul>
<li><p>创建一个数组，必须声明其长度，以在内存中寻找合适的一段连续存储单元。这也意味着数组的大小是固定的，我们无法动态调整其大小。</p>
</li>
<li><p>想要获取数组中第i个元素，其时间复杂度是O(1)，因为可以根据其地址直接找到它。同理修改也是。</p>
</li>
<li><p>数组对查询表现一般，要想查找一个元素，需要遍历，时间复杂度为O(n)。</p>
</li>
<li><p>因为地址连续，想要在数组中插入一个元素是复杂的，因为从插入位置起，后边的所有元素都需要向后移动一位。同理删除也是，只是移动方向为向前。并且，当数组存满时，就无法继续插入了。</p>
</li>
<li><p>因为数组要占据一整块内存，有可能产生许多的碎片，也可能因为找不到合适的内存块，而导致存储失败。</p>
</li>
</ul>
<p>总结起来就是：数组大小固定，查找迅速，增删复杂，需要完整的内存块，容易产生碎片。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种离散存储结构，其在内存中存储不是连续的，每个数据元素都通过一个指针指向其下一个元素的地址。根据指针域的不同，链表又分为单链表、双向链表、循环链表等，这里我们只分析单链表。示意图如下所示：<br><img src="https://img-blog.csdnimg.cn/2020060423192923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"><br>分析这种结构，我们可以得出以下几个结论：</p>
<ul>
<li><p>声明一个链表时，不需要知道其长度，也不需要连续的内存块，所以其大小可以动态调整。</p>
</li>
<li><p>链表的每个元素都分为数据域和指针域，前者是实际存储的数据，后者则指向下一个元素的地址。和数组相比，每个元素需要占用的内存更大了。</p>
</li>
<li><p>要获取链表的第 i 个元素变得复杂，因为其地址存放在它上一个元素的指针域里，所以只能从第一个元素起，进行 i 次操作。同理修改也是。</p>
</li>
<li><p>链表对查询表现也一般，需要遍历，时间复杂度为O(n)。</p>
</li>
<li><p>增加与删除一个元素更方便了，因为没有对内存地址的限制，我们只需要在对应节点合理处理下指针域的值，就可以把一个元素插入链表或者从链表删除。</p>
</li>
<li><p>链表对内存的要求很小，只要能够存储下一个数据元素的内存块都可以使用，因此不会造成碎片化。</p>
</li>
</ul>
<p>总结起来就是：大小可以动态调整，增删迅速，查找较慢，数据元素所占内存略多，不需要整块内存块，不会造成碎片化。</p>
<h3 id="数组与链表的选择"><a href="#数组与链表的选择" class="headerlink" title="数组与链表的选择"></a>数组与链表的选择</h3><p>通过以上分析，数组和链表对我们影响最大的几点区别在于：</p>
<ul>
<li>数组按位置查找迅速，链表增删方便</li>
<li>数组是固定大小，链表可以随时扩充与缩减</li>
<li>链表每个元素占据内存略多于数组</li>
<li>数组和链表在查询方面表现都比较一般，耗时较长  </li>
</ul>
<p>数组就像身上编了号站成一排的人，要找第10个人很容易，根据人身上的编号很快就能找到。但插入、删除慢，要望某个位置插入或删除一个人时，后面的人身上的编号都要变。当然，加入或删除的人始终末尾的也快。<br>链表就像手牵着手站成一圈的人，要找第10个人不容易，必须从第一个人一个个数过去。但插入、删除快。插入时只要解开两个人的手，并重新牵上新加进来的人的手就可以。删除一样的道理。  </p>
<p>在数据量很小，内容基本固定时，我们选择何种数据结构的影响并不大。但当数据量较大时，如果我们需要对数据进行频繁的插入删除，我们应该选择链表，如果我们需要频繁的获取某个位置的元素，我们应该选择数组。数组与链表并没有明确的优劣之分，根据不同的使用场景进行不同的选择，才是这两种结构使用的最佳方式。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/data_structure/balanced_binary_tree/</url>
    <content><![CDATA[<p>二叉排序树很好的平衡了插入与查找的效率，但不平衡的二叉排序树效率大打折扣。今天介绍的AVL树就是一种解决此问题的方案。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>平衡二叉树，是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。它是一种高度平衡的二叉排序树。意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF (Balance Factor)，那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。</p>
<p>如下图就不是一棵AVL树，因为结点18的左子树高度为2，右子树高度为0，高度差大于1。<br><img src="https://img-blog.csdnimg.cn/20200604232909854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>但通过一定的步骤调整之后，可以将其转为一棵平衡二叉树，如下图：<br><img src="https://img-blog.csdnimg.cn/20200604232947478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。最小不平衡子树是指距离插入结点最近的，且平衡因子的绝对值大于1 的结点为根的子树。</p>
<p>下面通过一个实例，了解平衡二叉树的构建过程。</p>
<p>假如我们要将数组int[] a = {3, 2, 1, 4, 5, 6, 7, 10, 9, 8}构建成一棵二叉排序树，如果直接按照二叉排序树的定义，会得到下面的结果：<br><img src="https://img-blog.csdnimg.cn/20200604233021566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>这样的结果对查找是十分不利的，树的高度达到了8，而且大多数只有一个孩子。所以我们需要一些操作，将它变成一棵AVL树。</p>
<p>首先，插入元素3和2时，没有什么影响，此时3的平衡因子为1，2的平衡因子为0，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200604233056990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>现在，要把1插入树中，这时结果如下所示：  </p>
<p><img src="https://img-blog.csdnimg.cn/2020060423312969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>此时3的平衡因子为2了，不再符合平衡二叉树的规则。此时，整棵树就是最小不平衡子树，我们将其右旋：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233205675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>再插入4，也不会影响平衡，结果如下：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233236547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>此时，插入元素5，以3为根结点的子树成为了最小不平衡子树，如下所示：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233309434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>现在要对其进行左旋：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233350415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>现在继续插入元素6，此时以2为根结点的右子树为最小不平衡子树，结果如下：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233422864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>这时再次需要对其进行左旋，这次旋转后要将4的左孩子变为2的右孩子，以满足二叉排序树的定义，如下所示：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233451438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>再插入7时，情况和之前有些类似了，结果如下：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233540770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>左旋后结果如下：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233612956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>现在，继续插入10，此时无需调整，结果如下：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233645958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>下一步，插入元素9，此时结果如下：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233715778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>按照之前的经验，这时我们应该进行左旋了，但是左旋之后9将变为10的右孩子，这会不符合二叉排序树的定义。和之前不同的是，7和10的平衡因子符号相反，这是造成这一结果的原因。这种情况下，要先以10为根节点右旋，再进行左旋，结果如下所示：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233755596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70">  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233825578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>最后插入元素8，如下所示：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233910376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>此时情况和上述类似，6是最小不平衡子树的根结点，9和6的平衡因子符号相反，所以先以9为根结点右旋：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604233942312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>然后再以6左旋：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604234013915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"></p>
<p>可以看到，此树的高度仅为4，与之前的8相差很多，性能自然也好很多。</p>
<p>平衡二叉树的删除操作与插入类似，这里将不再介绍。大家可以自己思考如何最高效地删除元素，可以分叶结点、仅有一个子结点和有两个子结点三种情况考虑，这里还用到了递归的思想。</p>
<p>接下来我们将介绍另一种实现方式，红黑树。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>二叉排序树</title>
    <url>/data_structure/binary_sort_tree/</url>
    <content><![CDATA[<p>解决查询速度慢的方案除了哈希表外，还可以使用二叉排序树。我们知道，查询慢主要是因为不知道元素的位置，使用hash函数映射虽然解决了问题，但其并不稳定，当出现大量的哈希碰撞后其表现更像一个链表，查询速度大大降低。</p>
<p>二叉排序树的方案则是使元素有序，这样便可以使用二分法进行查找了，虽然效率相比hash函数低一些，但可以通过AVL树、红黑树等增加稳定性。</p>
<p>HashMap在JDK1.8的实现中，就结合了哈希表的高效和红黑树的稳定，我们之后会详细分析其实现。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>二叉排序树(Binary Sort Tree)，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</p>
</li>
<li><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</p>
</li>
<li><p>它的左、右子树也分别为二叉排序树</p>
</li>
</ul>
<p>如下就是一棵简单的二叉排序树：<br><img src="https://img-blog.csdnimg.cn/20200604231449302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"><br>当对这棵树进行中序遍历时，其结果将按照从小到大排序。</p>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>二叉排序树的查找时间复杂度为O(lg n)，查找使用二分法。要在上图中找到元素37，只需要四次操作即可。</p>
<p>首先，找到根元素22，37比22大，所以淘汰左子树，再找到35，淘汰左子树，再找到41，进入左子树，得到37。可以看到其速度比挨个对比高了很多。</p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>二叉排序树的插入操作和查询类似，也需要通过二分法进行查找，找到合适的位置再插入元素，所以其插入速度相比链表较慢。</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>从二叉排序树中删除一个元素主要分为三种情况。</p>
<p>例如要从下面这个二叉排序树中删除一个元素：<br><img src="https://img-blog.csdnimg.cn/20200604231449302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<ul>
<li><p>删除的元素是叶结点，这时可以直接删除它。比如要删除值为1的元素，删除它对树没有任何影响。</p>
</li>
<li><p>删除的元素仅有左孩子或者仅有右孩子时，直接让其孩子顶替它即可。比如要删除元素35，只需要用41顶替它即可。</p>
</li>
<li><p>删除的元素既有左孩子又有右孩子，这时删除它相对复杂。一种好的方式是找到它的前驱或者后继来代替它。比如要删除元素9，就用6或者13代替它即可。</p>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一棵普通的二叉排序树也会出现不平衡问题，如果插入的数据都在树的一侧，就会使得树的深度迅速增大，每次二分查找可以排除的数据很少，从而查询速度严重下降，比如下方这棵树：<br><img src="https://img-blog.csdnimg.cn/20200604231633327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"><br>要查找值为2的元素，使用二分法和使用链表速度差不多。</p>
<p>为了解决这种问题，就需要在元素插入时即进行修正，后续介绍的AVL树和红黑树就是两种不同的解决方案。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/data_structure/hash_table/</url>
    <content><![CDATA[<p>无论是数组还是链表，其对数据的查询表现都比较无力，要想知道一个元素是否在数组或链表中，只能从前向后挨个对比。在后续将会分析的二叉排序树中，还会将数据排序以进行二分查找，将时间复杂度从O(n)降低到O(lg n)。</p>
<p>出现这个问题的根源在于，我们没有办法直接根据一个元素找到它存储的位置，那有没有办法消除这个对比的过程呢？哈希表就是解决查询问题的一种方案。</p>
<h3 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h3><p>通俗来讲，哈希表是通过关键字key来获取数据的一种数据结构。它把关键字映射成表中的位置来获取元素，这种映射称为hash函数。</p>
<p>因为不同的key类型不一样，可能是int，可能是string…但内存地址不会以这些对象也寻址，它会通过hash算法将其转换成int从而完成数据的存储。hash函数需要保证的是对于相同的key，其计算结果总是相同的。  </p>
<p>这个过程类似查字典，如果要查一个字，我们不会从第一页到最后一页挨着看，这将需要很长的时间，而是根据其发音先在拼音表中找到对应的页数，直接定位到对应的页即可。当然，由于有许多发音一致的汉字，所以我们可能依然需要逐个对比，但这复杂度就小太多了。</p>
<p>哈希表的过程就和上述例子一样，我们通过key经过hash算法直接定位其位置。然而类似于许多发音一致的，也就是有许多的key通过hash定位的结果是一样，那么这就是hash碰撞。  </p>
<h3 id="如何解决hash碰撞"><a href="#如何解决hash碰撞" class="headerlink" title="如何解决hash碰撞"></a>如何解决hash碰撞</h3><p>目前比较通用的方法就是使用数组加链表去处理，先看一张图<br><img src="https://img-blog.csdnimg.cn/202006042317255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>然后举个简单的例子：<br>hashmap是数组和链表的结合，它拥有这两种特性。怎么说呢？举个例子，一个学校有不同年级，不同年级有不同班级，不同班级有不同的学生。hashmap里面包含了一个数组，entry包装对象，而entry里面包含了k，v，next。</p>
<p>对next有似曾相识的感觉？打个比方。用年级对应k，班级对应v。而同一个年级，同一个班级，有不同的学生，对于这个学生，就是通过next来查询的。在后续文章中我们会对其进行详尽的分析。</p>
<h3 id="哈希表的优缺点"><a href="#哈希表的优缺点" class="headerlink" title="哈希表的优缺点"></a>哈希表的优缺点</h3><p>哈希表是一种优化存储的思想，具体存储元素的依然是其他的数据结构。设计良好的哈希表，能同时兼备数组和链表的优点，它能在插入和查找时都具备良好的性能。然而设计不好的哈希表，有可能会出现较多的哈希碰撞，导致链表过长，从而哈希表会更像一个链表。还有当数据量很大时，为防止链表过长，就需要对数组进行扩容，这时就涉及到了数组的拷贝，其对性能的影响也很严重，所以需要提前对可能的情况有良好的预测，才能真正发挥哈希表的优势。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>树与二叉树</title>
    <url>/data_structure/tree_and_binaryTree/</url>
    <content><![CDATA[<p>数组与链表是用来解决一对一的问题，而一对多的问题则需要树来解决。</p>
<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树是N的节点的有限集。N=0时称为空树，在一个非空树中：  </p>
<ul>
<li>有且只有一个根（）节点。</li>
<li> 当n&gt;1 时，其余结点可分为m (m&gt;0) 个互不相交的有限集T1 、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。</li>
</ul>
<p>下图就是一个树：<br><img src="https://img-blog.csdnimg.cn/20200604232225999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<h3 id="节点分类"><a href="#节点分类" class="headerlink" title="节点分类"></a>节点分类</h3><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree) 。度为0的结点称为叶结点(Leaf) 或终端结点；度不为0 的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。</p>
<p>如下图所示，A结点为根节点，G、H、I、J、F为叶节点，其余节点则为内部节点，此树的度为3。<br><img src="https://img-blog.csdnimg.cn/20200604232309547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<h3 id="节点间的关系"><a href="#节点间的关系" class="headerlink" title="节点间的关系"></a>节点间的关系</h3><p>结点的子树的根称为该结点的孩子(Child)，相应地，该结点称为孩子的双亲(Parent)。同一个双亲的孩子之间互称兄弟(Sibling)。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604232343951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<h3 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h3><p>结点的层次(LeveI)从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第L层，则其子树的根就在第L+1层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度(Depth)或高度 。<br><img src="https://img-blog.csdnimg.cn/20200604232435660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<h3 id="有序树与无序树"><a href="#有序树与无序树" class="headerlink" title="有序树与无序树"></a>有序树与无序树</h3><p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是n(n ≥ 0) 个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。<br>下图就是一个二叉树，二叉树就是每个节点的度≤2的树。<br><img src="https://img-blog.csdnimg.cn/20200604232514455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>二叉树遍历是指从根节点出发，按照某种顺序依次访问二叉树的所有节点，使得每个节点被访问一次且只能被访问一次。二叉树遍历分为前序遍历，中序遍历以及后续遍历。</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树， 再前序遍历右子树。</p>
<p>如下图所示，遍历结果为：ABDGHCEIF。<br><img src="https://img-blog.csdnimg.cn/20200604232550412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>规则是若树为空，则空操作返回，否则从根结点开始(注意并不是先访问根结点) ，中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p>
<p>如下图所示，遍历结果为：GDHBAEICF。<br><img src="https://img-blog.csdnimg.cn/20200604232622613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p>
<p>如下图所示，遍历结果为：GHDBIEFCA。<br><img src="https://img-blog.csdnimg.cn/20200604232653753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Gradle入门以及环境搭建</title>
    <url>/gradle/environment/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>gradle目前主要是在项目构建的时候使用，如果我们需要了解gradle。首先需要熟悉grooy的语法，本节来搭建groovy的环境，为了后续学习准备。</p>
<h3 id="Groovy环境搭建"><a href="#Groovy环境搭建" class="headerlink" title="Groovy环境搭建"></a>Groovy环境搭建</h3><h4 id="groovy-SDK下载"><a href="#groovy-SDK下载" class="headerlink" title="groovy SDK下载"></a>groovy SDK下载</h4><ul>
<li>官网下载，直接解压，然后目录选择groovy/libexec。</li>
<li>brew安装的groovy目录选择/usr/local/opt/groovy/libexec。（另外，在idea中无法切到/user目录下，mac按Cmd + Shift + G来切换目录）</li>
</ul>
<h4 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h4><p>使用sudo vim ~/.bash_profile打开编辑环境变量文本。在末尾加上<br>export GROOVY_HOME=/usr/local/opt/groovy/libexec。然后esc+:wq进行保存</p>
<h3 id="gradle项目"><a href="#gradle项目" class="headerlink" title="gradle项目"></a>gradle项目</h3><p>在idea中新建一个groovy项目。如下：<br><img src="https://s3.ax1x.com/2021/01/06/sVxThQ.png" alt="image"></p>
<p>创建好项目后，我们新建一个 groovy 文件，并添加 hello world 的代码如下：<br><img src="https://s3.ax1x.com/2021/01/06/sZip4K.png" alt="image"><br>能够正常输出 hello world，收工！</p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>如何自己动手撸一个Gradle插件</title>
    <url>/gradle/gradle_plugin/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面我们已经把gradle中groovy的一些语法，以及常用的project和task介绍了一遍，那么我们通过自己撸个插件。刚好把前面的内容巩固下。</p>
<h3 id="插件的作用"><a href="#插件的作用" class="headerlink" title="插件的作用"></a>插件的作用</h3><p>首先我们需要了解下插件的作用，主要有如下几点：</p>
<ul>
<li><p>添加任务到项目中，可对项目进行测试、编译、打包；    </p>
</li>
<li><p>添加依赖到项目中，可用来配置项目构建过程中需要的依赖； </p>
</li>
<li><p>可以向项目中现有的对象类型添加新的扩展属性、方法等，可方便项目的配置和构建优化，比如 Android 项目构建中的 android{} 就是AndroidGradle插件为Project 对象添加的一个扩展。</p>
</li>
</ul>
<h3 id="插件的分类"><a href="#插件的分类" class="headerlink" title="插件的分类"></a>插件的分类</h3><p>插件主要是分为两种：脚本式插件和二进制式插件。</p>
<h4 id="脚本式插件"><a href="#脚本式插件" class="headerlink" title="脚本式插件"></a>脚本式插件</h4><p>脚本式插件就类似于前面文章提到的，自己新建一个config.gradle，然后通过</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">from:</span><span class="string">&quot;../config.gradle&quot;</span></span><br></pre></td></tr></table></figure>
<p>去引用config.gradle文件中的一些属性等，如可将某些工具性质的方法以及各个依赖使用的版本号分别定义到单个gradle文件中，方便统一调用和管理各个依赖的版本号等。</p>
<h4 id="二进制式插件"><a href="#二进制式插件" class="headerlink" title="二进制式插件"></a>二进制式插件</h4><p>二进制插件一般式之通过式Plugin接口，实现apply方法。该方法中的泛型指的是此Plugin可以应用到的对象，一般是将其应用到Project对象上。一般来说二进制插件分为三种方式：</p>
<ul>
<li>Build script：直接在gradle脚本文件中实现plugin接口并应用，不适用于对外提供</li>
<li>buildSrc project： buildSrc是Gradle 在项目中配置自定义插件的默认目录。一般来说很少使用</li>
<li>Standalone project：独立的工程，编译后不仅可以对内也可以对外使用</li>
</ul>
<p>前面两个应用场景很少，在这就不过多介绍了，想了解的可以自己百度一下～，我们着重介绍一下最后一个。</p>
<h3 id="动手撸一个-Standalone-project"><a href="#动手撸一个-Standalone-project" class="headerlink" title="动手撸一个 Standalone project"></a>动手撸一个 Standalone project</h3><p>既然是独立的工程，那么首先我们需要新建一个moudle。整个创建步骤如下：  </p>
<ul>
<li><p>新建moudle，类型可以选择Android。然后把目录删干净，只留下build.gradle文件并把build.gradle内部清空。</p>
</li>
<li><p>在moudle创建src/main/groovy目录，并新建其包名。同时在main目录下再新建resources/META-INF/gradle-plugins目录，在这个目录下编写一个和插件id名字相同的.properties文件，这样Gradle就可以找到插件实现了。  </p>
</li>
</ul>
<p>修改properties文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation-<span class="class"><span class="keyword">class</span>=<span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">plugin</span>.<span class="title">MyGradlePlugin</span></span></span><br></pre></td></tr></table></figure>
<p>修改build.gralde文件如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java-gradle-plugin&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;groovy&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;maven-publish&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group = <span class="string">&#x27;你的plugin包名&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;你的plugin版本号&#x27;</span></span><br><span class="line"></span><br><span class="line">publishing &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url = uri(<span class="string">&quot;$rootDir/repo&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    publications &#123;</span><br><span class="line">        maven(MavenPublication) &#123;</span><br><span class="line">            from components.java</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">&quot;libs&quot;</span>, <span class="attr">include:</span> [<span class="string">&quot;*.jar&quot;</span>])</span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;</span></span><br><span class="line">    <span class="comment">//gradle sdk</span></span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    <span class="comment">//groovy sdk</span></span><br><span class="line">    implementation localGroovy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖groovy相关插件是为了我们可以创建groovy文件。依赖maven是为了后续的本地上传以及调试。  </p>
<p>现在我们先写一个简单的试试效果。在你的目录下新建一个plugin：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGradlePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">         project.task(<span class="string">&#x27;MyGradlePlugin&#x27;</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println(<span class="string">&#x27;task in MyGradlePlugin&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我们点击Gradle -&gt; myGradlePlugin -&gt; publishing -&gt; publish。执行完成后，会在项目根目录下生成repo仓库。也就是之前在build.gradle中配置的url。  </p>
<p>既然本地maven已经生成了，接下来就是我们的引用了。我们在根目录的build.gradle引用我们本地的maven。示例如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">    maven &#123;</span><br><span class="line">        url = uri(<span class="string">&quot;$rootDir/repo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地maven依赖完成后，我们在根目录把自己引用的插件依赖下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;myGradlePlugin&quot;</span></span><br><span class="line"> dependencies &#123;</span><br><span class="line">        ...</span><br><span class="line">        classpath <span class="string">&#x27;com.xxxx.plugin:myGradlePlugin:1.0.0&#x27;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们sync一下。好了成功了。那我们如何验证我们自己写的plugin呢。我们在命令行输入：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">./gradlew MyGradlePlugin</span><br></pre></td></tr></table></figure>
<p>然后你会发现它输出了：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">Task:</span>MyGradlePlugin</span><br><span class="line">task <span class="keyword">in</span> MyGradlePlugin</span><br></pre></td></tr></table></figure>
<p>卧槽，卧槽，成功了！！</p>
<p>我们加大点难度，我们需要在build.gradle动态一些属性，并且自己写的plugin可以读到这些动态配置的属性。既然需要动态配置属性，那我们先定义一下需要动态的属性，新建一个Extension。具体示例如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGradlePluginExtension</span> &#123;</span></span><br><span class="line">    String versionName</span><br><span class="line">    String versionCode</span><br><span class="line">    String versionInfo</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;versionName = $versionName , versionCode = $versionCode , versionInfo = $versionInfo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了版本的属性，比如版本号，版本名称，版本信息等等。既然定义了，那么我们怎么读取这些属性呢。修改我们的plugin：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGradlePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        project.extensions.create(<span class="string">&quot;MyGradlePluginExtension&quot;</span>, MyGradlePluginExtension.<span class="keyword">class</span>)</span><br><span class="line">        project.task(<span class="string">&#x27;MyGradlePluginExtension&#x27;</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                MyGradlePluginExtension releaseInfo = project.MyGradlePluginExtension</span><br><span class="line">                println releaseInfo</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码修改后，可以看到逻辑如下，创建一个MyGradlePluginExtension，然后定义一个task为MyGradlePluginExtension（我这边为了方便2个名称用的同一个，其实可以分开）。也就是说我们在执行MyGradlePluginExtension的Task时候，会读取project的MyGradlePluginExtension的属性，然后将其输出。</p>
<p>重新上传maven，这里就不多说了，前面有提到过，然后我们在根目录新增如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">MyGradlePluginExtension &#123;</span><br><span class="line">    versionName = <span class="number">1.0</span></span><br><span class="line">    versionCode = <span class="number">1.0</span></span><br><span class="line">    versionInfo = <span class="string">&quot;测试第一版&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们执行这个task，会看到面板输出如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">Task :</span>MyGradlePluginExtension</span><br><span class="line">versionName = <span class="number">1.0</span> , versionCode = <span class="number">1.0</span> , versionInfo = 测试第一版</span><br></pre></td></tr></table></figure>
<p>动态配置生效了～</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节主要讲了Gradle插件的分类以及我们该如何去自己写一个插件并进行应用。更多自定义的操作可以查看官方文档：<a href="https://docs.gradle.org/4.1/userguide/custom_plugins.html#sec:custom_plugins_standalone_project">编写自定义插件</a></p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>Gradle简介及生命周期</title>
    <url>/gradle/lifecycle/</url>
    <content><![CDATA[<h3 id="Gradle简介"><a href="#Gradle简介" class="headerlink" title="Gradle简介"></a>Gradle简介</h3><p>gradle主要是由三个部分组成。</p>
<ul>
<li>groovy 核心语法：包括 groovy 基本语法、闭包、数据结构、面向对象等等。前面我们已经介绍过了。</li>
<li>Android DSL（build scrpit block）：Android 插件在 Gradle 所特有的东西，我们可以在不同的 build scrpit block 中去做不同的事情。</li>
<li>Gradle api：包括task，projects，setting等等。</li>
</ul>
<p>具体如下图：<br><img src="https://s3.ax1x.com/2021/01/19/sgahpq.png" alt="image"></p>
<h3 id="Gradle优势"><a href="#Gradle优势" class="headerlink" title="Gradle优势"></a>Gradle优势</h3><ul>
<li>灵活性：相对于 Maven、Ant 等构建工具，Gradle 提供了一系列的 API 让我们有能力去修改或定制项目的构建过程。</li>
<li>粒度性：源码的编译，资源的编译，都是一个一个Task的，我们可以修改task来达到精细控制上。</li>
<li>扩展性：Gradle 支持插件机制，所以我们可以复用这些插件，就如同复用库一样简单方便。</li>
<li>兼容性：Gradle 不仅自身功能强大，而且它还能兼容所有的Maven、Ant功能，也就是说，Gradle 吸取了所有构建工具的长处。</li>
</ul>
<h3 id="Gradle生命周期"><a href="#Gradle生命周期" class="headerlink" title="Gradle生命周期"></a>Gradle生命周期</h3><p>gradle的生命周期主要是如下三个部分：</p>
<ul>
<li>初始化阶段: 解析setting.gradle文件</li>
<li>配置阶段：解析所有的projects对象中的task，主要解析各个project下的build.gradle文件</li>
<li>执行阶段：执行project下具体的的task及其依赖task</li>
</ul>
<p>接下来我们看下gradle的流程图：<br><img src="https://s3.ax1x.com/2021/01/19/sgor0e.png" alt="image"></p>
<p>将上面流程可以再细化一下，细化之后如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzIwLzE3MTk1MDcxZTY1Y2JjZDg?x-oss-process=image/format,png" alt="image"></p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>初始化主要是读取setting.gradle文件中include的projects数量。我们可以通过如下命令查看project数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./gradlew project</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project <span class="emphasis">&#x27;APMProjetct&#x27;</span></span><br><span class="line">+--- Project <span class="emphasis">&#x27;:apm&#x27;</span></span><br><span class="line">+--- Project <span class="emphasis">&#x27;:app&#x27;</span></span><br><span class="line">\--- Project <span class="emphasis">&#x27;:aspectj&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置阶段"><a href="#配置阶段" class="headerlink" title="配置阶段"></a>配置阶段</h4><p>配置阶段主要是构造各个project下的task依赖关系图，需要注意的是，执行任何Gradle命令，在初始化阶段和配置阶段的逻辑都会被执行。</p>
<h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><p>配置完成后，便是依次执行指定的task以及依赖的task。</p>
<h4 id="生命周期的监听"><a href="#生命周期的监听" class="headerlink" title="生命周期的监听"></a>生命周期的监听</h4><p>在root project的build.gradle中添加如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置阶段开始前的监听回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">this</span>.beforeEvaluate &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置阶段后的监听回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">this</span>.afterEvaluate &#123;</span><br><span class="line">    println <span class="string">&#x27;配置阶段执行完毕...&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gradle执行完毕后的回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">this</span>.gradle.buildFinished &#123;</span><br><span class="line">    println <span class="string">&#x27;执行阶段执行完毕...&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 beforeEvaluate</span></span><br><span class="line"><span class="built_in">this</span>.gradle.beforeProject &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于 afterEvaluate</span></span><br><span class="line"><span class="built_in">this</span>.gradle.afterProject &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构建后，输出如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; Configure <span class="attr">project :</span></span><br><span class="line">配置阶段执行完毕...</span><br><span class="line"></span><br><span class="line">CONFIGURE SUCCESSFUL <span class="keyword">in</span> <span class="number">0</span>s</span><br><span class="line">执行阶段执行完毕...</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要是让你对gradle有一个初步对认识，以及gradle的生命周期。接下来我们会介绍最常用project以及task</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/start1225/p/9956558.html">Gradle系列之三 Gradle概述以及生命周期</a></p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>Gradle入门之Groovy语法</title>
    <url>/gradle/groovy_grammar/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>gradle是一个基于JVM的构建工具，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy 代码能够与Java代码很好地结合，也能用于扩展现有代码。由于其运行在 JVM 上的特性，Groovy可以使用其他Java语言编写的库。目前已经应用在多数Android技术体系中，比如，jenkins，插件化，组件化，模块化等等。如果你不了解gradle，那么前面几个技术点很难深入理解。  </p>
<p>Groovy 的语法跟 kotlin 类似，如果我们有 kotlin 的经验的话那么学习 groovy 会容易很多。下面我们一起来学习下groovy的核心语法，大家可以跟着样例敲一下加深理解、记忆。</p>
<h3 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h3><ul>
<li>构建在强大的Java语言之上 并 添加了从Python，Ruby和Smalltalk等语言中学到的 诸多特征，例如动态类型转换、闭包和元编程（metaprogramming）支持。</li>
<li>为Java开发者提供了 现代最流行的编程语言特性，而且学习成本很低（几乎为零）。</li>
<li>支持DSL（Domain Specific Languages领域定义语言）和其它简洁的语法，让代码变得易于阅读和维护。</li>
<li>受检查类型异常(Checked Exception)也可以不用捕获。</li>
<li>Groovy拥有处理原生类型，面向对象以及一个Ant DSL，使得创建Shell Scripts变得非常简单。</li>
<li>在开发Web，GUI，数据库或控制台程序时 通过 减少框架性代码 大大提高了开发者的效率。</li>
<li>支持单元测试和模拟（对象），可以 简化测试。</li>
<li>无缝集成 所有已经存在的 Java对象和类库。</li>
<li>直接编译成Java字节码，这样可以在任何使用Java的地方 使用Groovy。</li>
<li>支持函数式编程，不需要main函数。</li>
<li>一些新的运算符。</li>
<li>默认导入常用的包。</li>
<li>断言不支持jvm的-ea参数进行开关。</li>
<li>支持对对象进行布尔求值。</li>
<li>类不支持default作用域，且默认作用域为public。</li>
<li>groovy中基本类型也是对象，可以直接调用对象的方法。</li>
</ul>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="Groovy中的变量"><a href="#Groovy中的变量" class="headerlink" title="Groovy中的变量"></a>Groovy中的变量</h4><p>groovy中变量既可以像java一样是强类型的，也可以像kotlin一样是弱类型的。<br>代码示例如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        String a = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> b = <span class="string">&quot;Hello Silence&quot;</span></span><br><span class="line">        println(a)</span><br><span class="line">        println(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Hello World</span></span><br><span class="line"><span class="attribute">Hello Silence</span></span><br></pre></td></tr></table></figure>
<h4 id="Groovy中的运算符和条件控制"><a href="#Groovy中的运算符和条件控制" class="headerlink" title="Groovy中的运算符和条件控制"></a>Groovy中的运算符和条件控制</h4><p>与java一致，这里不过多介绍</p>
<h4 id="Groovy中的字符串"><a href="#Groovy中的字符串" class="headerlink" title="Groovy中的字符串"></a>Groovy中的字符串</h4><p>Groovy提供了多种表示String字面量的方法。Groovy中的字符串可以用单引号（’），双引号（“）或三引号（“““）括起来。此外，由三重引号括起来的Groovy字符串可以跨越多行。  </p>
<p>示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        String a = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> b = <span class="string">&quot;Hello Silence&quot;</span></span><br><span class="line">        <span class="keyword">def</span> c = <span class="string">&#x27;&#x27;&#x27;Hello World</span></span><br><span class="line"><span class="string">Hello Silence&#x27;&#x27;&#x27;</span></span><br><span class="line">        println(a)</span><br><span class="line">        println(b)</span><br><span class="line">        println(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Hello World</span></span><br><span class="line"><span class="attribute">Hello Silence</span></span><br><span class="line"><span class="attribute">Hello World</span></span><br><span class="line"><span class="attribute">Hello Silence</span></span><br></pre></td></tr></table></figure>
<h5 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h5><p>Groovy的扩展和kotlin的一样，示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        String a = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">        <span class="keyword">def</span> b = <span class="string">&quot;Hello $a&quot;</span></span><br><span class="line">        println(a)</span><br><span class="line">        println(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Hello World</span></span><br><span class="line"><span class="attribute">Hello Hello World</span></span><br></pre></td></tr></table></figure>
<h5 id="字符串的索引"><a href="#字符串的索引" class="headerlink" title="字符串的索引"></a>字符串的索引</h5><p>Groovy中的字符串是字符的有序序列。字符串中的单个字符可以通过其位置访问。这由索引位置给出。</p>
<p>字符串索引从零开始，以小于字符串长度的一个结束。Groovy还允许负索引从字符串的末尾开始计数。</p>
<p>具体示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        String a = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">        println(a[<span class="number">1</span>])<span class="comment">//输出坐标为1的内容</span></span><br><span class="line">        println(a[<span class="number">-2</span>])<span class="comment">//输出坐标为倒数第二的内容</span></span><br><span class="line">        println(a[<span class="number">1.</span><span class="number">.2</span>])<span class="comment">//输出坐标区间为1-2的内容</span></span><br><span class="line">        println(a[<span class="number">2.</span><span class="number">.5</span>])<span class="comment">//输出坐标区间为2-5的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">e</span></span><br><span class="line"><span class="attribute">l</span></span><br><span class="line"><span class="attribute">el</span></span><br><span class="line"><span class="attribute">llo</span> </span><br></pre></td></tr></table></figure>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Range范围"><a href="#Range范围" class="headerlink" title="Range范围"></a>Range范围</h4><p>范围是指定值序列的速记。范围由序列中的第一个和最后一个值表示，Range可以是包含或排除。包含范围包括从第一个到最后一个的所有值，而独占范围包括除最后一个之外的所有值。</p>
<ul>
<li>1..10 — 包含范围的示例</li>
<li>1 .. &lt;10 - 独占范围的示例</li>
<li>‘a’..’x’ - 范围也可以由字符组成</li>
<li>10..1 - 范围也可以按降序排列</li>
<li>‘x’..’a’ - 范围也可以由字符组成并按降序排列。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>contains()</td>
<td>检查范围是否包含特定值</td>
</tr>
<tr>
<td>get()</td>
<td>返回此范围中指定位置处的元素。</td>
</tr>
<tr>
<td>getFrom()</td>
<td>获得此范围的下限值。</td>
</tr>
<tr>
<td>getTo()</td>
<td>获得此范围的上限值。</td>
</tr>
<tr>
<td>isReverse()</td>
<td>这是一个反向的范围，反向迭代</td>
</tr>
<tr>
<td>size()</td>
<td>获得范围的元素值。</td>
</tr>
<tr>
<td>subList()</td>
<td>返回此指定的fromIndex（包括）和toIndex（排除）之间的此范围部分的视图。</td>
</tr>
</tbody></table>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>列表是用于存储数据项集合的结构。在 Groovy中，List保存了一系列对象引用。</p>
<p>List中的对象引用占据序列中的位置，并通过整数索引来区分。</p>
<p>groovy 中的一个列表中的数据可以是任意类型。这和java下集合列表有些不同，java下的列表是同种类型的数据集合。</p>
<p>groovy中列表还可以嵌套列表。如[1,2,[3,4,5],“aaa”]groovy列表内置有反转方法 reverse()。调用 List.reverse() 可以实现列表反转。groovy列表内置有排序方法 sort()。调用 List.sort() 可以实现列表排序。空列表表示为[]声明一个空集合。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map是对象引用的无序集合。Map集合中的元素由键值访问。Map中使用的键可以是任何类。当我们插入到Map集合中时，需要两个值：键和值。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><p>Groovy中的面向对象和其他任何的面向对象语言一样，存在类和对象的概念。不过在groovy新增了一个trait的关键字，名为特征。</p>
<h4 id="Groovy中的特征"><a href="#Groovy中的特征" class="headerlink" title="Groovy中的特征"></a>Groovy中的特征</h4><p>特征是语言结构的构造，其他包括：</p>
<ul>
<li>行为的组成</li>
<li>接口运行时的实现</li>
<li>与静态类型检查/编译的兼容性  </li>
</ul>
<p>使用trait关键字定义特征。示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Student st = <span class="keyword">new</span> Student();</span><br><span class="line">        st.StudentID = <span class="number">1</span></span><br><span class="line">        st.Marks1 = <span class="number">10</span></span><br><span class="line">        st.DisplayMarks()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Marks</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> DisplayMarks() &#123;</span><br><span class="line">        println(<span class="string">&quot;Display Marks&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Marks</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> StudentID</span><br><span class="line">    <span class="keyword">int</span> Marks1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Display</span> <span class="attribute">Marks</span></span><br></pre></td></tr></table></figure>
<p>上述示例中trait是类似接口的存在，同理，trait也可以实现接口。<br>示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Student st = <span class="keyword">new</span> Student();</span><br><span class="line">        st.StudentID = <span class="number">1</span></span><br><span class="line">        st.Marks1 = <span class="number">10</span></span><br><span class="line">        st.DisplayMarks()</span><br><span class="line">        st.DisplayTotal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Total</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> DisplayTotal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Marks</span> <span class="keyword">implements</span> <span class="title">Total</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> DisplayMarks() &#123;</span><br><span class="line">        println(<span class="string">&quot;Display Marks&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> DisplayTotal() &#123;</span><br><span class="line">        println(<span class="string">&quot;Display Total&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Marks</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> StudentID</span><br><span class="line">    <span class="keyword">int</span> Marks1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Display</span> <span class="variable">Marks</span></span><br><span class="line"><span class="built_in">Display</span> <span class="built_in">Total</span></span><br></pre></td></tr></table></figure>
<h4 id="扩展特征"><a href="#扩展特征" class="headerlink" title="扩展特征"></a>扩展特征</h4><p>特征的扩展则使用extends关键字，示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Marks</span> &#123;</span></span><br><span class="line">   <span class="keyword">void</span> DisplayMarks() &#123;</span><br><span class="line">      println(<span class="string">&quot;Marks1&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Total</span> <span class="keyword">extends</span> <span class="title">Marks</span> &#123;</span></span><br><span class="line">   <span class="keyword">void</span> DisplayMarks() &#123;</span><br><span class="line">      println(<span class="string">&quot;Total&quot;</span>);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="Groovy中的闭包"><a href="#Groovy中的闭包" class="headerlink" title="Groovy中的闭包"></a>Groovy中的闭包</h3><p>闭包是一个短的匿名代码块，个人理解是和lamda是差不多的。<br>下面是一个简单的闭包例子，代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">def</span> test = &#123; println <span class="string">&quot;Hello World&quot;</span> &#125;</span><br><span class="line">        test.call()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Hello World</span></span><br></pre></td></tr></table></figure>
<h4 id="闭包中的形式参数"><a href="#闭包中的形式参数" class="headerlink" title="闭包中的形式参数"></a>闭包中的形式参数</h4><p>闭包也可以包含形式参数，以使它们更有用，就像Groovy中的方法一样。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">def</span> hello=<span class="string">&quot;Hello&quot;</span></span><br><span class="line">        <span class="keyword">def</span> test = &#123;params -&gt; println <span class="string">&quot;$hello World&quot;</span> &#125;</span><br><span class="line">        test.call()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果也是Hello World。<br>当然我们还有另外一种写法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">def</span> test = &#123; println <span class="string">&quot;Hello $&#123;it&#125;&quot;</span> &#125;</span><br><span class="line">        test.call(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以把上面两种的形式，进行组合，示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">def</span> hello=<span class="string">&quot;Hello&quot;</span></span><br><span class="line">        <span class="keyword">def</span> test = &#123; params -&gt;println <span class="string">&quot;$hello $&#123;params&#125;&quot;</span> &#125;</span><br><span class="line">        test.call(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在方法中使用闭包"><a href="#在方法中使用闭包" class="headerlink" title="在方法中使用闭包"></a>在方法中使用闭包</h4><p>类似kotlin的方法中可以传匿名函数一样。示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">def</span> hello=<span class="string">&quot;Hello&quot;</span></span><br><span class="line">        <span class="keyword">def</span> test = &#123; params -&gt;println <span class="string">&quot;$hello $&#123;params&#125;&quot;</span> &#125;</span><br><span class="line">        Study.Display(test)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="keyword">static</span> Display(clo) &#123;</span><br><span class="line">        clo.call(<span class="string">&quot;Silence&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Hello Silence</span></span><br></pre></td></tr></table></figure>
<h3 id="Groovy中的Json"><a href="#Groovy中的Json" class="headerlink" title="Groovy中的Json"></a>Groovy中的Json</h3><p>我们先来看看 groovy 中对象与 json 字符串之间的相互转换：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.json.JsonOutput</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">def</span> study = [<span class="keyword">new</span> Person(<span class="string">&quot;silence&quot;</span>, <span class="number">25</span>),</span><br><span class="line">                     <span class="keyword">new</span> Person(<span class="string">&quot;david&quot;</span>, <span class="number">26</span>)]</span><br><span class="line">        <span class="keyword">def</span> json=JsonOutput.toJson(study)</span><br><span class="line">        println json</span><br><span class="line">        <span class="comment">//带格式的输出json</span></span><br><span class="line">        println JsonOutput.prettyPrint(json)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> String name</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setName(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> getAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setAge(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">&quot;age&quot;</span>:<span class="number">25</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;silence&quot;</span>&#125;,&#123;<span class="attr">&quot;age&quot;</span>:<span class="number">26</span>,<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;david&quot;</span>&#125;]</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;age&quot;</span>: <span class="number">25</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;silence&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;age&quot;</span>: <span class="number">26</span>,</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;david&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇主要讲解了groovy的基本语法，整体上是和kotlin和java的语法是差不多的。相对而言，熟悉kotlin和java的，上手groovy会很快。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/u010289802/article/details/105752715">暴力突破 Gradle 自动化项目构建（二）- Groovy 核心语法</a><br><a href="https://www.w3cschool.cn/groovy/">Groovy教程</a></p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>Gradle入门之Groovy元编程</title>
    <url>/gradle/meta_programming/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Groovy的元编程是指groovy运行时，可以理解成编写代码所执行的时期，也就是Runtime。在比如有解释执行的Js,编译执行的java，还有运行时期执行的代码java反射。  </p>
<p>Groovy运行时的处理逻辑如下图：<br><img src="https://s3.ax1x.com/2021/01/14/sdrfyj.png" alt="untitled diagram.png"></p>
<h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><p>按照上图所示，我们可以自己写一个Demo，示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Study</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">def</span> person = <span class="keyword">new</span> Personal(<span class="attr">name:</span> <span class="string">&quot;Silence&quot;</span>, <span class="attr">age:</span> <span class="number">26</span>)</span><br><span class="line">        println(person.printName())</span><br><span class="line">        println(person.printAge())</span><br><span class="line">        println(person.sex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Personal</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> String name</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String printName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My name is $name&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String printAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My ag is $age&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">My name is Silence</span><br><span class="line">My ag is <span class="number">26</span></span><br><span class="line">Exception in thread &quot;main&quot; groovy.lang.MissingPropertyException: No such property: sex for class: Personal</span><br><span class="line">	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:<span class="number">65</span>)</span><br><span class="line">	at org.codehaus.groovy.runtime.callsite.GetEffectivePogoPropertySite.getProperty(GetEffectivePogoPropertySite.java:<span class="number">87</span>)</span><br><span class="line">	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:<span class="number">329</span>)</span><br><span class="line">	at Study.main(Study.groovy:<span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到前两个日志是正常输出的，第三个控制台则提示MissingPropertyException。也就是上图中，所以逻辑都没进去导致异常输出。</p>
<p>我们在看看如果我们复写invokeMethod方法时的输出效果，代码修改如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Personal</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> String name</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String printName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My name is $name&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String printAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My ag is $age&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Object invokeMethod(String name, Object args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this invoke method is $name,this params is $args&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">My name is Silence</span><br><span class="line">My ag is <span class="number">26</span></span><br><span class="line"><span class="keyword">this</span> invoke method is sex,<span class="keyword">this</span> params is []</span><br></pre></td></tr></table></figure>
<p>然后我们看看重写methodMissing方法后：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Personal</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> String name</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String printName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My name is $name&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String printAge() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My ag is $age&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Object invokeMethod(String name, Object args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this invoke method is $name,this params is $args&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object methodMissing(String name, Object args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;this Missing method is $name,this params is $args&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">My name is Silence</span><br><span class="line">My ag is <span class="number">26</span></span><br><span class="line"><span class="keyword">this</span> Missing method is sex,<span class="keyword">this</span> params is []</span><br></pre></td></tr></table></figure>
<p>可以看出，两个方法都重写时，优先调用methodMissing。如果找不到才会调用invokeMethod。  </p>
<h3 id="MetaClass"><a href="#MetaClass" class="headerlink" title="MetaClass"></a>MetaClass</h3><p>Metaclasses在方法解析中起到核心作用，对于来自groovy代码的每个方法调用，Groovy将找到给定对象的MetaClass，并通过MetaClass＃invokeMethod将方法解析委托给Metaclasses，不应该与GroovyObject＃invokeMethod混淆，后者恰好是Metaclasses最终可能调用的方法。</p>
<h4 id="注入新字段"><a href="#注入新字段" class="headerlink" title="注入新字段"></a>注入新字段</h4><p>现在我们通过metaClass给Personal注入一个新属性看看：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Personal.metaClass.sex = <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="keyword">def</span> person = <span class="keyword">new</span> Personal(<span class="attr">name:</span> <span class="string">&quot;Silence&quot;</span>, <span class="attr">age:</span> <span class="number">26</span>)</span><br><span class="line">println(person.printName())</span><br><span class="line">println(person.printAge())</span><br><span class="line">println(person.sex)</span><br></pre></td></tr></table></figure>
<p>可以看出我们注入了一个sex的字段，输入结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">My name is Silence</span><br><span class="line">My age is <span class="number">26</span></span><br><span class="line">男</span><br></pre></td></tr></table></figure>
<p>当然了，注入静态变量也是类似，加上static即可。</p>
<h3 id="注入新方法"><a href="#注入新方法" class="headerlink" title="注入新方法"></a>注入新方法</h3><p>看到我们输入性别的时候，发现好像和上面对比，不工整，那就自己整一个工整的，修改代码：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Personal.metaClass.sex = <span class="string">&quot;男&quot;</span></span><br><span class="line">Personal.metaClass.printSex = &#123; -&gt;</span><br><span class="line">    <span class="string">&quot;My sex is $sex&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> person = <span class="keyword">new</span> Personal(<span class="attr">name:</span> <span class="string">&quot;Silence&quot;</span>, <span class="attr">age:</span> <span class="number">26</span>)</span><br><span class="line">println(person.printName())</span><br><span class="line">println(person.printAge())</span><br><span class="line">println(person.printSex())</span><br></pre></td></tr></table></figure>
<p>输出结果可想而之：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">My <span class="built_in">name</span> <span class="keyword">is</span> Silence</span><br><span class="line">My age <span class="keyword">is</span> <span class="number">26</span></span><br><span class="line">My sex <span class="keyword">is</span> 男</span><br></pre></td></tr></table></figure>
<p>这下工整了～。当然了，注入静态方法也是类似，加上static即可。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看出，我们可以通过metaClass给类新增变量，新增方法。那么这个和直接在类这种提供有什么区别呢？<br>举个例子：引入第三方库，其中的某个类有我们想用的方法，但是这个方法又不够全，想给里面添加点自己的方法。通常是extends它进而扩展，但是如果是final 类，任何类不能继承它，只能用它已有的方法。这个时候groovy的动态添加就有了大展身手的地方。不修改、不继承，通过metaclass变相的对原有的类进行了扩展。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/qq_39969226/article/details/102918552?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-6&spm=1001.2101.3001.4242">groovy中的元编程</a><br><a href="https://blog.csdn.net/usagoole/article/details/87390383">Groovy笔记之元编程</a></p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>Gradle核心之Project</title>
    <url>/gradle/project/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>project在gradle里起到里重要的作用，上节我们也说过可以通过<code>./gradlew projects</code>打印当前项目下所有的project，准确的说是有build.gradle的文件既是一个project。而有多少project取决于在setting.gradle文件中设置了多少个。一个project对应一个输出，而具体输出什么取决于build.gradle里面的内容。</p>
<h3 id="Project核心API"><a href="#Project核心API" class="headerlink" title="Project核心API"></a>Project核心API</h3><p>每个工程下都有一个build.gradle文件。根目录的build.gradle可以管理子工程下面的build.gradle。下面具体看下project相关api。</p>
<h4 id="getAllProjects"><a href="#getAllProjects" class="headerlink" title="getAllProjects()"></a>getAllProjects()</h4><p>我们可以通过getAllprojects打印出所有的project，可以理解成和<code>./gradlew projects</code>命令一样。示例带入如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">getAllprojects().eachWithIndex &#123; Project entry, <span class="keyword">int</span> i -&gt;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;RootProject-------$&#123;entry.name&#125;&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;SubProject-------$&#123;entry.name&#125;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RootProject-------APMProjetct</span><br><span class="line">SubProject-------apm</span><br><span class="line">SubProject-------app</span><br><span class="line">SubProject-------aspectj</span><br></pre></td></tr></table></figure>
<h4 id="getSubprojects"><a href="#getSubprojects" class="headerlink" title="getSubprojects()"></a>getSubprojects()</h4><p>此方法是获取所有子工程的实例，示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">getSubprojects().eachWithIndex &#123; Project entry, <span class="keyword">int</span> i -&gt;</span><br><span class="line">        println(<span class="string">&quot;SubProject-------$&#123;entry.name&#125;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; Configure project :</span><br><span class="line">SubProject-------apm</span><br><span class="line">SubProject-------app</span><br><span class="line">SubProject-------aspectj</span><br></pre></td></tr></table></figure>
<h4 id="getRootProject"><a href="#getRootProject" class="headerlink" title="getRootProject()"></a>getRootProject()</h4><p>既然我们可以拿到所有的子节点，那我们依然可以单独获取到根节点，示例代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">println</span><span class="params">(<span class="string">&quot;the root project name is $&#123;getRootProject().name&#125;&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">&gt; Configure project :</span><br><span class="line">the<span class="built_in"> root</span> project<span class="built_in"> name</span> <span class="literal">is</span> APMProjetct</span><br></pre></td></tr></table></figure>
<h4 id="getParent"><a href="#getParent" class="headerlink" title="getParent()"></a>getParent()</h4><p>此方法是用于在子工程获取父工程的实例，示例代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">println</span><span class="params">(<span class="string">&quot;the parent project name is $&#123;getParent().name&#125;&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>输出结果可想而知：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&gt; Configure project :aspectj</span><br><span class="line"><span class="keyword">the</span> parent project <span class="built_in">name</span> <span class="keyword">is</span> APMProjetct</span><br></pre></td></tr></table></figure>
<h4 id="projects"><a href="#projects" class="headerlink" title="projects()"></a>projects()</h4><p>project是为了让我们在父工程的build.gradle文件，针对子project做一些单独的处理，比如这样：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">project</span><span class="params">(<span class="string">&quot;app&quot;</span>)</span></span> &#123;</span><br><span class="line">    apply plugin: <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="allprojects"><a href="#allprojects" class="headerlink" title="allprojects()"></a>allprojects()</h4><p>allprojects 表示用于配置当前 project 及其每一个子 project，在 allprojects 中我们一般用来配置一些通用的配置，比如最常见的全局仓库配置。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">allprojects</span> &#123;</span><br><span class="line">    <span class="variable">repositories</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">google</span>()</span></span><br><span class="line">        <span class="function"><span class="title">jcenter</span>()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="subprojects"><a href="#subprojects" class="headerlink" title="subprojects()"></a>subprojects()</h4><p>此方法是为了让我们对所有的子project做一些配置，比如这样：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">subprojects</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">project</span>.plugins.hasPlugin(<span class="string">&quot;com.android.library&quot;</span>))&#123;</span><br><span class="line">        apply <span class="keyword">from</span> <span class="string">&quot;../uploadMaven.gradle&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ext扩展属性"><a href="#ext扩展属性" class="headerlink" title="ext扩展属性"></a>ext扩展属性</h4><p>我们可以通过ext扩展属性默认修改其他工程build.gradle的文件配置。比如我在root project中新增了如下属性：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    minSdkVersion = <span class="number">21</span></span><br><span class="line">    targetSdkVersion = <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们可以在子工程的build.gralde文件修改文件如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">30</span></span><br><span class="line">    buildToolsVersion <span class="string">&quot;30.0.1&quot;</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.xxxxx.apmprojetct&quot;</span></span><br><span class="line">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.ext.targetSdkVersion</span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外我们还可以通过apply的形式依赖自己新增的gradle文件，比如我们可以新增一个config.gradle文件，具体内容如下:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            storeFile file(<span class="string">&#x27;xxx.jks&#x27;</span>)</span><br><span class="line">            storePassword <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">            keyAlias <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">            keyPassword <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">            v1SigningEnabled <span class="literal">true</span></span><br><span class="line">            v2SigningEnabled <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            storeFile file(<span class="string">&#x27;xxx.jks&#x27;</span>)</span><br><span class="line">            storePassword <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">            keyAlias <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">            keyPassword <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">            v1SigningEnabled <span class="literal">true</span></span><br><span class="line">            v2SigningEnabled <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们可以在工程中这样使用：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">from:</span> <span class="string">&#x27;config.gradle&#x27;</span></span><br><span class="line">android &#123;</span><br><span class="line">      buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            shrinkResources <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">            versionNameSuffix <span class="string">&quot;_dev&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gradle文件操作"><a href="#gradle文件操作" class="headerlink" title="gradle文件操作"></a>gradle文件操作</h3><p>gradle中操作本地文件可以使用的是Project.file()方法，通过指定文件的相对路径或者绝对路径来进行操作。比如我们可以新建一个文件，可以查看一个文件的绝对路径，也可以判断一个文件是否存在，示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用相对路径</span></span><br><span class="line">File configFile = file(<span class="string">&#x27;src/main/java/test.java&#x27;</span>)</span><br><span class="line">configFile.createNewFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用绝对路径</span></span><br><span class="line">configFile = file(‘<span class="regexp">/Users/</span>xxx<span class="regexp">/xxx/</span>src<span class="regexp">/main/</span>java/test.java’)</span><br><span class="line">println(configFile.absolutePath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个文件对象</span></span><br><span class="line">configFile = file(<span class="keyword">new</span> File(<span class="string">&#x27;src/main/java/test.java&#x27;</span>))</span><br><span class="line"><span class="comment">// 打印文件是否存在</span></span><br><span class="line">println(configFile.exists())</span><br></pre></td></tr></table></figure>
<p>同步一下，输出结果如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>xxx<span class="regexp">/xxx/</span>src<span class="regexp">/main/</span>java/test.java</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="文件集合"><a href="#文件集合" class="headerlink" title="文件集合"></a>文件集合</h4><p>Gradle中文件集合就是类似于java中的数组，Gradle中使用FileCollection接口表示，我们可以使用Project.files()方法来获得一个文件集合对象,所有文件集合都是用到的时候才会创建。示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">FileCollection collection = files(<span class="string">&#x27;src/test1.txt&#x27;</span>,</span><br><span class="line">        <span class="keyword">new</span> File(<span class="string">&#x27;src/test2.txt&#x27;</span>),</span><br><span class="line">        [<span class="string">&#x27;src/test3.txt&#x27;</span>, <span class="string">&#x27;src/test4.txt&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>我们可以这样遍历文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历所有集合</span></span><br><span class="line">collection.each &#123; File file -&gt;</span><br><span class="line">    println file.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以这样转换文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把文件集合转换为Set类型</span></span><br><span class="line">Set set1 = collection.files</span><br><span class="line">Set set2 = collection <span class="keyword">as</span> Set</span><br><span class="line"><span class="comment">// 把文件集合转换为List类型</span></span><br><span class="line">List list = collection <span class="keyword">as</span> List</span><br><span class="line"><span class="comment">// 把文件集合转换为String类型</span></span><br><span class="line">String path = collection.asPath</span><br><span class="line"><span class="comment">// 把文件集合转换为File类型</span></span><br><span class="line">File file1 = collection.singleFile</span><br><span class="line">File file2 = collection <span class="keyword">as</span> File</span><br></pre></td></tr></table></figure>
<p>除此之外，我们还可以新增或者删除一个文件，比如这样：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加或者删除一个集合</span></span><br><span class="line"><span class="keyword">def</span> union = collection + files(<span class="string">&#x27;src/test5.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> different = collection - files(<span class="string">&#x27;src/test3.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h4><p>文件树你可以理解成是一个有层级结构的文件集合，所以文件树中包含了所有文件集合的操作。我们可以使用Project.fileTree()方法来创建文件树对象，还可以使用过虑条件来包含或排除相关文件。示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定目录创建文件树对象</span></span><br><span class="line">FileTree tree = fileTree(<span class="attr">dir:</span> <span class="string">&#x27;src/main&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给文件树对象添加包含指定文件</span></span><br><span class="line">tree.include <span class="string">&#x27;**/*.java&#x27;</span></span><br><span class="line"><span class="comment">// 给文件树对象添加排除指定文件</span></span><br><span class="line">tree.exclude <span class="string">&#x27;**/Abstract*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路径创建文件树对象，同时指定包含的文件</span></span><br><span class="line">tree = fileTree(<span class="string">&#x27;src&#x27;</span>).include(<span class="string">&#x27;**/*.java&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过闭包创建文件树</span></span><br><span class="line">tree = fileTree(<span class="string">&#x27;src&#x27;</span>) &#123;</span><br><span class="line">    include <span class="string">&#x27;**/*.java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过map创建文件树</span></span><br><span class="line">tree = fileTree(<span class="attr">dir:</span> <span class="string">&#x27;src&#x27;</span>, <span class="attr">include:</span> <span class="string">&#x27;**/*.java&#x27;</span>)</span><br><span class="line">tree = fileTree(<span class="attr">dir:</span> <span class="string">&#x27;src&#x27;</span>, <span class="attr">includes:</span> [<span class="string">&#x27;**/*.java&#x27;</span>, <span class="string">&#x27;**/*.xml&#x27;</span>])</span><br><span class="line">tree = fileTree(<span class="attr">dir:</span> <span class="string">&#x27;src&#x27;</span>, <span class="attr">include:</span> <span class="string">&#x27;**/*.java&#x27;</span>, <span class="attr">exclude:</span> <span class="string">&#x27;**/*test*/**&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>既然说到了文件树的创建，当然，我们也可以对文件树进行一些业务操作，比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历文件树的所有文件</span></span><br><span class="line">tree.each &#123;File file -&gt;</span><br><span class="line">    println file</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过虑生成新的文件树对象</span></span><br><span class="line">FileTree filtered = tree.matching &#123;</span><br><span class="line">    include <span class="string">&#x27;org/gradle/api/**&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用“+”号合并两个文件树，同文件集合的“+”操作一样</span></span><br><span class="line">FileTree sum = tree + fileTree(<span class="attr">dir:</span> <span class="string">&#x27;src/test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问文件树中各项内容</span></span><br><span class="line">tree.visit &#123;element -&gt;</span><br><span class="line">    println <span class="string">&quot;$element.relativePath =&gt; $element.file&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h4><p>我们可以通过copy的task对文件进行copy动作，并且可以指定copy内容和过滤copy内容，还可以在copy的过程中对文件进行重命名操作，先来个简单的，比如我需要从A目录copy到B目录，那我们可以这样做：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task copyTask(<span class="attr">type:</span> Copy) &#123;</span><br><span class="line">    from <span class="string">&#x27;src/main/java/fileA&#x27;</span></span><br><span class="line">    into <span class="string">&#x27;src/main/kotlin/fileB&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们也是支持批量copy的，比如这样：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task copyTask(<span class="attr">type:</span> Copy) &#123;</span><br><span class="line">    <span class="comment">// 拷贝src/main/webapp目录下所有的文件</span></span><br><span class="line">    from <span class="string">&#x27;src/main/java&#x27;</span></span><br><span class="line">    <span class="comment">// 拷贝单独的一个文件</span></span><br><span class="line">    from <span class="string">&#x27;src/main/res/index.html&#x27;</span></span><br><span class="line">    <span class="comment">// 从Zip压缩文件中拷贝内容</span></span><br><span class="line">    from zipTree(<span class="string">&#x27;src/main/assets.zip&#x27;</span>)</span><br><span class="line">    <span class="comment">// 拷贝到的目标目录</span></span><br><span class="line">    into <span class="string">&#x27;src/main/mouble&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们也说了，我们可以在copy的时候进行重命名，最常见的场景，就是项目拆解模块的时候，我们需要重新命名，那我们可以这样操作：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task rename(<span class="attr">type:</span> Copy) &#123;</span><br><span class="line">    from <span class="string">&#x27;moudleA/src/main/res/&#x27;</span></span><br><span class="line">    into <span class="string">&#x27;moudleB/src/main/res/&#x27;</span></span><br><span class="line">    <span class="comment">// 使用一个闭包方式重命名文件</span></span><br><span class="line">    rename &#123; String fileName -&gt;</span><br><span class="line">        fileName.replace(<span class="string">&#x27;moudleA&#x27;</span>, <span class="string">&#x27;moudleB&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大量的节约了手动重命名的成本。<br>同样我们也可以新增过滤条件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task copyTaskWithPatterns(<span class="attr">type:</span> Copy) &#123;</span><br><span class="line">    from <span class="string">&#x27;src/main/drawable&#x27;</span></span><br><span class="line">    into <span class="string">&#x27;src/main/drawable-xxhdpi&#x27;</span></span><br><span class="line">    include <span class="string">&#x27;*.jpg&#x27;</span></span><br><span class="line">    exclude &#123; details -&gt; details.file.name.endsWith(<span class="string">&#x27;.png&#x27;</span>) &amp;&amp;</span><br><span class="line">                         details.file.text.contains(<span class="string">&#x27;.webp&#x27;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们还可以拷贝的同时，并删除对应目录文件，我们可以这么操作：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task libs(<span class="attr">type:</span> Sync) &#123;</span><br><span class="line">    from configurations.runtime</span><br><span class="line">    <span class="comment">// 拷贝之前会把$buildDir/libs目录下所有的清除</span></span><br><span class="line">    into <span class="string">&quot;$buildDir/libs&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们简单的介绍了projects的相关操作以及在gradle中我们如何去操作文件，当然，gradle中除了projects，还有一个核心的task，这个我们放在下一节进行介绍。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/u010289802/article/details/105891913">暴力突破 Gradle 自动化项目构建（五）- Gradle 核心之 Project</a><br><a href="https://blog.csdn.net/u011077027/article/details/103251170">gradle操作文件详解</a></p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>Gradle核心之Task</title>
    <url>/gradle/task/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>gradle命令最终是通过task去执行的，可见task在gradle中的重要性。</p>
<h3 id="Task的定义与配置"><a href="#Task的定义与配置" class="headerlink" title="Task的定义与配置"></a>Task的定义与配置</h3><p>task的定义有两种形式，一个是直接通过task函数去创建，另一个是通过task的create方法去创建，示例代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task test1Task&#123;</span><br><span class="line">    println(<span class="string">&quot;test1Task&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.create(<span class="attr">name:</span><span class="string">&#x27;test2Task&#x27;</span>)&#123;</span><br><span class="line">    println(<span class="string">&quot;test2Task&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚刚我们为task指定了一个name。我们可以看看除了name我们还可以指定什么，我们打开Task的源代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Task</span>&gt;, <span class="title">ExtensionAware</span> </span>&#123;</span><br><span class="line">    String TASK_NAME = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String TASK_DESCRIPTION = <span class="string">&quot;description&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String TASK_GROUP = <span class="string">&quot;group&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String TASK_TYPE = <span class="string">&quot;type&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String TASK_DEPENDS_ON = <span class="string">&quot;dependsOn&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String TASK_OVERWRITE = <span class="string">&quot;overwrite&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String TASK_ACTION = <span class="string">&quot;action&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor arguments for the Task</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.7</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Incubating</span></span><br><span class="line">    String TASK_CONSTRUCTOR_ARGS = <span class="string">&quot;constructorArgs&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们介绍下这些属性都是用来干嘛的。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>ask 名字</td>
<td>必须指定</td>
</tr>
<tr>
<td>description</td>
<td>task 的描述信息</td>
<td>null</td>
</tr>
<tr>
<td>group</td>
<td>该 task 所属组</td>
<td>null</td>
</tr>
<tr>
<td>type</td>
<td>需要创建的 task Class</td>
<td>DefaultTask</td>
</tr>
<tr>
<td>dependsOn</td>
<td>该 task 所依赖的 task 集合</td>
<td>[]</td>
</tr>
<tr>
<td>overwrite</td>
<td>替换一个已存在的 task</td>
<td>false</td>
</tr>
<tr>
<td>action</td>
<td>当 task 执行的时候，需要执行的闭包 closure 或 行为 Action</td>
<td>null</td>
</tr>
<tr>
<td>constructorArgs</td>
<td>传递到 task Class 构造器中的参数</td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="Task的执行"><a href="#Task的执行" class="headerlink" title="Task的执行"></a>Task的执行</h3><p>前面我们也介绍了gradle的生命周期，通过前面的文章我们可以知道，在执行阶段gradle会输出每个gradle执行的内容。当然我们还可以通过<code>doFirst</code>和<code>doLast</code>为我们的 task 指定执行阶段要执行的代码。关于这2个的属性介绍如下：</p>
<ul>
<li>doFirst :表示当前task执行最开始的时候被调用的Action。</li>
<li>doLast：表示单曲task即将执行完的时候被调用的Action。</li>
</ul>
<p>我们可以验证下上面两个属性，执行代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task test1Task &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println(<span class="string">&quot;test1Task first&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;test1Tasking...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        println(<span class="string">&quot;test1Task last&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; Configure <span class="attr">project :</span></span><br><span class="line">test1Tasking...</span><br><span class="line"></span><br><span class="line">&gt; <span class="attr">Task :</span>test1Task</span><br><span class="line">test1Task first</span><br><span class="line">test1Task last</span><br><span class="line">:test1Task spend <span class="number">17</span>ms</span><br></pre></td></tr></table></figure>
<h3 id="Task的执行顺序"><a href="#Task的执行顺序" class="headerlink" title="Task的执行顺序"></a>Task的执行顺序</h3><p>首先了解下，控制task执行顺序的方式有两种。</p>
<ul>
<li>通过dependsOn强依赖的方式</li>
<li>通过api指定执行顺序</li>
</ul>
<p><img src="https://s3.ax1x.com/2021/01/25/sLQTc4.png" alt="image"></p>
<h4 id="dependsOn强依赖"><a href="#dependsOn强依赖" class="headerlink" title="dependsOn强依赖"></a>dependsOn强依赖</h4><p>强依赖的方式又分为两种，动态依赖及静态依赖，我们来举个例子：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task test1Task &#123;</span><br><span class="line">    println(<span class="string">&quot;test1Tasking...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task test2Task &#123;</span><br><span class="line">    println(<span class="string">&quot;test2Tasking...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态依赖一</span></span><br><span class="line">task test3Task(<span class="attr">dependsOn:</span> [test1Task, test2Task]) &#123;</span><br><span class="line">    println(<span class="string">&quot;test3Tasking...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态依赖二</span></span><br><span class="line">test3Task.dependsOn(test1Task, test2Task)</span><br><span class="line"><span class="comment">//动态依赖</span></span><br><span class="line">task test4Task &#123;</span><br><span class="line">    dependsOn tasks.findAll &#123; task -&gt;</span><br><span class="line">        <span class="keyword">return</span> task.name.startsWith(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;test4Tasking...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; Configure <span class="attr">project :</span></span><br><span class="line">test1Tasking...</span><br><span class="line">test2Tasking...</span><br><span class="line">test3Tasking...</span><br><span class="line">test4Tasking...</span><br></pre></td></tr></table></figure>
<p>需要注意的是，虽然我依赖了其他的task，但是依赖的task输出顺序它是随机的。</p>
<h4 id="API指定输出顺序"><a href="#API指定输出顺序" class="headerlink" title="API指定输出顺序"></a>API指定输出顺序</h4><table>
<thead>
<tr>
<th>关键字名称</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>mustRunAfter</td>
<td>指定一个任务必须执行在另一个任务之后</td>
<td>优先级小于dependsOn属性</td>
</tr>
<tr>
<td>shouldRunAfter</td>
<td>指定一个任务应该执行在另一个任务之后</td>
<td>一般不用</td>
</tr>
</tbody></table>
<p>举个栗子：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task test2Task &#123;</span><br><span class="line">    println(<span class="string">&quot;test2Tasking...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task test1Task &#123;</span><br><span class="line">    mustRunAfter test2Task</span><br><span class="line">    println(<span class="string">&quot;test1Tasking...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task test3Task &#123;</span><br><span class="line">    mustRunAfter test1Task</span><br><span class="line">    println(<span class="string">&quot;test3Tasking...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便查看，我们把顺序修改了，不让它按照1、2、3的形式输出，现在我们看看上述代码的输出结果：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; Configure <span class="attr">project :</span></span><br><span class="line">test2Tasking...</span><br><span class="line">test1Tasking...</span><br><span class="line">test3Tasking...</span><br></pre></td></tr></table></figure>
<h3 id="Task类型"><a href="#Task类型" class="headerlink" title="Task类型"></a>Task类型</h3><p>除了定义一个task之外，我们也可以使用task的type属性来直接使用一个已有的 task 类型，比如Gradle自带的Copy、Delete、Sync等等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节我们介绍了Task的使用，除了上面介绍的，我们还可以通过gradle官网去查看task相关指令。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/u010289802/article/details/105908520">暴力突破 Gradle 自动化项目构建（六）- Gradle 核心之 Task</a></p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>Gradle中Transform是什么？</title>
    <url>/gradle/transform/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Google从 Android Gradle 1.5.0 开始，提供了Transform API。通过Transform API，允许第三方以插件的形式，在Android应用程序打包成dex文件之前的编译过程中操作.class文件。我们只要实现一套Transform，去遍历所有.class文件的所有方法，然后进行修改，再对源文件进行替换，即可以达到插入代码的目的。</p>
<h3 id="Transform可以做什么"><a href="#Transform可以做什么" class="headerlink" title="Transform可以做什么"></a>Transform可以做什么</h3><p>首先，我们可以先执行一次build操作，命令行会输出如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Transform core-runtime.aar (androidx.arch.core:core-runtime:2.0.0) with AarTransform</span><br><span class="line">&gt; Transform lifecycle-livedata-core.aar (androidx.lifecycle:lifecycle-livedata-core:2.0.0) with AarTransform</span><br><span class="line">&gt; Transform lifecycle-livedata.aar (androidx.lifecycle:lifecycle-livedata:2.0.0) with AarTransform</span><br><span class="line">&gt; Transform interpolator.aar (androidx.interpolator:interpolator:1.0.0) with AarTransform</span><br><span class="line">&gt; Transform savedstate.aar (androidx.savedstate:savedstate:1.0.0) with AarTransform</span><br><span class="line">&gt; Transform lifecycle-viewmodel.aar (androidx.lifecycle:lifecycle-viewmodel:2.1.0) with AarTransform</span><br><span class="line">&gt; Transform lifecycle-runtime.aar (androidx.lifecycle:lifecycle-runtime:2.1.0) with AarTransform</span><br><span class="line">&gt; Transform versionedparcelable.aar (androidx.versionedparcelable:versionedparcelable:1.1.0) with AarTransform</span><br><span class="line">&gt; Transform cursoradapter.aar (androidx.cursoradapter:cursoradapter:1.0.0) with AarTransform</span><br><span class="line">&gt; Transform core.aar (androidx.core:core:1.3.2) with AarTransform</span><br><span class="line">&gt; Transform customview.aar (androidx.customview:customview:1.0.0) with AarTransform</span><br></pre></td></tr></table></figure>
<p>也就是在构建过程中，会执行一个个的Transform。那么回到刚开始的问题，Transform可以做什么，我先列一些大家常听的，以及常见的:</p>
<ul>
<li><p>无痕埋点：不需要侵入代码即可以对页面进行埋点，不过一般这种都是针对比较简单的case，复杂的业务场景很难通过无痕埋点处理。</p>
</li>
<li><p>性能监控：这个也很常见。</p>
</li>
<li><p>事件防抖：避免短期内多次点击按钮。</p>
</li>
<li><p>热修复：在方法前插入预留函数已做替换。</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>那么Transform的操作到底是在什么时候将代码植入的呢？我们看一张google官方的打包图：<br><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210303225336.png" alt="image">  </p>
<p>Transform阶段就是在图中红圈的位置，也就是.class文件变成.dex文件过程进行插入的。说白了Transform就是Android官方提供给开发者在项目构建阶段由class到dex转换期间修改class文件的一套api。比较经典的应用就是字节码插桩和代码注入技术。有了这个API，我们就可以根据自己的业务需求做一些定制。</p>
<h3 id="Transform使用"><a href="#Transform使用" class="headerlink" title="Transform使用"></a>Transform使用</h3><p>前面说了那么多，主要是介绍了，Transform是什么，能做什么。那么该如何使用呢？</p>
<p>我们先在我们build.gradle中新增一个依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">&quot;libs&quot;</span>, <span class="attr">include:</span> [<span class="string">&quot;*.jar&quot;</span>])</span><br><span class="line">    implementation <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;</span></span><br><span class="line">    <span class="comment">//gradle sdk</span></span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    <span class="comment">//groovy sdk</span></span><br><span class="line">    implementation localGroovy()</span><br><span class="line">    <span class="comment">//新增</span></span><br><span class="line">    implementation <span class="string">&quot;com.android.tools.build:gradle:3.3.2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后新建一个MyTransform：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意Transform有很多路径</span></span><br><span class="line"><span class="keyword">import</span> com.android.build.api.transform.Transform</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyTransform&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getName"><a href="#getName" class="headerlink" title="getName"></a>getName</h4><p>指定自定义 Transform 的名称，返回的是对应的Task名称</p>
<h4 id="getInputTypes"><a href="#getInputTypes" class="headerlink" title="getInputTypes"></a>getInputTypes</h4><p>可以看到这个方法是返回一个Set&lt;QualifiedContent.ContentType&gt;集合，其实就是返回Transform需要处理的文件类型。具体有哪些，TransformManager已经给我们提供了，我们来看一下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ContentType&gt; CONTENT_CLASS = ImmutableSet.of(CLASSES);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ContentType&gt; CONTENT_JARS = ImmutableSet.of(CLASSES, RESOURCES);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ContentType&gt; CONTENT_RESOURCES = ImmutableSet.of(RESOURCES);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ContentType&gt; CONTENT_NATIVE_LIBS =</span><br><span class="line">        ImmutableSet.of(NATIVE_LIBS);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ContentType&gt; CONTENT_DEX = ImmutableSet.of(ExtendedContentType.DEX);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ContentType&gt; CONTENT_DEX_WITH_RESOURCES =</span><br><span class="line">        ImmutableSet.of(ExtendedContentType.DEX, RESOURCES);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONTENT_CLASS</td>
<td>表示需要处理 java 的 class 文件</td>
</tr>
<tr>
<td>CONTENT_JARS</td>
<td>表示需要处理 java 的 class 与 资源文件</td>
</tr>
<tr>
<td>CONTENT_RESOURCES</td>
<td>表示需要处理 java 的资源文件</td>
</tr>
<tr>
<td>CONTENT_NATIVE_LIBS</td>
<td>表示需要处理 native 库的代码</td>
</tr>
<tr>
<td>CONTENT_DEX</td>
<td>表示需要处理 DEX 文件</td>
</tr>
<tr>
<td>CONTENT_DEX_WITH_RESOURCES</td>
<td>表示需要处理 DEX 与 java 的资源文件</td>
</tr>
</tbody></table>
<h4 id="getScopes"><a href="#getScopes" class="headerlink" title="getScopes"></a>getScopes</h4><p>可以看到这个方法是返回一个Set&lt;QualifiedContent.Scope&gt;集合，其实就是返回Transform处理的作用域。具体有哪些，我们来看一下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Only the project (module) content */</span></span><br><span class="line">PROJECT(<span class="number">0x01</span>),</span><br><span class="line"><span class="comment">/** Only the sub-projects (other modules) */</span></span><br><span class="line">SUB_PROJECTS(<span class="number">0x04</span>),</span><br><span class="line"><span class="comment">/** Only the external libraries */</span></span><br><span class="line">EXTERNAL_LIBRARIES(<span class="number">0x10</span>),</span><br><span class="line"><span class="comment">/** Code that is being tested by the current variant, including dependencies */</span></span><br><span class="line">TESTED_CODE(<span class="number">0x20</span>),</span><br><span class="line"><span class="comment">/** Local or remote dependencies that are provided-only */</span></span><br><span class="line">PROVIDED_ONLY(<span class="number">0x40</span>),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Only the project&#x27;s local dependencies (local jars)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @deprecated local dependencies are now processed as &#123;@link #EXTERNAL_LIBRARIES&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">PROJECT_LOCAL_DEPS(<span class="number">0x02</span>),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Only the sub-projects&#x27;s local dependencies (local jars).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @deprecated local dependencies are now processed as &#123;@link#EXTERNAL_LIBRARIES&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">SUB_PROJECTS_LOCAL_DEPS(<span class="number">0x08</span>);</span><br></pre></td></tr></table></figure>
<p>这里主要介绍下前面五个。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PROJECT</td>
<td>只处理当前的项目</td>
</tr>
<tr>
<td>SUB_PROJECTS</td>
<td>只处理子项目</td>
</tr>
<tr>
<td>EXTERNAL_LIBRARIES</td>
<td>只处理外部依赖库</td>
</tr>
<tr>
<td>TESTED_CODE</td>
<td>测试代码</td>
</tr>
<tr>
<td>PROVIDED_ONLY</td>
<td>只提供本地或者远程依赖项</td>
</tr>
</tbody></table>
<p>同样，TransformManager为我们分装了Scope的返回集合，具体如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ScopeType&gt; PROJECT_ONLY = ImmutableSet.of(Scope.PROJECT);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Scope&gt; SCOPE_FULL_PROJECT =</span><br><span class="line">        Sets.immutableEnumSet(</span><br><span class="line">                Scope.PROJECT,</span><br><span class="line">                Scope.SUB_PROJECTS,</span><br><span class="line">                Scope.EXTERNAL_LIBRARIES);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ScopeType&gt; SCOPE_FULL_WITH_IR_FOR_DEXING =</span><br><span class="line">        <span class="keyword">new</span> ImmutableSet.Builder&lt;ScopeType&gt;()</span><br><span class="line">                .addAll(SCOPE_FULL_PROJECT)</span><br><span class="line">                .add(InternalScope.MAIN_SPLIT)</span><br><span class="line">                .build();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ScopeType&gt; SCOPE_FULL_WITH_FEATURES =</span><br><span class="line">        <span class="keyword">new</span> ImmutableSet.Builder&lt;ScopeType&gt;()</span><br><span class="line">                .addAll(SCOPE_FULL_PROJECT)</span><br><span class="line">                .add(InternalScope.FEATURES)</span><br><span class="line">                .build();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ScopeType&gt; SCOPE_FULL_WITH_IR_AND_FEATURES =</span><br><span class="line">        <span class="keyword">new</span> ImmutableSet.Builder&lt;ScopeType&gt;()</span><br><span class="line">                .addAll(SCOPE_FULL_PROJECT)</span><br><span class="line">                .add(InternalScope.MAIN_SPLIT)</span><br><span class="line">                .add(InternalScope.FEATURES)</span><br><span class="line">                .build();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ScopeType&gt; SCOPE_FEATURES = ImmutableSet.of(InternalScope.FEATURES);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ScopeType&gt; SCOPE_FULL_LIBRARY_WITH_LOCAL_JARS =</span><br><span class="line">        ImmutableSet.of(Scope.PROJECT, InternalScope.LOCAL_DEPS);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ScopeType&gt; SCOPE_IR_FOR_SLICING =</span><br><span class="line">        ImmutableSet.of(Scope.PROJECT, Scope.SUB_PROJECTS);</span><br></pre></td></tr></table></figure>
<h4 id="isIncremental"><a href="#isIncremental" class="headerlink" title="isIncremental"></a>isIncremental</h4><p>是否进行增量更新，如果返回true，TransformInput会包含一份修改的文件列表，如果返回 false，则会删除上次修改的记录并进行全量编译。</p>
<h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><p>这是最主要的方法，对文件和jar对处理都是在这里进行的，代码植入也是通过此方法进行操作的。常用到的属性有以下几个：</p>
<ul>
<li><p>TransformInput：对输入的class文件转变成目标字节码文件，TransformInput就是这些输入文件的抽象。目前它包含DirectoryInput集合与JarInput集合。</p>
</li>
<li><p>DirectoryInput：源码方式参与项目编译的所有目录结构及其目录下的源文件。</p>
</li>
<li><p>JarInput：Jar包方式参与项目编译的所有本地jar或远程jar包。</p>
</li>
<li><p>TransformOutProvider：通过这个类来获取输出路径。</p>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>当你编写完成之后，我们只需要在我们的plugin中添加如下代码就可以使用你自己写的Transform了。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGradlePlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">def</span> android = project.extensions.getByType(AppExtension)</span><br><span class="line">        <span class="keyword">def</span> classTransform = <span class="keyword">new</span> MyTransform(project)</span><br><span class="line">        <span class="comment">//注册你的Transform</span></span><br><span class="line">        android.registerTransform(classTransform)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回到标题，Transform是什么？Transform其实就是在编译过程中可以动态织入代码。最主要的目的就是解耦。让开发更注重于业务开发。一些数据监控、无痕埋点等逻辑交给Transfrom处理。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/a296777513/article/details/90665134">Gradle-初探代码注入Transform</a></p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title>TCP三次握手与四次挥手</title>
    <url>/http/tcp/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在开发中,时不时会听到关于HTTP的三次握手和四次挥手，在面试中也会被问道HTTP的三次握手和四次挥手，很多开发者可能都会有这这种误解，认为三次握手和四次挥手都是HTTP协议的，实际上，这是错误的。正确的来说，三次挥手与四次握手是在TCP中进行的。</p>
<h3 id="TCP中的三次握手"><a href="#TCP中的三次握手" class="headerlink" title="TCP中的三次握手"></a>TCP中的三次握手</h3><p>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。<br>通过下面的图片，我们来详细分析下TCP三次握手</p>
<p><img src="https://img-blog.csdnimg.cn/2020072223451133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>（1）最初两端的TCP进程都处于CLOSED关闭状态，A（Client）主动打开连接，而B（Server）被动打开连接。（A、B关闭状态CLOSED——B收听状态LISTEN——A同步已发送状态SYN-SENT——B同步收到状态SYN-RCVD——A、B连接已建立状态ESTABLISHED）</p>
<ul>
<li>第一次握手：起初两端都处于CLOSED关闭状态，A（Client）将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给B（Server），A（Client）进入SYN-SENT状态，等待B（Server）确认；</li>
<li>第二次握手：B（Server）收到连接请求报文段后，如同意建立连接，则向A（Client）发送确认，在确认报文段中（SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y），B（Server）TCP服务器进程进入SYN-RCVD（同步收到）状态；</li>
<li>第三次握手：TCP客户进程收到B（Server）的确认后，要向B（Server）给出确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1）（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。TCP连接已经建立，A进入ESTABLISHED（已建立连接）。<br>当B收到A的确认后，也进入ESTABLISHED状态。</li>
</ul>
<p>（2）总结三次握手过程：</p>
<ul>
<li>第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；</li>
<li>第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。</li>
</ul>
<p>起初A和B都处于CLOSED状态——B创建TCB，处于LISTEN状态，等待A请求——A创建TCB，发送连接请求（SYN=1，seq=x），进入SYN-SENT状态——B收到连接请求，向A发送确认（SYN=ACK=1，确认号ack=x+1，初始序号seq=y），进入SYN-RCVD状态——A收到B的确认后，给B发出确认（ACK=1，ack=y+1，seq=x+1），A进入ESTABLISHED状态——B收到A的确认后，进入ESTABLISHED状态。<br>TCB传输控制块Transmission Control Block，存储每一个连接中的重要信息，如TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号。<br>（3）为什么A还要发送一次确认呢？可以二次握手吗？</p>
<ul>
<li><strong>主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。</strong>如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立新的连接了，此时A不理睬B的确认且不发送数据，则B一致等待A发送数据，浪费资源。</li>
</ul>
<p>（4）Server端易受到SYN攻击？</p>
<ul>
<li>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击，SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</li>
</ul>
<ul>
<li>防范SYN攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。</li>
</ul>
<h3 id="TCP中的四次挥手"><a href="#TCP中的四次挥手" class="headerlink" title="TCP中的四次挥手"></a>TCP中的四次挥手</h3><p>（1）四次挥手的详述<br>  假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！<br>  <br>通过下面的图片，我们来详细分析下TCP三次握手</p>
<p><img src="https://img-blog.csdnimg.cn/202007222345118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>数据传输结束后，通信的双方都可释放连接，A和B都处于ESTABLISHED状态。（A、B连接建立状态ESTABLISHED——A进入等待1状态FIN-WAIT-1——B关闭等待状态CLOSE-WAIT——A进入等待2状态FIN-WAIT-2——B最后确认状态LAST-ACK——A时间等待状态TIME-WAIT——B、A关闭状态CLOSED）</p>
<ul>
<li>A的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。</li>
<li>B收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。</li>
<li>A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。</li>
<li>B没有要向A发出的数据，B发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。</li>
<li>A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。</li>
</ul>
<p>（2）总结四次挥手过程：</p>
<ul>
<li>起初A和B处于ESTABLISHED状态——A发出连接释放报文段并处于FIN-WAIT-1状态——B发出确认报文段且进入CLOSE-WAIT状态——A收到确认后，进入FIN-WAIT-2状态，等待B的连接释放报文段——B没有要向A发出的数据，B发出连接释放报文段且进入LAST-ACK状态——A发出确认报文段且进入TIME-WAIT状态——B收到确认报文段后进入CLOSED状态——A经过等待计时器时间2MSL后，进入CLOSED状态。</li>
</ul>
<p>（3）为什么A在TIME-WAIT状态必须等待2MSL的时间？（MSL最长报文段寿命Maximum Segment Lifetime，MSL=2）</p>
<ul>
<li>原因：1）<strong>保证A发送的最后一个ACK报文段能够到达B。</strong>这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态。</li>
</ul>
<ul>
<li>原因：2）防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ul>
<p>（4）为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
<ul>
<li>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</li>
</ul>
<p>（5）为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<ul>
<li>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</li>
</ul>
<p>（6）优化，我们可以通过修改系统参数来优化服务器</p>
<ul>
<li>tcp_tw_reuse: 是否重用处于TIME_WAIT状态的TCP链接  （设为true）</li>
<li>tcp_max_tw_buckets: 处于TIME_WAIT状态的SOCKET最大数目 （调大，这个参数千万不要调小了）</li>
<li>tcp_fin_timeout: 处于FIN_WAIT_2的时间  （调小）</li>
</ul>
]]></content>
      <categories>
        <category>http</category>
      </categories>
  </entry>
  <entry>
    <title>ArrayList源码分析</title>
    <url>/java/arraylist/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ArrayList是日常开发中使用最频繁的集合类。首先这边简单介绍一下ArrayList：  </p>
<ul>
<li>ArrayList是通过动态数组去实现的</li>
<li>ArrayList并不是线程安全的</li>
<li>实现了RandomAccess接口，可以通过下标序号进行快速访问</li>
<li>实现了Cloneable接口，能被克隆</li>
<li>实现了Serializable接口，支持序列化</li>
</ul>
<h3 id="ArrayList基本的属性"><a href="#ArrayList基本的属性" class="headerlink" title="ArrayList基本的属性"></a>ArrayList基本的属性</h3><p>ArrayList属性主要就是当前数组长度size，以及存放数组的对象elementData数组，除此之外还有一个经常用到的属性就是从AbstractList继承过来的modCount属性，代表ArrayList集合的修改次数。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 序列化id</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">	<span class="comment">// 默认初始的容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">// 一个空对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA =&#123;&#125;;</span><br><span class="line">	<span class="comment">// 一个空对象，如果使用默认构造函数创建，则默认对象内容默认是该值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA =&#123;&#125;;</span><br><span class="line">	<span class="comment">// 当前数据对象存放地方，当前对象不参与序列化</span></span><br><span class="line">	<span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">	<span class="comment">// 当前数组长度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="comment">// 数组最大长度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE =  Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 省略方法。。</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList的初始化"><a href="#ArrayList的初始化" class="headerlink" title="ArrayList的初始化"></a>ArrayList的初始化</h3><p>说到初始化，就肯定会提到构造函数，还有初始大小，那么ArrayList的初始大小是多少？我们首先看看无参的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>注意，当我们创建的时候，elementData这个数组的数组长度为0，但当我们添加数据的时候他的默认长度才会变成10。</p>
<p>当然除了无参的构造方法，还有有参的构造。我们可以在创建的时候直接指定一个大小，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入的数如果大于等于0，那么就使用传入的数据作为初始化的大小，如果小于0则会抛出异常。</p>
<p>除了上述两种初始化，其里面还有带Collection的构造函数。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将collection对象转换成数组，然后将数组的地址给到elementData。<br>更新size的值如果为0就传空，否则通过arrays.copyof将collection的内容考本到elementData中去。  </p>
<h3 id="比较重要的几个方法"><a href="#比较重要的几个方法" class="headerlink" title="比较重要的几个方法"></a>比较重要的几个方法</h3><h4 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h4><p>ArrayList已经是具体的实现类了，所以其实现了list接口中所有的定义方法。首先前面说到ArrayList的默认大小为0，只有第一次添加数据的时候才会设为10。下面我们看看add的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看到elementData如果为null的时候，他会讲初始大小设为10。然后在ensureExplicitCapacity方法中可以看出，如果需要扩容了，就调用了grow方法进行扩容。grow方法会将数组扩容成原来的1.5倍。最后确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。最后返回一个添加成功的boolean值。</p>
<p>当然了，添加处理这个还有一个方法就是在指定位置添加内容，逻辑和上面差不多，这边就不介绍了。</p>
<h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h4><p>前面我们说到了add方法，与之对应的就是remove了。这边不仅可以通过坐标去移除，也可以通过object去移除，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line"></span><br><span class="line">     modCount++;</span><br><span class="line">     E oldValue = (E) elementData[index];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">         System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                          numMoved);</span><br><span class="line">     elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">             <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 fastRemove(index);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">             <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                 fastRemove(index);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">         System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                          numMoved);</span><br><span class="line">     elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先看看根据索引去移除某个对象。我们需要判断索引是否越界，如果越界了则抛出异常。否则将指定的位置的元素保存在oldValue中。然后讲指定位置的后面元素都前移动一位。然后讲最后一位置空。最后返回oldValue。（注意，这个方法不会缩减数组的长度，只是将最后一位置空而已…）</p>
<p>下面是根据对象进行remove。它会循环编译所有对象，找到你要移除对象的索引位置。然后调用fastRemove进行移除，具体的逻辑和remove是一样的。但是为什么remove方法不去调用fastRemove方法….  </p>
<h4 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h4><p>然后，我们在看看contains方法，这是判断当前list中是否包涵某个内容。内部其实是通过equals去判断的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>其实ArrayList还有很多方法，最后我们只介绍2个方法。前面我们介绍了将数组元素置为空后，它的数组大小没变。那么通过clear方法。他的数组大小会变吗？我们继续看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// clear to let GC do its work</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">           elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       size = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>很明显，这里也只是讲值设为null，然后等待GC去回收掉。那么什么方法是去讲空的数据去除改变数组大小呢。是trimToSize。我们具体看看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">          elementData = (size == <span class="number">0</span>)</span><br><span class="line">            ? EMPTY_ELEMENTDATA</span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>将elementData中空余的空间（包括null值）去除，例如：数组长度为10，其中只有前三个元素有值，其他为空，那么调用该方法之后，数组的长度变为3。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体而言，ArrayList还是和数组一样，更适合于数据随机访问，而不太适合于大量的插入与删除，如果一定要进行插入操作，要使用以下三种方式：</p>
<ul>
<li><p>使用ArrayList(intinitialCapacity)这个有参构造，在创建时就声明一个较大的大小。</p>
</li>
<li><p>使用ensureCapacity(int minCapacity)，在插入前先扩容。</p>
</li>
<li><p>使用LinkedList，这个无可厚非哈，我们很快就会介绍这个适合于增删的集合类。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Hashmap源码分析</title>
    <url>/java/hashmap/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>hashmap应该是集合中较复杂的一个类。最早出现在1.2中，在1.8中加入了红黑树，所以1.8的改动很大。hashmap允许null值和null键，底层是通过散列算法实现的。并且hashmap不是线程安全的。  </p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认的初始化数组大小为16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span></span><br><span class="line"><span class="comment">//最大存储容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line"><span class="comment">//默认扩容因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//这是jdk1.8新加的，这是链表的最大长度，当大于这个长度时，就会将链表转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//table就是存储Node 的数组，就是hash表中的桶位</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//实际存储的数量，则HashMap的size()方法，实际返回的就是这个值，isEmpty()也是判断该值是否为0</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容的门限值，当大于这个值时，table数组要进行扩容，一般等于（cap*loadFactor）</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//装载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<p>我记得hashmap的初始大小在android中是4，java中是16…不知道啥时候改了….</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>hashmap的构造方法有4个，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 构造方法 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 构造方法 2 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 构造方法 3 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 构造方法 4 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以在初始化的时候传入初始大小以及扩容因子，如果不传则为默认值。当然，我们还可以把已有map直接传进去。我们可以看到在第三个构造方法中给扩展的限制进行了重新的定义，因为可能我们传的大小不是2的幂数。现在他是如何重新定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的意思就是把初始大小的后面所有数置为1，然后加一，也就是找到最近的2的次幂。</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>现在我们看看hashmap是如何添加一个元素的。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边主要是通过putVal进行添加的，这边通过hash函数将key与其高16位异或。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们具体看看putVal这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//table 没有初始化</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//可以看到table的初始化放在了这里，是通过resize来做的</span></span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//这里就是HASH算法了，用来定位桶位的方式，可以看到是采用容量-1与键hash值进行与运算</span></span><br><span class="line">       <span class="comment">//n-1,的原因就是n一定是一个2的整数幂，而(n - 1) &amp; hash其实质就是(n-1)%hash,但是取余运算的效率明显不如位运算与</span></span><br><span class="line">       <span class="comment">//并且(n - 1) &amp;hash也能保证散列均匀，不会产生只有偶数位有值的现象</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">//当这里是空桶位时，就直接构造新的Node节点，将其放入桶位中</span></span><br><span class="line">           <span class="comment">//newNode()方法，就是对new Node(,,,)的包装</span></span><br><span class="line">   <span class="comment">//同时也可以看到Node中的hash值就是重新计算的hash(key)</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="comment">//键hash值相等，键相等时，这里就是发现该键已经存在于Map中</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               e = p;</span><br><span class="line">           <span class="comment">//当该桶位是红黑树结构时，则应该按照红黑树方式插入</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="comment">//当该桶位为链表结构时，进行链表的插入操作，但是当链表长度大于TREEIFY_THRESHOLD - 1，就要将链表转换成红黑树</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//这里binCount记录链表的长度</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">             <span class="comment">//找到链表尾端</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">             </span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//记录改变次数</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">//当达到扩容上限时，进行扩容</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面注释的已经很清楚了，这边说一下，他会通过散列算法找到对应的位置，如果是空就直接扔进去，如果是非空就判断它是链表还是红黑树，按照对应的数据结构进行插入。</p>
<p>如果链表太长，会进行树化操作，下面看看如何进行树化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 桶数组容量小于 MIN_TREEIFY_CAPACITY，优先进行扩容而不是树化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// hd 为头节点（head），tl 为尾节点（tail）</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将普通节点替换成树形节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  <span class="comment">// 将普通链表转成由树形节点链表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 将树形链表转换成红黑树</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边代码不多，上面注释已经说的比较清楚了。  </p>
<p>无论在put还是树化中都用到了resize方法，也就是扩容，下面看看resize是如何处理扩容的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码，我们可以看出，如果超过了最大值则不需要扩容了，否则将大小以及阈值扩充到原来的两倍。扩充完成后，重新对数据排列。对红黑树以及链表进行拆分。然后按照原顺序进行排列。  </p>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>获取其实很简单，就是先定位键所在的桶的位置，然后在对链表或者红黑树进行查找。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 1. 定位键值对所在桶的位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 如果 first 是 TreeNode 类型，则调用黑红树查找方法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 2. 对链表进行查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除操作其实也是很简单的，第一步，定位bucket的位置，第二步，遍历找到与key相同的节点，第三步，删除。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 1. 定位桶位置</span></span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果键的值与链表第一个节点相等，则将 node 指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 如果是 TreeNode 类型，调用红黑树的查找逻辑定位待删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 2. 遍历链表，找到待删除节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 删除节点，并修复链表或红黑树</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>合理的使用HashMap能够在增删改查等方面都有很好的表现。在使用时我们需要注意以下几点：</p>
<ul>
<li><p>设计的key对象一定要实现hashCode方法，并尽可能保证均匀少重复。</p>
</li>
<li><p>由于树化过程会依次通过hash值、比较值和对象的hash值进行排序，所以key还可以实现Comparable，以方便树化时进行比较。</p>
</li>
<li><p>如果可以预先估计数量级，可以指定initial capacity，以减少rehash的过程。</p>
</li>
<li><p>虽然HashMap引入了红黑树，但它的使用是很少的，如果大量出现红黑树，说明数据本身设计的不合理，我们应该从数据源寻找优化方案。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>LinkedList源码分析</title>
    <url>/java/linkedlist/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>LinkedList弥补了ArrayList增删较慢的问题，但在查找方面又逊色于ArrayList，所以在使用时需要根据场景灵活选择。对于这两个频繁使用的集合类，掌握它们的源码并正确使用，可以让我们的代码更高效。</p>
<ul>
<li>LinkedList 是一个继承于AbstractSequentialList的双向循环链表。它也可以被当作堆栈、队列或双端队列进行操作。</li>
<li>LinkedList 实现 List 接口，能对它进行队列操作。</li>
<li>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。</li>
<li>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。</li>
<li>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。</li>
<li>LinkedList 是非同步的。</li>
</ul>
<h3 id="LinkedList的基本属性"><a href="#LinkedList的基本属性" class="headerlink" title="LinkedList的基本属性"></a>LinkedList的基本属性</h3><p>LinkedList的成员变量只有三个，所以很简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录当前链表的长度</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>因为链表没有长度方面的问题，所以也不会涉及到扩容等问题，其构造函数也十分简洁了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个默认的构造函数，什么都没有做，一个是用其他集合初始化，调用了一下addAll方法。addAll方法我们就不再分析了，它应该是和添加一个元素的方法是一致的。</p>
<h3 id="比较重要的几个方法"><a href="#比较重要的几个方法" class="headerlink" title="比较重要的几个方法"></a>比较重要的几个方法</h3><p>LinkedList既继承了List，又继承了Deque，那它必然有一堆add、remove、addFirst、addLast等方法。这些方法的含义也相差不大，实现也是类似的，因此LinkedList又提取了新的方法，来简化这些问题。我们看看这些不对外的方法，以及它们是如何与上述函数对应的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将一个元素链接到首位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先将原链表存起来</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//定义一个新节点，其next指向原来的first</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//将first指向新建的节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//原链表为空表</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//把last也指向新建的节点，现在first与last都指向了它</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//把原链表挂载在新建节点，也就是现在的first之后</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与linkFirst类似</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//在某个非空节点之前添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="comment">//先把succ节点的前置节点存起来</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//新节点插在pred与succ之间</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//succ的prev指针移到新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">//前置节点为空</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//说明插入到了首位</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//把前置节点的next指针也指向新建的节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除首位的元素，元素必须非空</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除一个指定的节点</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，LinkedList提供了一系列方法用来插入和删除，但是却没有再实现一个方法来进行查询，因为对链表的查询是比较慢的，所以它是通过另外的方法来实现的，我们看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以说尽力了</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//size&gt;&gt;1就是取一半的意思</span></span><br><span class="line">    <span class="comment">//折半，将遍历次数减少一半</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，我们看下它如何对应那些继承来的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用了node方法，需要遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可能需要遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也要遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>LinkedList非常适合大量数据的插入与删除，但其对处于中间位置的元素，无论是增删还是改查都需要折半遍历，这在数据量大时会十分影响性能。在使用时，尽量不要涉及查询与在中间插入数据，另外如果要遍历，也最好使用foreach，也就是Iterator提供的方式。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>TreeMap源码分析</title>
    <url>/java/treemap/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>TreeMap是红黑树的java实现，红黑树能保证增、删、查等基本操作的时间复杂度为O(lgN)。<br>首先我们来看一张TreeMap的继承体系图：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604231103553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70" alt="image"><br>还是比较直观的，这里来简单说一下继承体系中不常见的接口NavigableMap和SortedMap，这两个接口见名知意。先说NavigableMap接口，NavigableMap接口声明了一些列具有导航功能的方法，比如：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回红黑树中最小键所对应的 Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">firstEntry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回最大的键 maxKey，且 maxKey 仅小于参数 key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">K <span class="title">lowerKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回最小的键 minKey，且 minKey 仅大于参数 key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">K <span class="title">higherKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他略</span></span><br></pre></td></tr></table></figure>
<p>通过这些导航方法，我们可以快速定位到目标的 key 或 Entry。至于 SortedMap 接口，这个接口提供了一些基于有序键的操作，比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回包含键值在 [minKey, toKey) 范围内的 Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span></span>;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回包含键值在 [fromKey, toKey) 范围内的 Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他略</span></span><br></pre></td></tr></table></figure>
<p>以上就是两个接口的介绍，很简单。关于TreeMap的继承体系就这里就说到这，接下来我们深入源码进行分析。   </p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p>红黑树最复杂的无非就是增删了，这边我们先介绍增加一个元素，了解红黑树的都知道，当往 TreeMap 中放入新的键值对后，可能会破坏红黑树的性质。首先我们先巩固一下红黑树的特性。</p>
<ul>
<li><p>节点是红色或黑色。</p>
</li>
<li><p>根节点是黑色。</p>
</li>
<li><p>每个叶子节点都是黑色的空节点（NIL节点）。</p>
</li>
<li><p>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。</p>
</li>
<li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。  </p>
</li>
</ul>
<p>接下来我们看看添加到底做了什么处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    TreeMapEntry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                comparator.compare(key, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;key == null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(key <span class="keyword">instanceof</span> Comparable)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(</span><br><span class="line">                        <span class="string">&quot;Cannot cast&quot;</span> + key.getClass().getName() + <span class="string">&quot; to Comparable.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root = <span class="keyword">new</span> TreeMapEntry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    TreeMapEntry&lt;K,V&gt; parent;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeMapEntry&lt;K,V&gt; e = <span class="keyword">new</span> TreeMapEntry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这边会先把根节点暂存依赖，如果根节点为null，则讲新增的这个节点设为根节点。 如果初始化的时候指定了comparator比较器，则讲其插入到指定位置，否则使用key进行比较并且插入。不断的进行比较，找到没有子节点的节点，将其插入到相应节点。(注：如果查找出有相同的值只会更新当前值，cmp小于0是没有左节点，反之没有右节点。)</p>
<p>新插入的树破环的红黑树规则，我们会通过fixAfterInsertion去进行相应的调整，这也是TreeMap插入实现的重点，具体我们看看他是怎么通过java实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(TreeMapEntry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">        x.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">                TreeMapEntry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateLeft(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateRight(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeMapEntry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateRight(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line">前方高能。如果不清楚红黑树的特性，建议先去了解红黑树的特性。  </span><br><span class="line"></span><br><span class="line">首先将新插入的节点设置为红色，这边做了一个判断，新节点不为<span class="keyword">null</span>，新节点不为根节点并且新节点的父节点为红色。才会进入内部的判断，因为其本身就是一个红黑树。如果新节点的父节点为黑色，则他依旧满足红黑树的特性。所以当其父节点为红色进入内部的判断。  </span><br><span class="line"></span><br><span class="line">如果新节点是其祖父节点的左子孙，则拿到其祖父节点的右儿子，也就是新节点的叔叔。如果叔叔节点是红色。则将其父节点设为黑色，讲叔父节点设为黑色，然后讲新节点直接其祖父节点。</span><br><span class="line"></span><br><span class="line">否则如果新节点是其父节点的右节点，以其父节点进行左转，将父节点设为黑色，祖父节点设为红色，在通过祖父节点进行右转。</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>内容和上述基本一致。自己分析~~</span><br><span class="line"></span><br><span class="line">最后我们还需要将跟节点设为黑色。  </span><br><span class="line"></span><br><span class="line">我们稍微看一下，他是怎么进行左转和右转的。  </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 右旋与左旋思路一致，只分析其一</span></span><br><span class="line"><span class="comment">// 结果相当于把p和p的儿子调换了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 取出p的右儿子</span></span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        <span class="comment">// 然后将p的右儿子的左儿子，也就是p的左孙子变成p的右儿子</span></span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// p的左孙子的父亲现在是p</span></span><br><span class="line">            r.left.parent = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后把p的父亲，设置为p右儿子的父亲</span></span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="comment">// 这说明p原来是root节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和左旋类似</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>除了添加操作，红黑树的删除也是很麻烦的…我们看看怎么通过java去实现红黑树的删除。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      TreeMapEntry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">      <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      V oldValue = p.value;</span><br><span class="line">      deleteEntry(p);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其内部是通过deleteEntry去进行删除的。所以我们具体看看deleteEntry的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(TreeMapEntry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       size--;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           TreeMapEntry&lt;K,V&gt; s = successor(p);</span><br><span class="line">           p.key = s.key;</span><br><span class="line">           p.value = s.value;</span><br><span class="line">           p = s;</span><br><span class="line">       &#125; </span><br><span class="line">       </span><br><span class="line">       TreeMapEntry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// Link replacement to parent</span></span><br><span class="line">           replacement.parent = p.parent;</span><br><span class="line">           <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">               root = replacement;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">               p.parent.left  = replacement;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">           p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Fix replacement</span></span><br><span class="line">           <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(replacement);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; </span><br><span class="line">           root = <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                   p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                   p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">               p.parent = <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>根据上述代码，我们可以看出，如果 p 有两个孩子节点，则找到后继节点，并把后继节点的值复制到节点 P 中，并让 p 指向其后继节点。 然后将 replacement parent 引用指向新的父节点，同时让新的父节点指向 replacement。</p>
<p>然后判断如果删除的节点 p 是黑色节点，则需要进行调整。删除的是根结点并且树中只有一个节点，我们将根结点置为null，否则，如果删除的节点没有子节点并且是黑色，则需要调整。最后将p从树中移除。  </p>
<p>删除了一个元素，为了保证还是一个红黑树，我们需要将其进行调整，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/** From CLR */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(TreeMapEntry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                TreeMapEntry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    setColor(parentOf(x), RED);</span><br><span class="line">                    rotateLeft(parentOf(x));</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                    colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                        setColor(leftOf(sib), BLACK);</span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        rotateRight(sib);</span><br><span class="line">                        sib = rightOf(parentOf(x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    rotateLeft(parentOf(x));</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">                TreeMapEntry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    setColor(parentOf(x), RED);</span><br><span class="line">                    rotateRight(parentOf(x));</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                    colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                        setColor(rightOf(sib), BLACK);</span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        rotateLeft(sib);</span><br><span class="line">                        sib = leftOf(parentOf(x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    rotateRight(parentOf(x));</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果替换节点是父节点的左节点，并且替换节点的兄弟节点是红色，那我们需要将兄弟节点变成黑色，将父节点变成红色，并且通过父节点进行左旋转，然后将父节点的右节点设为兄弟节点。  </p>
<p>如果兄弟节点的左右节点都是黑色的，那么将兄弟节点置为红色，并且将当前节点指向父节点。若兄弟节点的右节点是黑色，我们需要将兄弟节点的左节点设为黑色，将兄弟节点设为红色，然后以兄弟节点进行右旋转，然后更新兄弟节点。然后设置兄弟节点的颜色为右节点的颜色，然后将父节点和兄弟节点的左节点设为黑色，最后进行右旋转。最后将根结点设为黑色。  </p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>说了最复杂的添加和删除，我们再来看看查找，这里就简单很多了，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找操作的核心逻辑就在这个 while 循环里</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个流程算比较简单了，上面注释标明了，这边就不再解释了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这边通过代码的形式将红黑树的特点展现出来。可以通过上面描述可见，红黑树并没有那么难…</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Android Jetpack架构组件——什么是Jetpack？</title>
    <url>/jetpack/introduction/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>提到Android架构，我们首先想到的是MVC，MVP，MVVM。他们主要是针对视图和模型的。随着Android的发展，从原来的框架很少，全是自己动手撸。到现在框架越来越多，选型也越来越多，导致开发出来越来越不规范。我们知道MVP和MVVM只是应用在架构上，而不是在框架选型上。而google在2018年推出jetpack就是为了解决以上的问题。</p>
<h3 id="Jetpack是什么？"><a href="#Jetpack是什么？" class="headerlink" title="Jetpack是什么？"></a>Jetpack是什么？</h3><p>Jetpack它不是一个新的架构，而是一个由多个库组成的套件，可帮助开发者遵循最佳做法，减少样板代码并编写可在各种Android版本和设备中一致运行的代码，让开发者精力集中编写重要的代码。</p>
<h3 id="Jetpack的优势"><a href="#Jetpack的优势" class="headerlink" title="Jetpack的优势"></a>Jetpack的优势</h3><p>既然需要使用Jetpack，那么说不出一些优势，你的领导也不会同意说换就换的。下面我们看看jetpack有哪些优势：</p>
<ul>
<li>Jetpack 拥有基于生命周期感知的能力，可以减少NPE崩溃、内存泄漏。为我们开发出健壮且流畅的程序提供强力保障。</li>
<li>Jetpack 可以减少样板代码，有助于提升 Android 开发的效率。</li>
</ul>
<h3 id="JetPack的分类"><a href="#JetPack的分类" class="headerlink" title="JetPack的分类"></a>JetPack的分类</h3><p>我们来看下google官方提供的一张图：<br><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/e6R24K.png" alt="jetpack体系"><br>由图可知，Jetpack被分成了四大类：</p>
<ul>
<li>基础 - Foundation</li>
<li>架构 - Architecture</li>
<li>界面 - UI</li>
<li>行为 - Behavior</li>
</ul>
<h4 id="Foundation（基础组件）"><a href="#Foundation（基础组件）" class="headerlink" title="Foundation（基础组件）"></a>Foundation（基础组件）</h4><ul>
<li>AppCompat：帮助较低版本的Android系统进行兼容</li>
<li>Android KTX：优化了供Kotlin使用的Jetpack和Android平台API，帮助开发者以更简洁、更愉悦、更惯用的方式使用Kotlin进行Android开发</li>
<li>Multidex：为具有多个Dex文件应用提供支持</li>
<li>Test：从AndroidStudio中快速检测基于Kotlin或Java的代码</li>
</ul>
<h4 id="Architecture（架构组件）"><a href="#Architecture（架构组件）" class="headerlink" title="Architecture（架构组件）"></a>Architecture（架构组件）</h4><ul>
<li>Data Binding：属于支持库可使用声明式将布局中的界面组件绑定到应用中的数据源</li>
<li>Lifecycles：管理Activity和Fragment生命周期</li>
<li>LiveData：是一个可观察的数据持有者类。与常规Observable不同，LiveData是有生命周期感知的</li>
<li>Navigation：处理应用内导航所需的一切</li>
<li>Paging：一次加载/按需加载 &amp;&amp; 显示小块数据</li>
<li>Room：帮助开发者更友好、流畅的访问SQLite数据库</li>
<li>ViewModel：以生命周期感知的方式存储和管理与UI相关的数据</li>
<li>WorkManager：管理Android的后台的作业，即使应用程序退出或设备重新启动也可以运行可延迟的异步任务</li>
</ul>
<h4 id="UI（界面组件）"><a href="#UI（界面组件）" class="headerlink" title="UI（界面组件）"></a>UI（界面组件）</h4><ul>
<li>Animation and Transition：该框架包含用于常见效果的内置动画，并允许开发者创建自定义动画和生命周期回调</li>
<li>Auto：开发Android Auto应用的组件，提供了适用于所有车辆的标准化界面和用户交互</li>
<li>TV：构建可让用户在大屏幕上体验沉浸式内容的应用</li>
<li>Wear：开发Wear应用的组件</li>
<li>Emoji：即便用户没有更新Android系统也可以获取最新的表情符号</li>
<li>Fragment：组件化界面的基本单位</li>
<li>Layout：用XML中声明UI元素或者在代码中实例化UI元素</li>
<li>Paletee：从调色板中提取出有用的信息</li>
</ul>
<h4 id="Behavior（行为组件）"><a href="#Behavior（行为组件）" class="headerlink" title="Behavior（行为组件）"></a>Behavior（行为组件）</h4><ul>
<li>DownloadManager：可处理长时间运行的HTTP下载&amp;&amp;超时重连</li>
<li>Media &amp; playback：用于媒体播放，以及路由的向后兼容API</li>
<li>Permissions：用于检查和请求应用权限的兼容性API</li>
<li>Notifications：提供向后兼容的通知API，支持Wear和Auto</li>
<li>Sharing：提供适合应用操作栏的共享操作</li>
<li>Slices：创建可在应用外部显示应用数据的灵活界面元素</li>
</ul>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
  </entry>
  <entry>
    <title>Android Jetpack架构组件——Lifecycle原理篇</title>
    <url>/jetpack/lifecycle_theory/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>前面我们讲到了lifecycle是如何使用的，但是我们单单知道如何使用它还是不够的，我们需要知道它到底是如何绑定生命周期的。那么本篇我们就讲一下lifecycle的原理篇。</p>
<blockquote>
<p>本篇基于Android 9.0源码进行分析，如有不同，注意sdk版本。</p>
</blockquote>
<h3 id="Lifecycle是什么？"><a href="#Lifecycle是什么？" class="headerlink" title="Lifecycle是什么？"></a>Lifecycle是什么？</h3><p>官方文档是这么描述的，Lifecycle它是一个类，用来存储相关组件的生命周期状态，如Activity或者Fragment等。并且允许其他组件对这些状态进行观察。</p>
<p>我们先简单看一下Lifecycle这个类的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    AtomicReference&lt;Object&gt; mInternalScopeRef = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> State <span class="title">getCurrentState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        ON_CREATE,</span><br><span class="line">        ON_START,</span><br><span class="line">        ON_RESUME,</span><br><span class="line">        ON_PAUSE,</span><br><span class="line">        ON_STOP,</span><br><span class="line">        ON_DESTROY,</span><br><span class="line">        ON_ANY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED,</span><br><span class="line">        CREATED,</span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出，Lifecycle主要是定义了2个枚举，一个是Event，它代表着Lifecycle分配的生命周期事件，并且它会映射到activity或者fragment的生命周期回调事件里。还有一个是State，它是指Lifecycle所处的生命周期状态。我们可以通过下图来了解State和Event的关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210220130924.svg"></p>
<h3 id="如何与Activity和Fragment建立联系？"><a href="#如何与Activity和Fragment建立联系？" class="headerlink" title="如何与Activity和Fragment建立联系？"></a>如何与Activity和Fragment建立联系？</h3><p>我们知道一般来说我们的activity是继承于FragmentActivity的。那么FragmentActivity又是继承于ComponentActivity。那我们看一下ComponentActivity的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestrictTo(LIBRARY_GROUP_PREFIX)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">LifecycleOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">KeyEventDispatcher</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> SimpleArrayMap&lt;Class&lt;? extends ExtraData&gt;, ExtraData&gt; mExtraDataMap =</span><br><span class="line">            <span class="keyword">new</span> SimpleArrayMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="meta">@RestrictTo(LIBRARY_GROUP_PREFIX)</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putExtraData</span><span class="params">(ExtraData extraData)</span> </span>&#123;</span><br><span class="line">        mExtraDataMap.put(extraData.getClass(), extraData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;RestrictedApi&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallSuper</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Bundle outState)</span> </span>&#123;</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RestrictTo(LIBRARY_GROUP_PREFIX)</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ExtraData&gt; <span class="function">T <span class="title">getExtraData</span><span class="params">(Class&lt;T&gt; extraDataClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) mExtraDataMap.get(extraDataClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到ComponentActivity实现了LifecycleOwner的接口。并且定义了LifecycleRegistry。LifecycleRegistry是Lifecycle的实现类。具体逻辑我们就不看了，有兴趣可以自己关注下。</p>
<p>上述代码中我们可以看到在onSaveInstanceState方法中，我们通过markState把状态设置成Lifecycle.State.CREATED。那么为什么找不到设置其他状态的逻辑呢？我们可以发现在onCreate方法中有一个inject方法。我们进入此方法，哎，它就找到了。我们看下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    dispatchCreate(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    dispatchStart(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    dispatchResume(mProcessListener);</span><br><span class="line">    dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    <span class="comment">// just want to be sure that we won&#x27;t leak reference to an activity</span></span><br><span class="line">    mProcessListener = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">        <span class="comment">// Only dispatch events from ReportFragment on API levels prior</span></span><br><span class="line">        <span class="comment">// to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks</span></span><br><span class="line">        <span class="comment">// added in ReportFragment.injectIfNeededIn</span></span><br><span class="line">        dispatch(getActivity(), event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们可以看到在对应的生命周期调用了dispatch方法，而在dispatch方法中又调用了一个多参的dispatch方法。在此方法中会判断activity是属于LifecycleRegistryOwner还是LifecycleRegistry。最终都会调到LifecycleRegistry的handleLifecycleEvent方法中去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">     State next = getStateAfter(event);</span><br><span class="line">     moveToState(next);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     mState = next;</span><br><span class="line">     <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">         mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">         <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">     sync();</span><br><span class="line">     mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">static</span> State <span class="title">getStateAfter</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">         <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">         <span class="keyword">case</span> ON_STOP:</span><br><span class="line">             <span class="keyword">return</span> CREATED;</span><br><span class="line">         <span class="keyword">case</span> ON_START:</span><br><span class="line">         <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">             <span class="keyword">return</span> STARTED;</span><br><span class="line">         <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">             <span class="keyword">return</span> RESUMED;</span><br><span class="line">         <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">             <span class="keyword">return</span> DESTROYED;</span><br><span class="line">         <span class="keyword">case</span> ON_ANY:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unexpected event value &quot;</span> + event);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到它是通过getStateAfter去获取event的状态，具体可以参考一下上面的时序图。而在moveToState方法中它又回调用sync方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">       <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;LifecycleOwner of this LifecycleRegistry is already&quot;</span></span><br><span class="line">                   + <span class="string">&quot;garbage collected. It is too late to change lifecycle state.&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">           mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">           <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               backwardPass(lifecycleOwner);</span><br><span class="line">           &#125;</span><br><span class="line">           Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">           <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">                   &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               forwardPass(lifecycleOwner);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里会通过mObserverMap的eldest和newest拿到的状态做对比，判断是向前还是向后。比如ON_CREATE=&gt;ON_START是向前，ON_START=&gt;ON_CREATE是向后。整体流程是差不多的。具体我们看代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">       Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">               mObserverMap.iteratorWithAdditions();</span><br><span class="line">       <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">           Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">           ObserverWithState observer = entry.getValue();</span><br><span class="line">           <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                   &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">               pushParentState(observer.mState);</span><br><span class="line">               observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">               popParentState();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">       Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =</span><br><span class="line">               mObserverMap.descendingIterator();</span><br><span class="line">       <span class="keyword">while</span> (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">           Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();</span><br><span class="line">           ObserverWithState observer = entry.getValue();</span><br><span class="line">           <span class="keyword">while</span> ((observer.mState.compareTo(mState) &gt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                   &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">               Event event = downEvent(observer.mState);</span><br><span class="line">               pushParentState(getStateAfter(event));</span><br><span class="line">               observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">               popParentState();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最终它都会走到<code> observer.dispatchEvent(lifecycleOwner, event);</code>方法中。<br>并且最终会调用<code> mLifecycleObserver.onStateChanged(owner, event);</code>也就是LifecycleEventObserver的方法。我们看基于LifecycleEventObserver的实现类ReflectiveGenericLifecycleObserver。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReflectiveGenericLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mWrapped;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallbackInfo mInfo;</span><br><span class="line"></span><br><span class="line">    ReflectiveGenericLifecycleObserver(Object wrapped) &#123;</span><br><span class="line">        mWrapped = wrapped;</span><br><span class="line">        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> Event event)</span> </span>&#123;</span><br><span class="line">        mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在onStateChanged方法中调用了CallbackInfo的invokeCallbacks方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeCallbacks</span><span class="params">(LifecycleOwner source, Lifecycle.Event event, Object target)</span> </span>&#123;</span><br><span class="line">        invokeMethodsForEvent(mEventToHandlers.get(event), source, event, target);</span><br><span class="line">        invokeMethodsForEvent(mEventToHandlers.get(Lifecycle.Event.ON_ANY), source, event,</span><br><span class="line">                target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeMethodsForEvent</span><span class="params">(List&lt;MethodReference&gt; handlers,</span></span></span><br><span class="line"><span class="function"><span class="params">        LifecycleOwner source, Lifecycle.Event event, Object mWrapped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = handlers.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                handlers.get(i).invokeCallback(source, event, mWrapped);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mCallType;</span><br><span class="line">    <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">    MethodReference(<span class="keyword">int</span> callType, Method method) &#123;</span><br><span class="line">        mCallType = callType;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invokeCallback</span><span class="params">(LifecycleOwner source, Lifecycle.Event event, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (mCallType) &#123;</span><br><span class="line">                <span class="keyword">case</span> CALL_TYPE_NO_ARG:</span><br><span class="line">                    mMethod.invoke(target);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CALL_TYPE_PROVIDER:</span><br><span class="line">                    mMethod.invoke(target, source);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CALL_TYPE_PROVIDER_WITH_EVENT:</span><br><span class="line">                    mMethod.invoke(target, source, event);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failed to call observer method&quot;</span>, e.getCause());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最后走到的是MethodReference的invokeCallback方法，而MethodReference中有两个变量，一个是callType，它表示调用方法的类型，另一个是Method，表示方法，不管是哪种callType都会通过invoke对方法进行反射。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后我们以一张调用的时序图来对上述流程做个总结。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210220154001.jpg"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle?hl=zh_cn#use-cases">官方文档</a></p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
  </entry>
  <entry>
    <title>Android Jetpack架构组件——Lifecycle使用篇</title>
    <url>/jetpack/lifecycle_use/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Lifecycle是一个持有组件生命周期状态的class，并且允许其他组件来观察生命周期的变化。并不局限于Activity或者Fragment。我们只知道生命周期是由操作系统或者进程中运行的代码进行管理。而且生命周期是Android工作原理的核心，所以应用必须遵循它们。否则会引起OOM或者Crash。</p>
<h3 id="为什么需要使用Lifecycle管理生命周期"><a href="#为什么需要使用Lifecycle管理生命周期" class="headerlink" title="为什么需要使用Lifecycle管理生命周期"></a>为什么需要使用Lifecycle管理生命周期</h3><p>在此我们用官网提供的一个示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> callback: (Location) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// connect to system location service</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// disconnect from system location service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> myLocationListener: MyLocationListener</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(...)</span></span> &#123;</span><br><span class="line">        myLocationListener = MyLocationListener(<span class="keyword">this</span>) &#123; location -&gt;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        myLocationListener.start()</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        myLocationListener.stop()</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从逻辑上看这段代码其实没什么问题，但是在真实应用场景中，我们需要管理很多组件和当前页面的调用，以响应当前生命周期的状态。所以会导致我们在onStop和onStart中存放大量的代码，导致它们难以维护。</p>
<p>所以官方提供lifecycle就是为了可以帮助我们以弹性和隔离的方式解决这些问题。</p>
<h3 id="如何使用Lifecycle"><a href="#如何使用Lifecycle" class="headerlink" title="如何使用Lifecycle"></a>如何使用Lifecycle</h3><h4 id="lifecycle依赖"><a href="#lifecycle依赖" class="headerlink" title="lifecycle依赖"></a>lifecycle依赖</h4><p>如果需要使用lifecycle的依赖，需要家google的maven仓库添加到项目中，在项目中的build.gradle新增：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在你的工程目录中的build.gradle中新增如下依赖：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def lifecycle_version = <span class="string">&quot;2.2.0&quot;</span></span><br><span class="line">    def arch_version = <span class="string">&quot;2.1.0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:<span class="variable">$lifecycle_version</span>&quot;</span></span><br><span class="line">    <span class="comment">// LiveData</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-livedata-ktx:<span class="variable">$lifecycle_version</span>&quot;</span></span><br><span class="line">    <span class="comment">// Lifecycles only (without ViewModel or LiveData)</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-runtime-ktx:<span class="variable">$lifecycle_version</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Saved state module for ViewModel</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:<span class="variable">$lifecycle_version</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotation processor</span></span><br><span class="line">    kapt <span class="string">&quot;androidx.lifecycle:lifecycle-compiler:<span class="variable">$lifecycle_version</span>&quot;</span></span><br><span class="line">    <span class="comment">// alternately - if using Java8, use the following instead of lifecycle-compiler</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-common-java8:<span class="variable">$lifecycle_version</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - helpers for implementing LifecycleOwner in a Service</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-service:<span class="variable">$lifecycle_version</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - ProcessLifecycleOwner provides a lifecycle for the whole application process</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-process:<span class="variable">$lifecycle_version</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - ReactiveStreams support for LiveData</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.lifecycle:lifecycle-reactivestreams-ktx:<span class="variable">$lifecycle_version</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers for LiveData</span></span><br><span class="line">    testImplementation <span class="string">&quot;androidx.arch.core:core-testing:<span class="variable">$arch_version</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>生命周期拥有者使用getLifecycle()或者实例，然后通过addObserver添加观察者。</li>
<li>观察者实现LifecycleObserver接口，通过使用OnLifecycleEvent注解关注相应的生命周期。</li>
</ul>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>我们这里依然使用官方的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> : <span class="type">LifecycleObserver &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">connectListener</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">disconnectListener</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myLifecycleOwner.getLifecycle().addObserver(MyObserver())</span><br></pre></td></tr></table></figure>
<p>首先MyObserver实现LifecycleObserver接口，并使用ON_RESUME和ON_PAUSE注解对方法加上了生命周期的限制。然后拥有者直接通过添加观察者的形式进行调用即可。</p>
<h4 id="实现自定义的LifecycleOwner"><a href="#实现自定义的LifecycleOwner" class="headerlink" title="实现自定义的LifecycleOwner"></a>实现自定义的LifecycleOwner</h4><p>在26.1.0及更高版本中的Fragment和Activity已经默认实现了LifecycleOwner接口。<br>如果你需要自定义类并希望它成为LifecycleOwner。你可以使用 LifecycleRegistry。示例代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">Activity</span></span>(), LifecycleOwner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> lifecycleRegistry: LifecycleRegistry</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        lifecycleRegistry = LifecycleRegistry(<span class="keyword">this</span>)</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.CREATED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLifecycle</span><span class="params">()</span></span>: Lifecycle &#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过makeState设置Lifecycle的各种状态，然后通过getLifecycle返回该实例。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>我们简单通过lifecycle对应用的前后台进行一个监听。我们先看下我们使用lifecycle之前是怎么对应用的前后台监听的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:2020/12/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:Silence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivityLifecycleCallback</span> : <span class="type">Application.ActivityLifecycleCallbacks &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentResumedActivity: WeakReference&lt;Activity&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听app前后台的监听器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> listener: OnAppStatusListener? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开的Activity数量统计</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> activityStartCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerAppStatusListener</span><span class="params">(listener: <span class="type">OnAppStatusListener</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityPaused</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        currentResumedActivity == <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStarted</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        activityStartCount++</span><br><span class="line">        <span class="keyword">if</span> (activityStartCount == <span class="number">1</span>) &#123;</span><br><span class="line">            listener?.onAppFront()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(activity: <span class="type">Activity</span>, bundle: <span class="type">Bundle</span>)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        activityStartCount--</span><br><span class="line">        <span class="keyword">if</span> (activityStartCount == <span class="number">0</span>) &#123;</span><br><span class="line">            listener?.onAppBackground()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(activity: <span class="type">Activity</span>, bundle: <span class="type">Bundle</span>?)</span></span> = <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResumed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        currentResumedActivity = WeakReference(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentActivity</span><span class="params">()</span></span>: Activity? &#123;</span><br><span class="line">        <span class="keyword">return</span> currentResumedActivity?.<span class="keyword">get</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是感觉代码有点繁琐？需要通过对activity记数来判断应用是否在前后台。那么如果我们通过lifecycle会变成怎样呢？那我们来看一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:2021/02/08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:Silence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppLifeObserver</span> : <span class="type">LifecycleObserver &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onForeground</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onBackground</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在application直接调用如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ProcessLifecycleOwner.<span class="keyword">get</span>().lifecycle.addObserver(AppLifeObserver())</span><br></pre></td></tr></table></figure>
<p>是不是相对之前的记数方法简单很多。而且通过lifecycle的实现可读性相对而言会更高。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们简单介绍了lifecycle的使用以及通过尝试使用lifecycle这个歌简单的例子对app前台后做监听。可以发现lifecycle的使用很简单。但是本篇并没有讲到lifecycle的原理。因为你只有会使用了才会愿意了解原理。那么下一篇我们讲lifecycle的实现原理。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle?hl=zh_cn#kotlin">官方文档</a></p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
  </entry>
  <entry>
    <title>Android Jetpack架构组件——LiveData原理篇</title>
    <url>/jetpack/livedata_theory/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面我们讲到了LiveData是如何使用的，并在最后留了几个问题。比如它是如何通过生命周期去变化的？为什么DESTORY不会接受数据？postValue和setValue是如何更新数据的？Transformations的map和switchMap方法内部是如何操作的？别急，本篇文章会带你了解其原理。接下来上正文。</p>
<h3 id="LiveData是如何观察生命周期变化的？"><a href="#LiveData是如何观察生命周期变化的？" class="headerlink" title="LiveData是如何观察生命周期变化的？"></a>LiveData是如何观察生命周期变化的？</h3><p>如何观察生命周期，我们需要通过他的observe方法去看，我们上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner owner, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observe&quot;</span>);</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在源码加了几个注释，我们一个个看。  </p>
<p>注释一：可以看出通过当前组件的LifecycleOwner拿到生命周期的状态，如果是DESTORY就返回，不做任何处理。</p>
<p>注释二：新建了一个LifecycleBoundObserver包装类，并把owner和observer丢进去。</p>
<p>注释三：将observer和wrapper做一个存储。我们看下putIfAbsent方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(<span class="meta">@NonNull</span> K key, <span class="meta">@NonNull</span> V v)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K, V&gt; entry = get(key);</span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> entry.mValue;</span><br><span class="line">        &#125;</span><br><span class="line">        put(key, v);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，如何这个entry存在的话，不像正常map做替换，而且直接拿到对应的value。不存在的话正常put操作。</p>
<p>注释四：判断这个owner是否存在，如何存在就抛出异常，提示无法添加具有不同生命周期的同一观察者。</p>
<p>注释五：将LifecycleBoundObserver添加到Lifecycle中完成注册，所以我们LiveData的生命周期观察其实来源于LifecycleOwner，这也就是为什么LiveData具备了观察组件生命周期变化的能力。</p>
<h3 id="observe是如何同步数据的？"><a href="#observe是如何同步数据的？" class="headerlink" title="observe是如何同步数据的？"></a>observe是如何同步数据的？</h3><p>上面代码中我们知道有一个LifecycleBoundObserver的包装类。我们看看其实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">LifecycleEventObserver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@NonNull</span></span><br><span class="line">        <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">        LifecycleBoundObserver(<span class="meta">@NonNull</span> LifecycleOwner owner, Observer&lt;? <span class="keyword">super</span> T&gt; observer) &#123;</span><br><span class="line">            <span class="keyword">super</span>(observer);</span><br><span class="line">            mOwner = owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">            Lifecycle.State currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">            <span class="keyword">if</span> (currentState == DESTROYED) &#123;</span><br><span class="line">                removeObserver(mObserver);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Lifecycle.State prevState = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (prevState != currentState) &#123;</span><br><span class="line">                prevState = currentState;</span><br><span class="line">                activeStateChanged(shouldBeActive());</span><br><span class="line">                currentState = mOwner.getLifecycle().getCurrentState();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们来关注几个方法。通过ObserverWrapper实现了shouldBeActive。从命名上可以看出判读是否活跃。从代码看来也就是STARTED和RESUMED。</p>
<p>在看另一个，通过LifecycleEventObserver实现了onStateChanged方法。我们可以看到如果当前的STATE是DESTROYED时会移除观察者监听。接着通过判读状态是否匹配调用了activeStateChanged方法。因为prevState定义为null。所以此方法最少执行一次。那么我们看看它是如何处理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// immediately set active state, so we&#x27;d never dispatch anything to inactive</span></span><br><span class="line">            <span class="comment">// owner</span></span><br><span class="line">            mActive = newActive;</span><br><span class="line">            changeActiveCounter(mActive ? <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">                dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它会先调用changeActiveCounter，字面意思也就是改变活跃的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeActiveCounter</span><span class="params">(<span class="keyword">int</span> change)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> previousActiveCount = mActiveCount;</span><br><span class="line">        mActiveCount += change;</span><br><span class="line">        <span class="keyword">if</span> (mChangingActiveState) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mChangingActiveState = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (previousActiveCount != mActiveCount) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> needToCallActive = previousActiveCount == <span class="number">0</span> &amp;&amp; mActiveCount &gt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> needToCallInactive = previousActiveCount &gt; <span class="number">0</span> &amp;&amp; mActiveCount == <span class="number">0</span>;</span><br><span class="line">                previousActiveCount = mActiveCount;</span><br><span class="line">                <span class="keyword">if</span> (needToCallActive) &#123;</span><br><span class="line">                    onActive();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needToCallInactive) &#123;</span><br><span class="line">                    onInactive();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mChangingActiveState = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从逻辑上我们可以看出previousActiveCount默认为0，mActiveCount可能为1，可能为-1，mChangingActiveState默认为flase。也就是一定会走进while循环里面去。从里面代码可以看出需要通知组件存活状态就调用onActive，需要通知组件不活跃就调用onInactive。然后我们往回看，如果组件是活跃的就会调用dispatchingValue方法。我们接着看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(<span class="meta">@Nullable</span> ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line">        mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class="keyword">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释一中mDispatchingValue用于标记当前是否处于分发状态中，如果是存在分发状态，则执行注释二表示分发无效并直接return。注释三则将分发状态修改成有效状态。我们可以看到后面无论initiator是否为null都会执行considerNotify方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn&#x27;t get the event yet.</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">       <span class="comment">// the observer moved to an active state, if we&#x27;ve not received that event, we better not</span></span><br><span class="line">       <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">       <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">           observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       observer.mLastVersion = mVersion;</span><br><span class="line">       observer.mObserver.onChanged((T) mData);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到当前状态如果是非活跃的就直接return了。接着判读了如果当前observer对应组件的状态不是Active，就会再次调用activeStateChanged方法，并传入false，其方法内部会再次判断是否执行onActive方法和onInactive方法回调。接着就会调用Observer的onChange方法通知数据更新。</p>
<h3 id="postValue和setValue的区别是什么？"><a href="#postValue和setValue的区别是什么？" class="headerlink" title="postValue和setValue的区别是什么？"></a>postValue和setValue的区别是什么？</h3><p>我们知道虽然我们调用observe方法对数据进行观察，但是真正同步数据的代码是postValue和setValue。话不多说，上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Runnable mPostValueRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Object newValue;</span><br><span class="line">         <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">             newValue = mPendingData;</span><br><span class="line">             mPendingData = NOT_SET;</span><br><span class="line">         &#125;</span><br><span class="line">         setValue((T) newValue);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> postTask;</span><br><span class="line">     <span class="keyword">synchronized</span> (mDataLock) &#123;</span><br><span class="line">         postTask = mPendingData == NOT_SET;</span><br><span class="line">         mPendingData = value;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@MainThread</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">     assertMainThread(<span class="string">&quot;setValue&quot;</span>);</span><br><span class="line">     mVersion++;</span><br><span class="line">     mData = value;</span><br><span class="line">     dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到setValue加上了@MainThread注解，也就是在主线程中执行，并且会调用dispatchingValue传入null。这个前面我们有提到过。而postValue其实是在子线程操作，最后通过postToMainThread同步至主线程，最后其实还是调用了setValue方法。</p>
<h3 id="Transformations分析"><a href="#Transformations分析" class="headerlink" title="Transformations分析"></a>Transformations分析</h3><p>前面我们在使用篇时有提到Transformations有2个方法，一个是map。一个是switchMap。我们一个个的看。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line">   <span class="meta">@NonNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;X, Y&gt; <span class="function">LiveData&lt;Y&gt; <span class="title">map</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="meta">@NonNull</span> LiveData&lt;X&gt; source,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="meta">@NonNull</span> <span class="keyword">final</span> Function&lt;X, Y&gt; mapFunction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> MediatorLiveData&lt;Y&gt; result = <span class="keyword">new</span> MediatorLiveData&lt;&gt;();</span><br><span class="line">       result.addSource(source, <span class="keyword">new</span> Observer&lt;X&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(<span class="meta">@Nullable</span> X x)</span> </span>&#123;</span><br><span class="line">               result.setValue(mapFunction.apply(x));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到此处调用了MediatorLiveData的addSource方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;S&gt; <span class="function"><span class="keyword">void</span> <span class="title">addSource</span><span class="params">(<span class="meta">@NonNull</span> LiveData&lt;S&gt; source, <span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> S&gt; onChanged)</span> </span>&#123;</span><br><span class="line">    Source&lt;S&gt; e = <span class="keyword">new</span> Source&lt;&gt;(source, onChanged);</span><br><span class="line">    Source&lt;?&gt; existing = mSources.putIfAbsent(source, e);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; existing.mObserver != onChanged) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">&quot;This source was already added with the different observer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasActiveObservers()) &#123;</span><br><span class="line">        e.plug();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最后一个判断，如果存在活跃的观察者，即调用Source的plug方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LiveData&lt;V&gt; mLiveData;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> V&gt; mObserver;</span><br><span class="line">        <span class="keyword">int</span> mVersion = START_VERSION;</span><br><span class="line"></span><br><span class="line">        Source(LiveData&lt;V&gt; liveData, <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> V&gt; observer) &#123;</span><br><span class="line">            mLiveData = liveData;</span><br><span class="line">            mObserver = observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">plug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mLiveData.observeForever(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unplug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mLiveData.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(<span class="meta">@Nullable</span> V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mVersion != mLiveData.getVersion()) &#123;</span><br><span class="line">                mVersion = mLiveData.getVersion();</span><br><span class="line">                mObserver.onChanged(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到Source提供了添加观察者，移除观察者，以及监听的操作。哎，不对，是不是发现哪里有点问题？这里它调用的是observeForever，而不是addObserver。那我们接着看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observeForever</span><span class="params">(<span class="meta">@NonNull</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">&quot;observeForever&quot;</span>);</span><br><span class="line">    AlwaysActiveObserver wrapper = <span class="keyword">new</span> AlwaysActiveObserver(observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> LiveData.LifecycleBoundObserver) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cannot add the same observer&quot;</span></span><br><span class="line">                + <span class="string">&quot; with different lifecycles&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.activeStateChanged(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这里最后其实还是调用了ObserverWrapper的activeStateChanged方法。</p>
<h4 id="switchMap"><a href="#switchMap" class="headerlink" title="switchMap"></a>switchMap</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;X, Y&gt; LiveData&lt;Y&gt; switchMap(</span><br><span class="line">        <span class="meta">@NonNull</span> LiveData&lt;X&gt; source,</span><br><span class="line">        <span class="meta">@NonNull</span> final <span class="built_in">Function</span>&lt;X, LiveData&lt;Y&gt;&gt; switchMapFunction) &#123;</span><br><span class="line">    final MediatorLiveData&lt;Y&gt; result = <span class="keyword">new</span> MediatorLiveData&lt;&gt;();</span><br><span class="line">    result.addSource(source, <span class="keyword">new</span> Observer&lt;X&gt;() &#123;</span><br><span class="line">        LiveData&lt;Y&gt; mSource;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params"><span class="meta">@Nullable</span> X x</span>)</span> &#123;</span><br><span class="line">            LiveData&lt;Y&gt; newLiveData = switchMapFunction.apply(x);</span><br><span class="line">            <span class="keyword">if</span> (mSource == newLiveData) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mSource != <span class="literal">null</span>) &#123;</span><br><span class="line">                result.removeSource(mSource);</span><br><span class="line">            &#125;</span><br><span class="line">            mSource = newLiveData;</span><br><span class="line">            <span class="keyword">if</span> (mSource != <span class="literal">null</span>) &#123;</span><br><span class="line">                result.addSource(mSource, <span class="keyword">new</span> Observer&lt;Y&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onChanged</span>(<span class="params"><span class="meta">@Nullable</span> Y y</span>)</span> &#123;</span><br><span class="line">                        result.setValue(y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，整体和map类似，只是内部包装了一层，让其返回结果是一个LiveData而已。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇我们整体介绍了LiveData的使用原理，也就是上篇文章遗留下来的几个问题。总之，我们不仅需要知其然，还需要知其所以然。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://liuwangshu.cn/application/jetpack/5-livedata-theory.html">Android Jetpack架构组件（五）带你了解LiveData(原理篇）</a></p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
  </entry>
  <entry>
    <title>Android Jetpack架构组件——LiveData使用篇</title>
    <url>/jetpack/livedata_use/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一般来说，LiveData很少单独使用，它更多的和Android Jetpack的其他组件搭配使用，比如ViewModel和ViewBinding。所以前面我们介绍ViewModel的使用以及其实现原理。那么这篇文章就来介绍LiveData的使用。</p>
<h3 id="LiveData是什么？"><a href="#LiveData是什么？" class="headerlink" title="LiveData是什么？"></a>LiveData是什么？</h3><p>通过字面意思其实我们可以理解成生存(活着)的数据。我们看下官方是怎么介绍它的：</p>
<blockquote>
<p>LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保LiveData仅更新处于活跃生命周期状态的应用组件观察者。</p>
</blockquote>
<p>化繁为简：</p>
<ul>
<li>LiveData具备生命周期的感知能力</li>
<li>LiveData只存在活跃的生命周期里，比如STARTED或RESUMED。</li>
</ul>
<h3 id="LiveData的优势"><a href="#LiveData的优势" class="headerlink" title="LiveData的优势"></a>LiveData的优势</h3><p>使用 LiveData 具有以下优势：</p>
<ul>
<li><p><strong>确保界面符合数据状态</strong><br>LiveData 遵循观察者模式。当底层数据发生变化时，LiveData会通知Observer对象。您可以整合代码以在这些Observer对象中更新界面。这样一来，您无需在每次应用数据发生变化时更新界面，因为观察者会替您完成更新。</p>
</li>
<li><p><strong>不会发生内存泄漏</strong><br>观察者会绑定到 Lifecycle 对象，并在其关联的生命周期遭到销毁后进行自我清理。<br>不会因 Activity 停止而导致崩溃如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何LiveData事件。</p>
</li>
<li><p><strong>不再需要手动处理生命周期</strong><br>界面组件只是观察相关数据，不会停止或恢复观察。LiveData将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。</p>
</li>
<li><p><strong>数据始终保持最新状态</strong><br>如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的Activity会在返回前台后立即接收最新的数据。</p>
</li>
<li><p><strong>适当的配置更改</strong><br>如果由于配置更改（如设备旋转）而重新创建了Activity或Fragment，它会立即接收最新的可用数据。</p>
</li>
<li><p><strong>共享资源</strong><br>您可以使用单例模式扩展LiveData对象以封装系统服务，以便在应用中共享它们。LiveData对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察LiveData对象。</p>
</li>
</ul>
<h3 id="如何使用LiveData"><a href="#如何使用LiveData" class="headerlink" title="如何使用LiveData"></a>如何使用LiveData</h3><p>前面我们介绍了LiveData是什么以及它的优势有什么，那么接下来我们介绍下到底如何使用它。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>LiveData是一个抽象类，不能直接使用，我们一般使用它的直接子类MutableLiveData。那我们直接写例子，直接在之前的ViewModel里面修改代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:2021/2/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:Silence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userData: MutableLiveData&lt;UserInfo&gt; = MutableLiveData()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> user = UserInfo(<span class="string">&quot;我就是马云飞&quot;</span>, (<span class="number">1.</span><span class="number">.100</span>).random())</span><br><span class="line">        userData.postValue(user)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateUserInfo</span><span class="params">(userInfo: <span class="type">UserInfo</span>)</span></span> &#123;</span><br><span class="line">        userData.postValue(userInfo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看看怎么在Activity里面获取这个data呢。接着看代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> lazy &#123; ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(MyViewModel::<span class="keyword">class</span>.java) &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_view_model)</span><br><span class="line">    viewModel.userData.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate: &quot;</span> + <span class="string">&quot;姓名：<span class="subst">$&#123;it.name&#125;</span> \t年龄：<span class="subst">$&#123;it.age&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    liveDataBtn.setOnClickListener &#123;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            viewModel.getUserInfo()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> user = UserInfo(<span class="string">&quot;你不是马云飞&quot;</span>, (<span class="number">1.</span><span class="number">.100</span>).random())</span><br><span class="line">            viewModel.updateUserInfo(user)</span><br><span class="line">        &#125;</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在Activity中对viewModel的userData做了监听，实时观察数据的变化。那么我们现在进行点击看看效果如何：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210224221658.png" alt="image"></p>
<p>果然，只要我数据更新了，我的Log立马就输出了。</p>
<h4 id="扩展使用"><a href="#扩展使用" class="headerlink" title="扩展使用"></a>扩展使用</h4><p>如果观察者的生命周期处于STARTED或RESUMED状态，则LiveData会认为该观察者处于活跃状态。我们直接看官方的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span></span>(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123;</span><br><span class="line">    <span class="comment">//股票管理类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stockManager: StockManager = StockManager(symbol)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听股票价格的变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> listener = &#123; price: BigDecimal -&gt;</span><br><span class="line">        <span class="comment">//更新value值</span></span><br><span class="line">        value = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//页面处于活跃状态时，开始观察股票价格的数据更新</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//页面处于非活跃状态，移除相关监听</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.removeUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> sInstance: StockLiveData</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这是一个单例</span></span><br><span class="line">        <span class="meta">@MainThread</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(symbol: <span class="type">String</span>)</span></span>: StockLiveData &#123;</span><br><span class="line">            sInstance = <span class="keyword">if</span> (::sInstance.isInitialized) sInstance <span class="keyword">else</span> StockLiveData(symbol)</span><br><span class="line">            <span class="keyword">return</span> sInstance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Fragment中的使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        StockLiveData.<span class="keyword">get</span>(symbol).observe(viewLifecycleOwner, Observer&lt;BigDecimal&gt; &#123; price: BigDecimal? -&gt;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们看下上述的代码，具体包含如下功能：</p>
<ul>
<li><p>本身是个单例，也就是可以在多个Activity与Fragment中进行数据监听。</p>
</li>
<li><p>当具备活跃的观察者时，会调用onActive方法，监听股价的变动。</p>
</li>
<li><p>当其观察者不具备活跃状态时，会调用onInactive方法，移除监听。也就是就算值改变了，也不会同步更新，同理，当页面销毁时，会自动移除监听。</p>
</li>
</ul>
<h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>我们按照上面我们的示例代码继续，前面我们打印了姓名和年龄，那么假设，我暂时不需要字段，我需要通过姓名拿到他的班级以及学号。也就是通过姓名将数据转换成班级和学号，LiveData也给我们提供了相关方法,可以通过Transformations.map去实现。具体代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewModelActivity.kt</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_view_model)</span><br><span class="line">        viewModel.userData.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onCreate: &quot;</span> + <span class="string">&quot;姓名：<span class="subst">$&#123;it.name&#125;</span> \t年龄：<span class="subst">$&#123;it.age&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        viewModel.getUserInfo()</span><br><span class="line">        viewModel.classInfo.observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onCreate: &quot;</span> + <span class="string">&quot;班级：<span class="subst">$&#123;it?.grade&#125;</span> \t学号：<span class="subst">$&#123;it?.id&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        liveDataBtn.setOnClickListener &#123;</span><br><span class="line">            viewModel.getClassIdByUser().observe(<span class="keyword">this</span>, Observer &#123;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyViewModel.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getClassIdByUser</span><span class="params">()</span></span>: LiveData&lt;ClassBean?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Transformations.map(userData) &#123; input -&gt;</span><br><span class="line">            <span class="keyword">var</span> classBean: ClassBean? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">if</span> (input?.name == <span class="string">&quot;我就是马云飞&quot;</span>) &#123;</span><br><span class="line">                classBean = ClassBean(<span class="string">&quot;高三&quot;</span>, (<span class="number">1.</span><span class="number">.100</span>).random())</span><br><span class="line">                classInfo.postValue(classBean)</span><br><span class="line">            &#125;</span><br><span class="line">            classBean</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先我们进入页面先获取一次用户的姓名和年龄，然后当我们点击按钮的时候，我们根据用户的姓名给他定义一个班级和学号。我们来看下效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210225183634.png"></p>
<p>可以看到，每次点击的时候，它都会给我们生成一个学号。说明我们的数据转换成功了。</p>
<h5 id="switchMap"><a href="#switchMap" class="headerlink" title="switchMap"></a>switchMap</h5><p>switchMap的方法和map大同小异，只是它是返回一个liveData<T>，而上面map是直接返回T。我们直接上代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getClassIdByUser</span><span class="params">()</span></span>: LiveData&lt;ClassBean?&gt; &#123;</span><br><span class="line">       <span class="keyword">return</span> Transformations.switchMap(userData) &#123;</span><br><span class="line">           <span class="keyword">val</span> classBean = ClassBean(<span class="string">&quot;高三&quot;</span>, (<span class="number">1.</span><span class="number">.100</span>).random())</span><br><span class="line">           classInfo.postValue(classBean)</span><br><span class="line">           classInfo</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>输出也基本差不多。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210225191739.png"></p>
<h4 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h4><p>所谓的数据合并是什么呢？之前我们如果有多套的LiveData，我们需要对多套数据进行观察。而数据合并可以做到批量添加LiveData并且只实现一组观察逻辑就可以监听多套数据的改动。我们修改一下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.mediatorLiveData.addSource(viewModel.userData) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;卧槽，数据合并也可以监听！！！！onCreate: &quot;</span> + <span class="string">&quot;姓名：<span class="subst">$&#123;it.name&#125;</span> \t年龄：<span class="subst">$&#123;it.age&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">viewModel.mediatorLiveData.addSource(viewModel.classInfo) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;卧槽，数据合并也可以监听！！！！onCreate: &quot;</span> + <span class="string">&quot;班级：<span class="subst">$&#123;it?.grade&#125;</span> \t学号：<span class="subst">$&#123;it?.id&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">viewModel.mediatorLiveData.observe(<span class="keyword">this</span>, Observer&lt;Any?&gt; &#123;</span><br><span class="line">&#125;)</span><br><span class="line">liveDataBtn.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        viewModel.getUserInfo()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel.getClassInfo()</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续通过点击看看效果如何：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210226173735.png"></p>
<p>哎。可以了～</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们主要介绍了LiveData是什么，以及它的优势和使用方法。而LiveData的很多细节我们没有去关注，比如postValue和setValue。比如Transformations的map和switchMap方法。后面我们会在LiveData原理篇讲到。毕竟我们需要了解它是怎么使用的。会使用后才会想去了解其原理。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.android.google.cn/topic/libraries/architecture/livedata?hl=zh_cn#merge_livedata">官网</a></p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
  </entry>
  <entry>
    <title>Android Jetpack导航组件——Navigation的使用</title>
    <url>/jetpack/navigation_use/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Navigation是采用一个Activity和多个Fragment形式设计的Ui架构模式，但是众所周知，Fragment的管理一直是个麻烦事，需要通过FragmentManager和FragmentTransaction来管理Fragment之间的切换。所以Google提供了一套Navigation用来管理Fragment相互间的跳转等逻辑。我们先看下Navigation的优势：</p>
<ul>
<li><p>处理 Fragment 事务。</p>
</li>
<li><p>默认情况下，正确处理往返操作。</p>
</li>
<li><p>为动画和转换提供标准化资源。</p>
</li>
<li><p>实现和处理深层链接。</p>
</li>
<li><p>包括导航界面模式（例如抽屉式导航栏和底部导航），用户只需完成极少的额外工作。</p>
</li>
<li><p>Safe Args - 可在目标之间导航和传递数据时提供类型安全的 Gradle 插件。</p>
</li>
<li><p>ViewModel支持 - 您可以将ViewModel的范围限定为导航图，以在图表的目标之间共享与界面相关的数据。</p>
</li>
</ul>
<p>正式介绍前，我们需要了解Navigation是由哪几部分组成的，现在我们看一下：</p>
<ul>
<li><p><strong>NavHostFragment</strong>：一种特殊的Fragment，用于承载导航内容的容器。</p>
</li>
<li><p><strong>Navigation Graph</strong>：一个包含所有导航和页面关系相关的 XML资源。</p>
</li>
<li><p><strong>NavController</strong>：管理应用导航的对象，实现Fragment之间的跳转等操作。</p>
</li>
</ul>
<h3 id="Navigation使用"><a href="#Navigation使用" class="headerlink" title="Navigation使用"></a>Navigation使用</h3><h4 id="Navigation-Graph"><a href="#Navigation-Graph" class="headerlink" title="Navigation Graph"></a>Navigation Graph</h4><p>首先我们在build.gradle 文件中新增navigation的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">implementation(<span class="string">&quot;androidx.navigation:navigation-fragment-ktx:$lifecycle_version&quot;</span>) </span><br><span class="line">implementation(<span class="string">&quot;androidx.navigation:navigation-ui-ktx:$lifecycle_version&quot;</span>) </span><br></pre></td></tr></table></figure>
<p>然后我们需要新建一个Navigation，点击Project-&gt;Res-&gt;New Android Resource File,Resource Type选择Navigation，如下图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210307172451.png"></p>
<p>打开新建的nav_graph.xml文件，在Design界面可以看到目前还没有内容，可以依次点击[New Destination]图标，然后点击[Create new destination]，即可快速创建新的Fragment,这里作次示例，因为本身之前我已经新建好多个Fragment了，就不单独示范了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210309203232.gif"></p>
<p>我们可以点击视图的小圆点，建议页面的绑定关系。我这里已经建立好多个页面的绑定关系，同时你可以切换至code模块，本人代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/jetpack_nav&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">&quot;@id/navigationFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=&quot;@+id/navigationFragment&quot;</span><br><span class="line">        android:name=&quot;com.silence.apmprojetct.NavigationFragment&quot;</span><br><span class="line">        android:label=&quot;fragment_navigation&quot;</span><br><span class="line">        tools:layout=&quot;@layout/fragment_navigation&quot;&gt;</span><br><span class="line">        &lt;action</span><br><span class="line">            android:id=&quot;@+id/action_navigationFragment_to_blankFragment&quot;</span><br><span class="line">            app:destination=&quot;@id/blankFragment&quot; /&gt;</span><br><span class="line">        &lt;action</span><br><span class="line">            android:id=&quot;@+id/action_navigationFragment_to_threeFragment&quot;</span><br><span class="line">            app:destination=&quot;@+id/threeFragment&quot; /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=&quot;@+id/blankFragment&quot;</span><br><span class="line">        android:name=&quot;com.silence.apmprojetct.SecondFragment&quot;</span><br><span class="line">        android:label=&quot;fragment_blank&quot;</span><br><span class="line">        tools:layout=&quot;@layout/fragment_second&quot;&gt;</span><br><span class="line">        &lt;action</span><br><span class="line">            android:id=&quot;@+id/action_blankFragment_to_threeFragment&quot;</span><br><span class="line">            app:destination=&quot;@id/threeFragment&quot; /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=&quot;@+id/threeFragment&quot;</span><br><span class="line">        android:name=&quot;com.silence.apmprojetct.ThreeFragment&quot;</span><br><span class="line">        android:label=&quot;fragment_three&quot;</span><br><span class="line">        tools:layout=&quot;@layout/fragment_three&quot;&gt;</span><br><span class="line">        &lt;action</span><br><span class="line">            android:id=&quot;@+id/action_threeFragment_to_navigationFragment&quot;</span><br><span class="line">            app:destination=&quot;@+id/navigationFragment&quot;</span><br><span class="line">            app:enterAnim=&quot;@anim/nav_default_enter_anim&quot;</span><br><span class="line">            app:exitAnim=&quot;@anim/nav_default_exit_anim&quot;</span><br><span class="line">            app:popEnterAnim=&quot;@anim/nav_default_pop_enter_anim&quot;</span><br><span class="line">            app:popExitAnim=&quot;@anim/nav_default_pop_exit_anim&quot; /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们看下几个标签的含义：</p>
<ul>
<li>navigation：根标签，通过startDestination配置指定默认的启动页面。</li>
<li>fragment： fragment标签代表一个fragment。</li>
<li>action：action标签定义了页面跳转的行为，destination标签定义跳转的目标页，里面还有启动模式的相关设置等等。</li>
</ul>
<h4 id="NavHostFragment"><a href="#NavHostFragment" class="headerlink" title="NavHostFragment"></a>NavHostFragment</h4><p>而讲到这里，我们只概括前面三个模块其中之一Navigation Graph。我们知道Fragment需要一个Activity才能正常运行，但是我们如何在我们的Activity指定我们上面startDestination呢。这就需要用到了NavHostFragment。我们看下我们Activity的布局代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.NavigationActivity&quot;</span>&gt;</span></span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=&quot;@+id/fragment&quot;</span><br><span class="line">        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        app:defaultNavHost=&quot;true&quot;</span><br><span class="line">        app:navGraph=&quot;@navigation/jetpack_nav&quot; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到布局里定义了一个Fragment，并且它使用的就是NavHostFragment，可以看到navGraph属性绑定了我们刚刚写的Navigation文件。而defaultNavHost就是做到了自动实现了页面间的返回操作。如果没有这个属性，点击返回的时候就是直接关闭当前Activity了。当然，其内部Fragment的点击事件我们可以自己控制。</p>
<p>然后我们可以运行程序，可以看到默认展示的是NavigationFragment页面，这是因为NavigationActivity的布局文件中配置了NavHostFragment，并且给NavHostFragment指定了默认展示的页面为NavigationFragment。</p>
<h4 id="NavController"><a href="#NavController" class="headerlink" title="NavController"></a>NavController</h4><p>NavController主要用来管理fragment之间的跳转，每个NavHost均有自己的相应NavController。然后可以使用它的navigate或者navigateUp方法来进行页面之间的路由操作。比如我这边的NavigationFragment需要跳转SecondFragment。我们可以这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">       savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">   )</span></span>: View? &#123;</span><br><span class="line">       <span class="keyword">val</span> view = inflater.inflate(R.layout.fragment_navigation, container, <span class="literal">false</span>)</span><br><span class="line">       view.findViewById&lt;TextView&gt;(R.id.next).setOnClickListener &#123;</span><br><span class="line">           findNavController().navigate(R.id.action_navigationFragment_to_blankFragment)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> view</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>也就是通过navigate指向前面我们在action定义的id。即可完成跳转。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h4 id="Bundle数据传递"><a href="#Bundle数据传递" class="headerlink" title="Bundle数据传递"></a>Bundle数据传递</h4><p>我们可以创建一个Bundle对象，然后使用navigate()将它传递给目的地，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> bundle = Bundle()</span><br><span class="line">bundle.putString(TITLE, getString(R.string.three_fragment_navigation_bundle_label))</span><br><span class="line">findNavController().navigate(R.id.action_blankFragment_to_threeFragment, bundle)</span><br></pre></td></tr></table></figure>
<h4 id="使用-Safe-Args-传递安全的数据"><a href="#使用-Safe-Args-传递安全的数据" class="headerlink" title="使用 Safe Args 传递安全的数据"></a>使用 Safe Args 传递安全的数据</h4><p>这是官方为了navigation数据传递安全提供的一个数据传递方式，首先我们需要在根目录的build.gradle文件中添加如下依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">       <span class="keyword">def</span> nav_version = <span class="string">&quot;2.3.3&quot;</span></span><br><span class="line">       classpath <span class="string">&quot;androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version&quot;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在模块的build.gradle文件中新增如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;androidx.navigation.safeargs.kotlin&quot;</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;androidx.navigation.safeargs&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后我们ReBuild项目，可以看到在build目录中生成了如下文件：<br><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210309221959.png"></p>
<p>然后我们修改我们的代码，比如我需要在ThreeFragment页面新增一个参数，那么我们需要在navigation文件中新增如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;fragment</span><br><span class="line">        android:id=&quot;@+id/threeFragment&quot;</span><br><span class="line">        android:name=&quot;com.silence.apmprojetct.ThreeFragment&quot;</span><br><span class="line">        android:label=&quot;fragment_three&quot;</span><br><span class="line">        tools:layout=&quot;@layout/fragment_three&quot;&gt;</span><br><span class="line">        &lt;action</span><br><span class="line">            android:id=&quot;@+id/action_threeFragment_to_navigationFragment&quot;</span><br><span class="line">            app:destination=&quot;@+id/navigationFragment&quot; /&gt;</span><br><span class="line">        &lt;argument</span><br><span class="line">            android:name=&quot;key&quot;</span><br><span class="line">            app:argType=&quot;string&quot;</span><br><span class="line">            android:defaultValue=&quot;safeArgs&quot; /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们在需要跳转的时候修改下代码，比如我这里SecondFragment会跳转至ThreeFragment。那么我们只需要这么写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">        view.findViewById&lt;TextView&gt;(R.id.next).setOnClickListener &#123;</span><br><span class="line"><span class="comment">//            val bundle = Bundle()</span></span><br><span class="line"><span class="comment">//            bundle.putString(TITLE, getString(R.string.three_fragment_navigation_bundle_label))</span></span><br><span class="line"><span class="comment">//            findNavController().navigate(R.id.action_blankFragment_to_threeFragment, bundle)</span></span><br><span class="line">            <span class="keyword">var</span> secondFragment =</span><br><span class="line">                SecondFragmentDirections.actionBlankFragmentToThreeFragment(<span class="string">&quot;safe传递的数据&quot;</span>)</span><br><span class="line">            findNavController().navigate(secondFragment)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>我们在看下如何在ThreeFragment里接收数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">view.findViewById&lt;TextView&gt;(R.id.title).text = arguments?.let &#123;</span><br><span class="line">           ThreeFragmentArgs.fromBundle(it).key</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h3><h4 id="堆栈处理"><a href="#堆栈处理" class="headerlink" title="堆栈处理"></a>堆栈处理</h4><p>前面我们说到了正常的页面启动，以及如何挟带参数跳转。现在有个场景，比如我A-》B-》C之后，然后直接回到A。并且清栈，也就是在A页面返回就直接关闭当前的Activity了。我们看一下，目前我们的代码执行后效果会如何：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210309225951.gif"></p>
<p>可以看出来我们每次打开新的fragment就相当于新开了一个堆栈。我们可记得我们配置页面的时候有一个action属性。我们把action的代码改成如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;fragment</span><br><span class="line">       android:id=&quot;@+id/threeFragment&quot;</span><br><span class="line">       android:name=&quot;com.silence.apmprojetct.ThreeFragment&quot;</span><br><span class="line">       android:label=&quot;fragment_three&quot;</span><br><span class="line">       tools:layout=&quot;@layout/fragment_three&quot;&gt;</span><br><span class="line">       &lt;action</span><br><span class="line">           android:id=&quot;@+id/action_threeFragment_to_navigationFragment&quot;</span><br><span class="line">           app:destination=&quot;@+id/navigationFragment&quot;</span><br><span class="line">           app:popUpTo=&quot;@+id/navigationFragment&quot;</span><br><span class="line">           app:popUpToInclusive=&quot;true&quot; /&gt;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们运行一下，在看一下效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210309230611.gif"></p>
<p>哎，可以了。</p>
<p>其实action还有一个属性launchSingleTop的设置，这个看具体场景使用即可。</p>
<h4 id="指定startDestination"><a href="#指定startDestination" class="headerlink" title="指定startDestination"></a>指定startDestination</h4><p>我们想一下，如何指定startDestination的Fragment呢。上面介绍过，activity要绑定NavHostFragment。而NavHostFragment要指定startDestination。在我们在navigaiton指定了fragment后，可以修改么。或者说，我可以动态改变他的startDestination嘛。其实是可以的。我们知道startDestination是由navGraph指定的。那么我们只需要修改activity的代码，就可以做到了。具体示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">       setContentView(R.layout.activity_navigation)</span><br><span class="line">       <span class="keyword">val</span> startDestinationID = R.id.blankFragment</span><br><span class="line">       <span class="keyword">val</span> navController = Navigation.findNavController(<span class="keyword">this</span>, R.id.fragment)</span><br><span class="line">       <span class="keyword">val</span> navInflater = navController.navInflater</span><br><span class="line">       <span class="keyword">val</span> navGraph = navInflater.inflate(R.navigation.jetpack_nav)</span><br><span class="line">       navGraph.startDestination = startDestinationID</span><br><span class="line">       navController.graph = navGraph</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>那我们执行一下，看下效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210309232529.gif"></p>
<p>我这边指定了SecondFragment成功了。那具体指定哪一个，由你自己的业务场景而定。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们主要介绍了Jetpack中的导航组件Navigation的组件，从普通的跳转，已经挟带参数跳转，甚至一些特殊场景的跳转逻辑。关于一些其他场景，我这里不过多介绍，因为目前正常的跳转场景基本已经了解了。如果你想知道更多的使用场景，请查看<a href="https://developer.android.google.cn/guide/navigation">官方文档</a>。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
  </entry>
  <entry>
    <title>Android Jetpack架构组件——一文带你了解ViewModel的使用及原理</title>
    <url>/jetpack/viewmodel_use_with_theory/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>前面我们讲过了lifecycle的使用及原理。今天我们谈谈viewModel。原本使用和原理是准备分开写的，结果我看了下ViewModel的原理，很简单，所以决定把两者放在一起了。那么接下来，我们进入正题。</p>
<h3 id="ViewModel是什么？"><a href="#ViewModel是什么？" class="headerlink" title="ViewModel是什么？"></a>ViewModel是什么？</h3><p>ViewModel旨在以注重生命周期的方式存储和管理界面相关的数据。我们知道当屏幕旋转时，Activity会销毁并且重建，而它让数据可在发生屏幕旋转等配置更改后继续留存。  </p>
<p>哎？那就有人要问了，为什么我们不通过onSaveInstanceState()对数据进行保存，然后在onCreate()的时候读取数据呢？这种方法其实只适合少量的数据，并且它还需要进行序列化操作。不过毕竟Bundle的传输数据是有大小限制的。  </p>
<p>还有Activity和Fragment有数据交互的时候，那么我们的成本其实也是相对有点高。而ViewModel便可以替我们解决此类问题。</p>
<p>所以从UI控制器逻辑中分离出View的展示数据所有权的操作更容易且更高效。</p>
<h3 id="ViewModel的生命周期"><a href="#ViewModel的生命周期" class="headerlink" title="ViewModel的生命周期"></a>ViewModel的生命周期</h3><p>我们先看一张官网的图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210222232031.png" alt="image"></p>
<p>上图说明了Activity经历屏幕旋转而后结束时所处的各种生命周期状态。并且在Activity生命周期旁边显示了对应的ViewModel的生命周期。此图只展示了Activity相关的生命周期，而在Fragment上其实一样。</p>
<p>通常来说，我们获取一个ViewModel是在Activity的onCreate()中去获取的，但onCreate()方法可能被调用多次，比如屏幕旋转，所以ViewModel的存在时间其实是第一次获取实例到当前页面完全销毁。</p>
<h3 id="ViewModel的使用"><a href="#ViewModel的使用" class="headerlink" title="ViewModel的使用"></a>ViewModel的使用</h3><p>那么现在我们准备用ViewModel写一个demo。既然前面说了ViewModel存在的时间是第一次创建到页面完全销毁。那么我们就以屏幕旋转的场景为例。</p>
<h4 id="在Activity中使用"><a href="#在Activity中使用" class="headerlink" title="在Activity中使用"></a>在Activity中使用</h4><p>既然我们需要验证ViewModel是否真的可以在屏幕旋转的时候存储数据，那么我们就以计时器为例，先不使用ViewModel，看看结果如何，接下来我们上代码，首先写一个简单的计时器的Demo：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:2021/2/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:Silence</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeCounter</span> : <span class="type">LifecycleObserver &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> canCount = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        canCount = <span class="literal">true</span></span><br><span class="line">        Thread &#123;</span><br><span class="line">            <span class="keyword">while</span> (canCount) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;start: <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        canCount = <span class="literal">false</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;stop: &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;TimeCounter&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在页面OnResume的时候开始计时，在页面Stop的时候停止计时。然后我们在activity中绑定下这个观察者，我们运行下，验证下效果：  </p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210223111216.png"></p>
<p>上图可见，当我们在屏幕旋转的时候，因为页面的生命周期重新执行了，导致了计时器的数据也被重新初始化了。那么我们怎么用ViewModel解决这个问题呢？首先我们先写一个ViewModel。代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span></span>(<span class="keyword">var</span> count: <span class="built_in">Int</span> = <span class="number">0</span>) : ViewModel()</span><br></pre></td></tr></table></figure>
<p>然后我们在Activity中把当前的ViewModel定义一下，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> lazy &#123; ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(MyViewModel::<span class="keyword">class</span>.java) &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们给TimeCounter新增一个入参，在添加观察者时把当前的ViewModel传进去即可。代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lifecycle.addObserver(TimeCounter(viewModel))</span><br></pre></td></tr></table></figure>
<p>把原先的count修改为viewModel.count即可。那么现在我们在看一下效果： </p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210223113827.png"></p>
<p>哎，可以了。接下来我们需要做的是，在不同场景我们可能需要不同的入参。那如何向ViewModel内部传参呢。别急，ViewModel向我们提供了一个Factory。我们可以通过这个工厂类来解决上述问题。直接上代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModelFactory</span></span>(<span class="keyword">var</span> count: <span class="built_in">Int</span>) : ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel?&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> MyViewModel(count) <span class="keyword">as</span> T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然定义了这个工厂类，那我们怎么使用呢？不慌，ViewModelProvider也提供了Factory相关参数，只需要把定义修改成如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> lazy &#123; ViewModelProvider(<span class="keyword">this</span>, MyViewModelFactory(<span class="number">10</span>)).<span class="keyword">get</span>(MyViewModel::<span class="keyword">class</span>.java) &#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以解决了初始值的问题了。我们先来看一下效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210223134909.png"></p>
<p>哎，解决了。不过，等等，我直接new一个ViewModel把初始值传进去不就行了吗？为什么还要写一个工厂类，搞这么麻烦干嘛。但是如果通过new ViewModel的方法进行传值的话，它就与Activity的生命周期绑定了，所以，切记，不要使用新建传值的方法去定义初始值。</p>
<h4 id="在Fragment中使用"><a href="#在Fragment中使用" class="headerlink" title="在Fragment中使用"></a>在Fragment中使用</h4><p>在日常开发中，Activity和Fragment通信是一个很常见的问题，需要通过定义相关接口去处理。此外，这两个Fragment都必须处理另一个Fragment尚未创建或不可见的情况。那么我们通过共享Activity的ViewModel来解决上述问题。那么接下来，我们依旧直接上代码，我们只需要在Fragment中这样定义ViewModel就可以了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel <span class="keyword">by</span> lazy &#123; activity?.let &#123; ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(MyViewModel::<span class="keyword">class</span>.java) &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们定义的时候需要传入的是Activity的上下文，而不是Fragment的。<br>此方法具有以下优势：</p>
<ul>
<li>Activity不需要执行任何操作，也不需要对此通信有任何了解。</li>
<li>除了ViewModel约定之外，Fragment不需要相互了解。如果其中一个Fragment消失，另一个Fragment将继续照常工作。</li>
<li>每个Fragment都有自己的生命周期，而不受另一个Fragment的生命周期的影响。如果一个Fragment 替换另一个Fragment，界面将继续工作而没有任何问题。</li>
</ul>
<h3 id="ViwModel实现原理"><a href="#ViwModel实现原理" class="headerlink" title="ViwModel实现原理"></a>ViwModel实现原理</h3><p>既然需要看ViewModel的原理，我们回过头去看下ViewModel生命周期的那张图，可以看出Activity完全销毁后才调用了ViewModel的onCleared方法。那我们使用反推法，看看ViewModel的onCleared方法是何时调用的，先上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; mBagOfTags = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mCleared = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCleared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCleared = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBagOfTags != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mBagOfTags) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object value : mBagOfTags.values()) &#123;</span><br><span class="line">                    closeWithRuntimeException(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onCleared();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在ViewModel的clear方法中调用了onCleared方法，那么我们看看clear方法是在哪里调用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是在ViewModelStore的clear方法里面调用的，那么继续向上追踪，可以发现在ComponentActivity中调用了，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getLifecycle().addObserver(<span class="keyword">new</span> LifecycleEventObserver() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!isChangingConfigurations()) &#123;</span><br><span class="line">                       getViewModelStore().clear();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到当activity调用了OnDestory并且isChangingConfigurations不成立的时候，会去调用ViewModelStore的clear方法。那我们就知道了为什么单单调用了onDestory，ViewModel的实例还存在的原因。那么我们看下isChangingConfigurations这个方法是用来干嘛的。</p>
<p>由源码可知，如果在onStop()中发现isChangingConfigurations()的返回值为false，则说明该Activity被暂停了，暂时不需要使用该资源了，则可以释放引用的资源；如果isChangingConfigurations()返回值为true，则说明该Activity正在被销毁然后重新创建一个新的，这种情况下引用的资源还需要马上用到(在新创建的Activity中)，这样可以先不释放该资源，当新的Activity创建好后，则可以立即使用该资源。</p>
<p>我们使用反推法证实了在Activity完全结束后ViewModel的销毁才会执行。那么ViewModel的创建呢？话不多说，我们直接看get方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    String canonicalName = modelClass.getCanonicalName();</span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Local and anonymous classes can not be ViewModels&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">&quot;:&quot;</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel = mFactory.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看出它先从ViewModelStore获取ViewModel实例。如果获取到了就直接返回。如果未获取到就直接通过工厂类创建一个，然后放入mViewModelStore中去。所以我们知道了，即使Activity重新创建了，因为ViewModel没有销毁，所以之前存储在ViewModel的数据源还在。这就合理的解释了，为什么ViewModel可以解决屏幕旋转后页面数据存储的问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要介绍了ViewModel的使用以及原理，小结下，ViewModel在Activity首次onCreate的时候创建，并存入ViewModelStore，后续就算多次调用了onCreate方法，它永远都是读取上次在ViewModelStore存入的ViewModel实例。在Activity完全销毁后，调用ViewModel的onCleared方法将其清除。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh_cn#sharing">官网</a></p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
  </entry>
  <entry>
    <title>Class初始化过程</title>
    <url>/jvm/classinit/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个 class 文件被加载到内存中需要经过三大步：装载、链接、初始化。其中链接又可以细分为：验证、准备、解析三小步。如图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2nSAXgX1AAAk3WIjy2w291.png" alt="image"></p>
<h3 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h3><p>装载是指JVM找到class文件生成字节流，然后根据字节流创建java.lang.Class对象的过程。  </p>
<p><strong>过程如下</strong>：</p>
<ul>
<li><p>ClassLoader通过一个类的包名+类型来查找.class文件。并生成二进制字节流。  </p>
</li>
<li><p>把class文件解析为JVM内部的数据结构，并存储在方法区。（这种解析类似json文件解析成运行时的bean类）</p>
</li>
<li><p>在内存中创建一个java.lang.Class类型的对象。</p>
</li>
</ul>
<h4 id="加载时机"><a href="#加载时机" class="headerlink" title="加载时机"></a>加载时机</h4><ul>
<li><p>隐式装载：在程序运行过程中，当碰到通过new等方式生成对象时，系统会隐式调用ClassLoader去装载对应的class到内存中。</p>
</li>
<li><p>显示装载：在编写源代码时，主动调用Class.forName()等方法也会进行class装载操作，这种方式通常称为显示装载。</p>
</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接过程分为 3 步：验证、准备、解析。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是链接的第一步，目的是为了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危及虚拟机本身的安全。主要包含以下几个方面的检验。</p>
<ul>
<li><p>文件格式检验：检验字节流是否符合class文件格式的规范，并且能被当前版本的虚拟机处理。</p>
</li>
<li><p>元数据检验：对字节码描述的信息进行语义分析，以保证其描述的内容符合 Java 语言规范的要求。</p>
</li>
<li><p>字节码检验：通过数据流和控制流分析，确定程序语义是合法、符合逻辑的。</p>
</li>
<li><p>符号引用检验：符号引用检验可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</p>
</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备是链接的第 2 步，这一阶段的主要目的是为类中的静态变量分配内存，并为其设置“0值”。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析是链接的最后一步，这一阶段的任务是把常量池中的符号引用转换为直接引用，也就是具体的内存地址。在这一阶段，JVM会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这是 class 加载的最后一步，这一阶段是执行类构造器<clinit>方法的过程，并真正初始化类变量。比如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>在准备阶段 value 被分配内存并设置为 0，在初始化阶段 value 就会被设置为 100。</p>
<h4 id="初始化的时机"><a href="#初始化的时机" class="headerlink" title="初始化的时机"></a>初始化的时机</h4><p>对于装载阶段，JVM 并没有规范何时具体执行。但是对于初始化，JVM规范中严格规定了 class 初始化的时机，主要有以下几种情况会触发 class 的初始化：</p>
<ul>
<li><p>虚拟机启动时，初始化包含 main 方法的主类；</p>
</li>
<li><p>遇到 new 指令创建对象实例时，如果目标对象类没有被初始化则进行初始化操作；</p>
</li>
<li><p>当遇到访问静态方法或者静态字段的指令时，如果目标对象类没有被初始化则进行初始化操作；</p>
</li>
<li><p>子类的初始化过程如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；</p>
</li>
<li><p>使用反射 API 进行反射调用时，如果类没有进行过初始化则需要先触发其初始化；</p>
</li>
<li><p>第一次调用 java.lang.invoke.MethodHandle 实例时，需要初始化 MethodHandle 指向方法所在的类。</p>
</li>
</ul>
<h4 id="初始化创建的顺序"><a href="#初始化创建的顺序" class="headerlink" title="初始化创建的顺序"></a>初始化创建的顺序</h4><p>静态变量/静态代码块 -&gt; 普通代码块 -&gt; 构造函数</p>
<ul>
<li><p>父类静态变量和静态代码块；</p>
</li>
<li><p>子类静态变量和静态代码块；</p>
</li>
<li><p>父类普通成员变量和普通代码块；</p>
</li>
<li><p>父类的构造函数；</p>
</li>
<li><p>子类普通成员变量和普通代码块；</p>
</li>
<li><p>子类的构造函数。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要介绍了.class文件被加载到内存中所经过的详细过程，主要分3大步：装载、链接、初始化。其中链接中又包含验证、准备、解析3小步。</p>
<ul>
<li><p>装载：指查找字节流，并根据此字节流创建类的过程。装载过程成功的标志就是在方法区中成功创建了类所对应的Class对象。</p>
</li>
<li><p>链接：指验证创建的类，并将其解析到JVM中使之能够被JVM执行。</p>
</li>
<li><p>初始化：则是将标记为static的字段进行赋值，并且执行static标记的代码语句 。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>拉勾教育 - Android 工程师进阶34讲 </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>GC回收机制</title>
    <url>/jvm/gc/</url>
    <content><![CDATA[<h3 id="为什么需要GC？"><a href="#为什么需要GC？" class="headerlink" title="为什么需要GC？"></a>为什么需要GC？</h3><p>如果不进行垃圾回收，内存耗空是迟早的。因为我们在不断的进行内存分配，而不进行垃圾回收。除非内存足够大，可以让我们随意分配内存。但事实并非如此。</p>
<h3 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h3><p>所谓垃圾就是指内存中已经没用的对象。那么我们如何找到这些没用的对象。JVM中使用一种叫做<strong>可行性分析</strong>的算法来决定对象是否要被回收。</p>
<h3 id="可行性分析"><a href="#可行性分析" class="headerlink" title="可行性分析"></a>可行性分析</h3><p>这个算法的思想是通过一系列称为“GCRoot”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GCRoot没有任何引用链（即GCRoots到对象不可达）时，则证明此对象是不可用的。  </p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/7C/9B/Cgq2xl58leGAIoKxAAEZWYE_v08477.png" alt="image">  </p>
<p>如上图所示，对象A、B、C、D、E与GCRoot之间都存在一条直接或者间接的引用链，这也代表它们与 GC Root之间是可达的，因此它们是不能被GC回收掉的。而对象M和K虽然被对J 引用到，但是并不存在一条引用链连接它们与GCRoot，所以当GC进行垃圾回收时，只要遍历到 J、K、M 这 3 个对象，就会将它们回收。</p>
<blockquote>
<p><strong>注意：上图中圆形图标虽然标记的是对象，但实际上代表的是此对象在内存中的引用。包括 GC Root 也是一组引用而并非对象。</strong>‘</p>
</blockquote>
<h3 id="什么是GCRoot对象？"><a href="#什么是GCRoot对象？" class="headerlink" title="什么是GCRoot对象？"></a>什么是GCRoot对象？</h3><p>1、虚拟机栈（局部变量）引用的对象<br>2、方法区中常量引用的对象<br>3、方法去中静态引用的对象<br>4、本地方法栈中JNI（Native方法）引用的对象  </p>
<h3 id="什么时候GC？"><a href="#什么时候GC？" class="headerlink" title="什么时候GC？"></a>什么时候GC？</h3><p>1、在堆内存分配中，出现可用内存不足导致分配对象内存失败。系统主动GC。<br>2、在应用层，开发人员执行System.gc()主动执行GC操作。</p>
<h3 id="如何进行垃圾回收？"><a href="#如何进行垃圾回收？" class="headerlink" title="如何进行垃圾回收？"></a>如何进行垃圾回收？</h3><p>主要通过如下几种方式进行垃圾回收：<br>1、标记清除算法<br>2、复制算法<br>3、标记压缩算法<br>4、分代回收算法</p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>标记清除是最基础的GC回收机制，字面意思，标记清除算法分为两步。<br><strong>标记</strong>：找到内存中所有与GCRoot相连/间接性连接的对象标记为灰色（存活对象），否则标记为黑色（垃圾对象）。</p>
<p><strong>清除</strong>：将垃圾对象直接清除。</p>
<ul>
<li><strong>优点</strong>：实现简单，不需要将对象进行移动。</li>
<li><strong>缺点</strong>：标记清除后会产生大量不连续的内存碎片，内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将现有内存分为两块，每次只使用其一，当需要GC的时候，在内存中找到正在使用的对象，复制到另一块内存中，然后将当前内存直接清空。交换2个内存的角色。完成GC。</p>
<ul>
<li><strong>优点</strong>：按序分配内存，无需考虑内存碎片。</li>
<li><strong>缺点</strong>：可用内存缩小为原来的一半，会存在频繁的GC操作。</li>
</ul>
<h4 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h4><p>过程和标记清除类似，但不是直接清除，而是将所有对象移动至内存的一端，然后回收那些不可用的对象。</p>
<ul>
<li><strong>优点</strong>：这种回收算法既避免产生了内存的碎片，也不需要分两块内存空间，相对上面两种算是最优解了。</li>
<li><strong>缺点</strong>：所谓压缩，还是需要进行内存移动，一定程度上，降低了效率。</li>
</ul>
<h4 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h4><p>JVM根据内存对象存活周期，把堆内存划分成了新生代，老年代，和持久代。分代回收的中心思想就是：对于新创建的对象会在新生代中分配内存，此区域的对象生命周期一般较短。如果经过多次回收仍然存活下来，则将它们转移到老年代中。</p>
<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>大批量死去的对象，少量的存活对象，一次GC能回收70%—95%的空间，回收效率极高。一般使用复制算法，复制成本低。  </p>
<p>新生代又划分为一个Eden区和两个survivor(存活)区。这三部分按照8:1:1来划分新生代。<br>绝大多数新建的对象都被放在eden区。如图：<br><img src="https://s0.lgstatic.com/i/image3/M01/03/81/Ciqah158kSCACECoAABYMXWFYtY758.png" alt="image"><br>当eden区第一次满的时候回进行内存回收。将eden中的垃圾对象进行清除，将存活对象放至S0。此时S1是空的。如图：<br><img src="https://s0.lgstatic.com/i/image3/M01/7C/97/Cgq2xl58kSGACeimAABTArM3xYk676.png" alt="image"><br>下一次eden区满的时候，将eden区和S0中所有的垃圾对象清除，将存活对象放至S1，此时S0变为空。如图：<br><img src="https://s0.lgstatic.com/i/image3/M01/03/81/Ciqah158kSGAXW6uAABTZbbBBQU172.png" alt="image"><br>如此反复在S0和S1中切换（默认15次），依旧存活的对象放至老年代。</p>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><p>对象存活率高，没有额外空间进行分配，使用标记清除或者标记整理算法。</p>
<p>一个对象在新生代中存在过久没有被清除，此时就会将其移至老年代。老年代的内存空间会比新生代大很多。如果某个对象内存过大，导致无法将其放入新生代时，此对象会直接放入老年代中。</p>
<h5 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h5><p>指内存中永久存在的数据，主要指class以及meta（元数据）信息。</p>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p>判断对象是否存活我们是通过GCRoots的引用可达性来判断的。但是JVM中的引用关系并不止一种，而是有四种，根据引用强度的由强到弱，他们分别是:强引用(StrongReference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)。</p>
<h4 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用 StrongReference"></a>强引用 StrongReference</h4><p>如果一个对象具有强引用，那么垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误，使得程序异常停止。</p>
<p>Object object = new Object(); 即是一个强引用。</p>
<h4 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用 SoftReference"></a>软引用 SoftReference</h4><p>如果一个对象只具有软引用，那么垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收这些对象。软引用对象被回收后，Java虚拟机会把这个软引用加入到与之关联的引用队列中。</p>
<h4 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用 WeakReference"></a>弱引用 WeakReference</h4><p>如果一个对象只具有弱引用，那么垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。与软引用相同，弱引用对象被回收后，Java虚拟机会把这个弱引用加入到与之关联的引用队列中。</p>
<h4 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用 PhantomReference"></a>虚引用 PhantomReference</h4><p>虚引用并不决定对象生命周期，如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。与软引用和弱引用不同的是，虚引用必须关联一个引用队列。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>拉勾教育 - Android 工程师进阶34讲 </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java JMM内存模型</title>
    <url>/jvm/jmm/</url>
    <content><![CDATA[<h3 id="java内存划分"><a href="#java内存划分" class="headerlink" title="java内存划分"></a>java内存划分</h3><p>JMM规定了内存主要划分为主内存和工作内存两种。此处的主内存和工作内存跟JVM内存划分（堆、栈、方法区）是在不同的层次上进行的，如果非要对应起来，主内存对应的是Java堆中的对象实例部分，工作内存对应的是栈中的部分区域，从更底层的来说，主内存对应的是硬件的物理内存，工作内存对应的是寄存器和高速缓存。具体如图所示： </p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/0F/5C/Ciqah16VdfyAKW4PAADwKkKf3ho258.png" alt="image"></p>
<p>正常情况下，java中所有的数据都是放在主存中的，如图所示：</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/88/72/Cgq2xl6VddeAEMpoAAB8hyBTG6s068.png" alt="image"></p>
<p>随着 CPU 技术的发展，CPU的执行速度越来越快，但内存的技术并没有太大的变化,如果JAVA线程每次读取和写入变量都直接操作主内存，对性能影响比较大，所以每条线程拥有各自的工作内存，工作内存中的变量是主内存中的一份拷贝，线程对变量的读取和写入，直接在工作内存中操作，而不能直接去操作主内存中的变量。</p>
<p>因此，为了“压榨”处理性能，达到“高并发”的效果，在CPU中添加了高速缓存（cache）来作为缓冲。</p>
<p><img src="https://s0.lgstatic.com/i/image3/M01/0F/5B/Ciqah16VddeAQQn6AACp-HxFwfo279.png" alt="image"></p>
<p>但是这样就会出现一个问题，当一个线程修改了自己工作内存中变量，对其他线程是不可见的，会导致线程不安全的问题。也就是缓存一致性的问题。</p>
<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>现在市面上的手机通常有两个或者多个CPU，其中一些CPU还有多核。每个CPU在某一时刻都能运行一个线程，这就意味着，如果你的Java程序是多线程的，那么就有可能存在多个线程在同一时刻被不同的CPU执行的情况。</p>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>除了缓存一致性问题，还存在另外一种硬件问题，也比较重要：为了使CPU内部的运算单元能够尽量被充分利用，处理器可能会对输入的字节码指令进行重排序处理，也就是处理器优化。除了CPU之外，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做指令重排。</p>
<p>比如如下代码：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int a</span> = 1;</span><br><span class="line"><span class="attribute">int b</span> = 1;</span><br><span class="line"><span class="attribute">a</span> = a + 1;</span><br></pre></td></tr></table></figure>
<p>经过CPU指令重排后，可能会变成如下代码：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">int a</span> = 1;</span><br><span class="line"><span class="attribute">a</span> = a + 1;</span><br><span class="line"><span class="attribute">int b</span> = 1;</span><br></pre></td></tr></table></figure>
<p>如果我们任由 CPU 优化或者编译器指令重排，那我们编写的Java代码最终执行效果可能会极大的出乎意料。为了解决这个问题，让Java代码在不同硬件、不同操作系统中，输出的结果达到一致，Java 虚拟机规范提出了一套机制——Java 内存模型。</p>
<h3 id="什么是java内存模型"><a href="#什么是java内存模型" class="headerlink" title="什么是java内存模型"></a>什么是java内存模型</h3><p>JMM (Java Memory Model)是Java内存模型,JMM定义了程序中各个共享变量的访问规则,即在虚拟机中将变量存储到内存和从内存读取变量这样的底层细节。解决了CPU多级缓存、CPU 优化、指令重排等导致的内存访问问题，从而保证Java程序（尤其是多线程程序）在各种平台下对内存的访问效果一致。</p>
<h3 id="内存交互操作"><a href="#内存交互操作" class="headerlink" title="内存交互操作"></a>内存交互操作</h3><p>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</p>
<ul>
<li><strong>lock   （锁定）</strong>：作用于主内存的变量，把一个变量标识为线程独占状态</li>
<li><strong>unlock （解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li><strong>read   （读取）</strong>：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li><strong>load   （载入）</strong>：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li>
<li><strong>use    （使用）</strong>：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li>
<li><strong>assign （赋值）</strong>：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li>
<li><strong>store  （存储）</strong>：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</li>
<li><strong>write  （写入）</strong>：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ul>
<p>JMM对这八种指令的使用，制定了如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>
<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li>
<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>
<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>
</ul>
<h3 id="Happens-before-先行发生原则"><a href="#Happens-before-先行发生原则" class="headerlink" title="Happens-before 先行发生原则"></a>Happens-before 先行发生原则</h3><p>先行发生原则用于描述2个操作之间的内存可见性。意思就是当A操作先行发生于B操作，则在发生B操作的时候，操作A产生的影响能被B观察到，“影响”包括修改了内存中的共享变量的值、发送了消息、调用了方法等。  </p>
<p>JMM 中定义了以下几种情况是自动符合 happens-before 规则的：</p>
<ul>
<li><strong>程序次序规则（Program Order Rule）</strong>：在一个线程内，程序的执行规则跟程序的书写规则是一致的，从上往下执行。</li>
<li><strong>锁定规则（Monitor Lock Rule）</strong>：无论是在单线程环境还是多线程环境，一个锁如果处于被锁定状态，那么必须先执行 unlock 操作后才能进行 lock 操作。</li>
<li><strong>volatile变量规则（volatile Variable Rule）</strong>：对同一个volatile的变量，先行发生的写操作，肯定早于后续发生的读操作</li>
<li><strong>线程启动规则（Thread Start Rule）</strong>：Thread 对象的 start() 方法先行发生于此线程的每一个动作。假定线程 A 在执行过程中，通过执行 ThreadB.start() 来启动线程 B，那么线程 A 对共享变量的修改在线程 B 开始执行后确保对线程 B 可见。</li>
<li><strong>线程中止规则（Thread Termination Rule）</strong>：Thread对象的中止检测（如：Thread.join()，Thread.isAlive()等）操作，必行晚于线程中所有操作</li>
<li><strong>线程中断规则（Thread Interruption Rule）</strong>：对线程的interruption（）调用，先于被调用的线程检测中断事件(Thread.interrupted())的发生</li>
<li><strong>对象中止规则（Finalizer Rule）</strong>：一个对象的初始化方法先于一个方法执行Finalizer()方法</li>
<li><strong>传递性（Transitivity）</strong>：如果操作A先于操作B、操作B先于操作C,则操作A先于操作C</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>Java 内存模型的来源：主要是因为CPU缓存和指令重排等优化会造成多线程程序结果不可控。</p>
</li>
<li><p>Java 内存模型是什么：本质上它就是一套规范，在这套规范中有一条最重要的 happens-before 原则。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>拉勾教育 - Android 工程师进阶34讲 </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>程序运行时，内存是如何分配的？</title>
    <url>/jvm/memory_allocation/</url>
    <content><![CDATA[<h3 id="Jvm中的内存划分"><a href="#Jvm中的内存划分" class="headerlink" title="Jvm中的内存划分"></a>Jvm中的内存划分</h3><p>JVM 中的内存可以划分为若干个不同的数据区域，主要分为：<strong>程序计数器、虚拟机栈、本地方法栈、堆、方法区</strong>。  </p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>java本身是多线程的，当某一线程被CPU挂起后，需要记录程序执行的位置，这个时候就需要用到程序计数器。方便CPU重新执行此线程时，知道从哪行指令开始执行。这就是程序计数器的作用。</p>
<p>注意：<br>1、在JVM中，对于程序计数器没有规定任何OutOfMemoryError的情况。<br>2、线程私有的，每条线程内部都有一个私有程序计数器。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。<br>3、当一个线程正在执行一个Java方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Native方法，这个计数器值则为空（Undefined）。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈是线程私有的，与线程的生命周期同步。在java的虚拟机规范中，定义了两种异常：<br>1、StackOverflowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出。<br>2、OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出。  </p>
<p>JVM是基于栈的解释器执行的，DVM是基于寄存器解释器执行的。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈和上面介绍的虚拟栈基本相同，只不过是针对本地（native）方法。在开发中如果涉及JNI可能接触本地方法栈多一些，在有些虚拟机的实现中已经将两个合二为一了（比如HotSpot）。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 堆（Heap）是 JVM所管理的内存中最大的一块，该区域唯一目的就是存放对象实例，几乎所有对象的实例都在堆里面分配，因此它也是Java垃圾收集器（GC）管理的主要区域，有时候也叫作“GC堆”）。同时它也是所有线程共享的内存区域，因此被分配在此区域的对象如果被多个线程访问的话，需要考虑线程安全问题。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）也是JVM规范里规定的一块运行时数据区。方法区主要是存储已经被 JVM 加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据。该区域同堆一样，也是被各个线程共享的内存区域。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JVM 的运行时内存结构中一共有两个“栈”和一个“堆”，分别是：Java虚拟机栈和本地方法栈，以及“GC堆”和方法区。除此之外还有一个程序计数器，但是我们开发者几乎不会用到这一部分。JVM内存中只有堆和方法区是线程共享的数据区域，其它区域都是线程私有的。并且程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>拉勾教育 - Android 工程师进阶34讲 </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>如何在工作中快速成长？致工程师的十条建议。</title>
    <url>/soft_skills/business_tips/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>本文是我最近刚看完的一本《阿里工程师的自我修养》书中的部分内容，我做了简单的梳理。侵删。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20191009113257423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaWxlbmNlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="思考脑与反射脑"><a href="#思考脑与反射脑" class="headerlink" title="思考脑与反射脑"></a>思考脑与反射脑</h3><p>简单介绍下什么是思考脑和反射脑。思考脑管理性，反射脑管直觉，存储脑管记忆，直觉依赖习惯，用直觉做出反应，快速，但未必正确;思考脑管理性，理性依赖逻辑，缓慢，但更加正确。</p>
<p>有科学家通过研究，发现一个人一天的行为中，5%是非习惯性的，用思考脑的逻辑驱动，95%是习惯性的，用反射脑的直觉驱动，决定我们一生的，永远是95%的反射脑(习惯)，而不是5%的思考脑(逻辑)。回想自己的一天，大部分的判断和观点是不是都是靠直觉，靠习惯的，什么情况下才会用思考脑?是不是一个人的时候用思考脑比较多，而在多人对话场景中要快只能靠直觉和反射，而给别人好与不好的印象往往是在对话场景中建立起来的，可想而知，反射出来的观点或行为对我们而言是多么重要。</p>
<p><img src="https://img-blog.csdnimg.cn/20191009113421668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaWxlbmNlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="习以为常"><a href="#习以为常" class="headerlink" title="习以为常"></a>习以为常</h3><p>把95%中的低质量习惯反射，训练成逻辑后的高质量习惯反射需要有很多的时间保障。但对于处理互联网时代的我们，我们对电子设备的依赖程度已经达到了形影不离的地步。甚至上厕所的那几分钟，也是形影不离。对习惯的认知，关键在于换种说法:“把改变玩手机的习惯，用另外一句话来替代，把学习变成习以为常的生活方式”。<br>谁都知道替换可以改变，但为什么这么难?其实关键在于这个意识点能不能变成触发性响应，也就是说当某个触发条件产生的时候，改变的意识能不能弹出来警告自己。</p>
<p>先对习惯的产生机制要有所了解，习惯并非凭空产生，他有前因后果，前因是前一件事情结束(触发条件)，后果是前一件事情结束后的行为带来的一些额外奖励。比如晚上下班回家洗完澡这件事情结束后，肯定会开始下一件我们最习惯的事情，比如盯手机看剧或者刷八卦，当这件最习惯的事情结束后，大脑会产生精神上的及时享受，内容很丰富、很精彩。短期看是享受，长期看是灾难，因为对未来帮助意义不大，但是却消耗了我们大把时间。而且看剧或者刷八卦带来的信息积累只能称的上是饭后谈资，或者有些根本没机会谈。</p>
<p>了解习惯产生的机制后，改变习惯就变得很简单，每次在触发条件发生时，弹出一道选择题，选择做无效事情，还是学习？多次以这种方式不断强化自己做对选择题。久而久之，正确的行为被训练得多了，就成为顺其自然的习惯了。所以改变习惯，就是在触发条件发生时，让自己做对选择题，打破旧有习惯回路，建立新的习惯回路。相信这句话“精英之所以精英，是不间断的正向行为习惯的驱使”。</p>
<p><img src="https://img-blog.csdnimg.cn/20191009113432838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaWxlbmNlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="时间管理：三八理论"><a href="#时间管理：三八理论" class="headerlink" title="时间管理：三八理论"></a>时间管理：三八理论</h3><p>时间管理三八理论:每个人每天有公平的24个小时，第1个八小时用于睡觉、第2个八小时用于工作、第3个八小时用于自由支配，但人与人的差距主要是由第3个八小时决定的，第3个8小时用于消费、交易还是投资有着非常大的人生差别。以下班空闲时间为例解释消费、交易、投资从而理解人生差异的不同:</p>
<p>下班空闲时间，用于消费，比如刷新闻，刷抖音，刷朋友圈，产生及时享受，没产生成长，钱还是那些钱，职位还是原来职位;</p>
<p>下班空闲时间，用于交易，接个外快，赚点辛苦钱，产生金钱，没产生成长，钱没多多少，职位却还是原来职位;</p>
<p>下班空闲时间，用于投资，以终为始，相信“慢慢来，成长最快”的认知，持续不断投入多维领域的学习，沉淀能力，获得成长，从成长中获得金钱，名誉的升级;</p>
<p>看完时间的消费、交易、投资的解释，在看《习以为常》中做选择题的重要性，做对选择题其实就是投资，投资自己的成长，投资自己的学习，人生的不同不就是因为投资自己而变得不一样吗？但是投资需要时间，时间怎么来?<br>“找到不被打扰的时间”。只有找到了不被打扰的时间用于投资自己的成长才能发生复利效应。如果想从工作中省点时间，想从周末挤点时间用于学习，这叫成长的断崖，我相信不能持续，学习必须是每日的必修课，必须是日拱一卒，持之以恒，有不断的输入，也有不断的输出，持续地沉淀，在关键时刻输出解决问题能力，从而获得能力认可。</p>
<p><img src="https://img-blog.csdnimg.cn/20191009113454188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaWxlbmNlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="注意力"><a href="#注意力" class="headerlink" title="注意力"></a>注意力</h3><p>先来解个疑惑:“为什么看电影注意力特别好，做正事注意力集中不了”。<br>首先我们要接受这个现实，医学上把这叫作注意力缺失症，基本所有人都有这种毛病，因为做正事比较枯燥、困难，让人不舒服，集中不了注意力，逃避很正常!<br>其次找到改善方法，通常可以这么做，给自己准备一个笔记本，边读边思考，顺带把重要的观点记录下来，开始会觉得很困难，但是慢慢坚持下来你会发现，思考会越来越深入，注意力集中时间越来越长。<br>注意力和时间管理的认知一旦结合，我们可以兴奋地这么说:“在不被打扰的时间里，用好注意力投资在自己成长上，我们的人生会不一样，在未来会遇到更好的自己”。</p>
<h3 id="执行力"><a href="#执行力" class="headerlink" title="执行力"></a>执行力</h3><p><img src="https://img-blog.csdnimg.cn/2019100911350491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaWxlbmNlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>提升执行力，首先让自己成为投资者，投资自己的成长，投资在正确的事情上，此时去认知执行力才有意义，我对执行力的认知:“想明白，然后一步一步做下去”，如果想不明白，根本谈不上执行力。同时提升执行力的时候，还需要自律，通过自律让执行力得到持续，要相信持续投资自己的成长，可以实现“慢慢来，成长最快”的复利效果。</p>
<h3 id="贵人"><a href="#贵人" class="headerlink" title="贵人"></a>贵人</h3><p>很多时候我们会觉得身边缺少贵人，或者有贵人但离自己太远。产生这种认知离不开4个方面:</p>
<ul>
<li><p>一是，自己不自信，不相信自己能够影响他人，导致缺乏主动沟通，长期沟通，沟通的延续性和习惯没有建立。</p>
</li>
<li><p>二是，自己心态问题，自己的心态若是不够积极正向，没有贵人敢进入你的思维空间，因为价值观不匹配，很难形成认知共识。</p>
</li>
<li><p>三是，职场原因，很多时候可能你的老板就是你的贵人，但是因为职场，因为上下级，碍于面子，碍于工作，不敢多交流，多请教。</p>
</li>
<li><p>四是，贵人来了又走了，有贵人帮你改变，帮你进步，但是自己不努力，抱着过去做事的心态和方法在职场上浪迹天涯，进步不明显，否定了他作为贵人的价值和意义。</p>
</li>
</ul>
<p>如果恰好有这么一位贵人，应该懂得珍惜，珍惜的主要方式是用成长回报他，因为你的成长在未来可以帮助他。同时在平时需要建立有效沟通，首先让贵人真正地了解你，在确定贵人能够帮助你，影响你时，你应该大胆去承担一些有挑战的事情，哪怕遇到委屈，遇到压力，遇到失败，要相信此时的你才是真实的你，你的天花板，你的瓶颈就在于此，借助贵人助你提升能力，下次同样的事情来临时，自己就能够得心应手，这种能力的锻炼机会非常少，和阿里经常说的借事修人非常匹配，事情失败了没关系，但人要成，人的能力要提升。<br><img src="https://img-blog.csdnimg.cn/20191009113514341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaWxlbmNlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h3><p>会多不一定是坏事，反而可能成为你训练思考，训练总结归纳，训练逻辑表达的地方。<br>而且用什么样的身份参与会议，或者在过程中角色如何切换，也是非常重要。我一般用3种角色参加:</p>
<p>作为参与者，认真聆听，快速提炼自己想表达的逻辑，然后参与讨论。</p>
<p>作为聆听者，仔细聆听，认真输入，在脑中组织思路，组织逻辑。</p>
<p>作为中断者，发现有些会议真的没有继续的必要了，出于好意，提示会议的重心或者结束会议。<br><img src="https://img-blog.csdnimg.cn/20191009113530117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaWxlbmNlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="跳出舒适区"><a href="#跳出舒适区" class="headerlink" title="跳出舒适区"></a>跳出舒适区</h3><p>心理学家把我们可能面对的学习内容分成了三个区，分别是舒适区、学习区和恐慌区。舒适区太容易，待太久了，总想跳出去看看。恐慌区太难，太难带来恐惧，就像梁宁在产品思维中讲同理心时，恐惧会产生束缚也会产生动力，就看安全边界有没有被侵犯，如果无法战胜挑战，恐惧就产生了束缚，退回到舒适区。</p>
<p>所以跳出舒适区，不是说跳到恐慌区，而是跳到两者之间的学习区，在学习区中达到困难和能力的平衡状态，引用米哈里·契克森米哈赖在《心流:最优体验心里学》这本书提到的:要想在工作中达到心流状态，这项工作的挑战和你的技能必须形成平衡，如果工作的挑战大大低于你的技能，你会觉得工作很无聊。如果工作的挑战大大超出你的技能，你会感到焦虑。</p>
<p><img src="https://img-blog.csdnimg.cn/20191009113539437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaWxlbmNlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h3><p>职业规划不是某个岗位，某个角色，而是工作能力的提升。针对自己岗位需要的能力，职场需要的能力，然后用专家思维，多维视角重点突破3-4项能力，抱着120%的努力拿到结果，甚至是超出期望的结果，事情成了，能力也就被认可了，所谓的角色，岗位只是顺其自然的结果。<br><img src="https://img-blog.csdnimg.cn/20191009113546898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaWxlbmNlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="时间换空间"><a href="#时间换空间" class="headerlink" title="时间换空间"></a>时间换空间</h3><p>所谓时间换空间，就是让我们无法看清未来是什么样子的时候，把注意力聚焦在当下，做成长该做的事。</p>
<p><img src="https://img-blog.csdnimg.cn/20191009113555901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zaWxlbmNlLmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所谓直觉反射，就是通过大量的逻辑反复训练，提升自己的直觉准确性，从狭窄的5%进入广阔的95%;<br>所谓以习为常，就是在触发条件发生进入下一个行为前，做对选择题;<br>所谓时间管理，就是找到不被打扰的时间用于投资自己;<br>所谓注意力，就是专注在目标事务上，直到产生期望结果;<br>所谓执行力，就是让自己先想明白，然后一步一步走下去;<br>所谓贵人，就是能够持续陪你一起输出高质量内容的人;<br>所谓会议，就是模拟机器学习思路，通过参与讨论获得正反馈来验证自己的观点;<br>所谓跳出舒适区，就是先跳出，然后进入学习区，平衡挑战和能力达到心流的体验;<br>所谓职业规划，就是提升工作需要的能力;<br>所谓时间换空间，就是慢慢来，持之以恒，成长最快。</p>
<p>更多文章请关注我的公众号：码农职场<br><img src="https://img-blog.csdnimg.cn/20191009113626957.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>软技能</category>
      </categories>
  </entry>
  <entry>
    <title>Activity的启动模式</title>
    <url>/android/activity/launchmode/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>上篇我稍微介绍了关于activity的生命周期的知识点，今天我们来谈一下activity的启动模式，这也是一个面试常客。下面容我慢慢道来。</p>
<h3 id="什么情况下会用到启动模式？"><a href="#什么情况下会用到启动模式？" class="headerlink" title="什么情况下会用到启动模式？"></a>什么情况下会用到启动模式？</h3><p>举个简单的例子，来推送通知之后，我们点击推送跳转页面，如果我们一次来了10个推送，那么我们会先后打开10个页面。但是这10个页面是同一个。这种情况下，我们就需要通过启动模式去解决。</p>
<h3 id="Activity的LaunchMode"><a href="#Activity的LaunchMode" class="headerlink" title="Activity的LaunchMode"></a>Activity的LaunchMode</h3><p>关于activity的启动模式，目前总共有四种：standard、singleTop、singleTask和singleInstance，下面我们来简单介绍下，四个启动模式的具体含义是什么：</p>
<ul>
<li>standard：标准模式。这是Android模式的启动模式，所以对这个词陌生也算正常。每次启动一个activity都会创建该实例，不管当前activity是否存在。也就是说可以有多个相同的activity在栈中重叠。也就是上述例子的情况下。</li>
<li>singleTop：栈顶复用模式。在这种模式，如果当前activity已经位于栈顶，此时，当前activity将不再重新创建。同时它的onNewIntent方法会被调用。此时，当前activity的生命周期不会重置。如果当前activity已经存在，但是不位于栈顶，此时会重新创建。假设目前栈内是ABCD，我将D设为singleTop属性，再次启动D的时候是ABCD而不是ABCDD。</li>
<li>singleTask：栈内复用模式。在这种模式，如果当前activity已经位于栈内，此时，当前activity将不再重新创建。同时它的onNewIntent方法也会被调用。和singleTop一样。但是和singleTop的区别是重新启动时，它会移除在当前页面上面的所有activity。因为singleTask有clearTop效果。假设目前栈内是ABCD，将B设为singleTask属性，再次启动B的时候是AB而不是ABCDB。</li>
<li>singleInstance：单实例模式。这个模式除了单独给当前activity开一个栈，它具备了所有singleTask的属性。具体什么地方用到。不明。。。</li>
</ul>
<h3 id="Activity的flags"><a href="#Activity的flags" class="headerlink" title="Activity的flags"></a>Activity的flags</h3><ul>
<li><p>FLAG_ACTIVITY_CLEAR_TOP：例如现在的栈情况为：A B C D 。D此时通过intent跳转到B，如果这个intent添加FLAG_ACTIVITY_CLEAR_TOP 标记，则栈情况变为：A B。如果没有添加这个标记，则栈情况将会变成：A B C D B。也就是说，如果添加了FLAG_ACTIVITY_CLEAR_TOP 标记，并且目标Activity在栈中已经存在，则将会把位于该目标activity之上的activity从栈中弹出销毁。这跟上面把B的Launch mode设置成singleTask类似。</p>
</li>
<li><p>FLAG_ACTIVITY_NEW_TASK：例如现在栈1的情况是：A B C。C通过intent跳转到D，并且这个intent添加了FLAG_ACTIVITY_NEW_TASK 标记，如果D这个Activity在Manifest.xml中的声明中添加了Task affinity，并且和栈1的affinity不同，系统首先会查找有没有和D的Task affinity相同的task栈存在，如果有存在，将D压入那个栈，如果不存在则会新建一个D的affinity的栈将其压入。如果D的Task affinity默认没有设置，或者和栈1的affinity相同，则会把其压入栈1，变成：A B C D，这样就和不加FLAG_ACTIVITY_NEW_TASK 标记效果是一样的了。      </p>
<p>注意如果试图从非activity的非正常途径启动一个activity，比如从一个service中启动一个activity，则intent比如要添加FLAG_ACTIVITY_NEW_TASK 标记。</p>
</li>
<li><p>FLAG_ACTIVITY_NO_HISTORY：例如现在栈情况为：A B C。C通过intent跳转到D，这个intent添加FLAG_ACTIVITY_NO_HISTORY标志，则此时界面显示D的内容，但是它并不会压入栈中。如果按返回键，返回到C，栈的情况还是：A B C。如果此时D中又跳转到E，栈的情况变为：A B C E，此时按返回键会回到C，因为D根本就没有被压入栈中。</p>
</li>
<li><p>FLAG_ACTIVITY_SINGLE_TOP：和上面Activity的 Launch mode的singleTop类似。如果某个intent添加了这个标志，并且这个intent的目标activity就是栈顶的activity，那么将不会新建一个实例压入栈中。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>Activity生命周期详解</title>
    <url>/android/activity/lifecycle/</url>
    <content><![CDATA[<h3 id="Activity是什么？"><a href="#Activity是什么？" class="headerlink" title="Activity是什么？"></a>Activity是什么？</h3><p>Activity是用户和应用程序交互的界面，用户可以在Activity上进行点击、滚动、触摸等操作。一般来说，一个应用是由多个Activity组成，首次进入的Activity称为主Activity。至于如何判断一个Activity是不是主Activity。本篇文章我们先不讨论。后面会讲到。</p>
<h3 id="Activity的活动状态"><a href="#Activity的活动状态" class="headerlink" title="Activity的活动状态"></a>Activity的活动状态</h3><p>当我查阅关于Activity的官方文档的时候，我发现，官方文档中谈到Activity有三种状态，运行中、暂停、停止。我觉得少了一个销毁。所以这边我简单介绍一下Activity的四种活动状态。</p>
<ul>
<li><p>运行中(running)  </p>
<p>此acitvity位于前台，并且用户可以在activity中执行触摸、点击、滚动等操作。</p>
</li>
<li><p>暂停(paused)</p>
<p>activity可见，但并不可以操作，比如，当一个弹窗弹出来的时候。</p>
</li>
<li><p>停止(stopped)</p>
<p>activity不可见，一般来说当用户按了home键之后。如果系统内存不够的时候，并且其他应用需要内存时，系统会回收已经停止的activity。</p>
</li>
<li><p>销毁(destroy)</p>
<p>activity不可见，一般处于这种状态的activity会被系统回收掉。</p>
<p>​</p>
</li>
</ul>
<h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><p>首先我们先看下图解是怎么描述activity的生命周期的。</p>
<p><img src="https://developer.android.google.cn/images/activity_lifecycle.png"></p>
<p>在正常情况下，Acitivity的生命周期会先后经历如下的生命周期：</p>
<p>1）onCreate：表示Activity正在被创建，一般来说，我们会在这个方法中设置布局以及一些数据的初始化。</p>
<p>2）onStart：表示Activity正在被启动，这个Activity已经可见，但并不是前台，这种情况下，我们无法操作这个Activity。</p>
<p>3）onResume：表示Activity已经可见并且位于前台了，此时，我们可以对当前的Activity进行操作。</p>
<p>4）onPasue：表示Activity暂停了，一般来说，执行到了这一步，后续会调用onStop方法。所以，在这边我们尽可能不要去执行耗时操作，因为这会影响新的Activity的显示。</p>
<p>5）onStop：表示Activity停止了，这边我们可以对一些数据进行回收。同样不能太耗时。</p>
<p>6）onDestroy：表示Activity即将销毁，这是Activity最后一个生命周期，同样，我们可以对一些数据进行回收。</p>
<p>7）onRestart：表示Activity正在被重启，这个方法一般只有在重启Activity的时候才被调用，比如，打开一个新的Activity然后在回退到当前的Activity。此方法便会被调用。</p>
<p>我们可以通过上述介绍以及图片，可以分析出一般Activity会有如下几种情况：</p>
<p>启动一个Activity：onCreate()–&gt;onStart()–&gt;onResume()。</p>
<p>按Home键之后或者重新打开一个Activity：onPause()–&gt; onStop()（注：如果新的Activity是透明主题，当前Acitvity不会走onStop方法，例如dialog弹出的时候，当然，dialog关闭当前Activity会走onResume()）。</p>
<p>重新启动一个Activity：onRestart()–&gt;onStart()–&gt;onResume()。</p>
<p>销毁一个Activity：onPasue()–&gt;onStop()–&gt;onDestroy()。</p>
<h3 id="异常情况下Activity的生命周期"><a href="#异常情况下Activity的生命周期" class="headerlink" title="异常情况下Activity的生命周期"></a>异常情况下Activity的生命周期</h3><p>首先，我们需要什么情况算异常情况。最好的例子莫过于横竖屏切换，这种情况Activity会被销毁并且重建，一般来说，系统会调用onSaveInstanceState 方法进行数据的存储。然后通过调用onRestoreInstanceState进行数据的恢复。如果我们想知道当前activity是否被重建了。我们可以在onCreate中判断bundle是否为null或者重写onRestoreInstanceState方法。一般推荐使用后者，因为只有在重建的情况下，此方法才会被调用。</p>
<p>如果我们希望当系统配置参数发生改变时，当前Activity不会被重建应该怎么做呢？自然是有的，我们可以在Mainfest文件中为Activity配置configChanges属性。比如，我们想当屏幕切换的时候当前Activity不被重启。我们可以这样：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">android:</span>configChanges=<span class="string">&quot;orientation|screenSize&quot;</span></span><br></pre></td></tr></table></figure>
<p>configChanges的选项有很多，这里我们常用的只有locale、orentation、keyboardHidden以及screenSize。（需要注意的是：screenSize这个属性比较特殊，minSdkVersion 和targetSdkVersion 低于13时，此选项不会导致activity重启。否则会导致activity重启。）</p>
<p>此时，我们可以通过重写此方法来进行一些特殊处理：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> void onConfigurationChanged(Configuration <span class="keyword">new</span><span class="type">Config</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.onConfigurationChanged(<span class="keyword">new</span><span class="type">Config</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h3><p>《Android开发艺术探索》</p>
<p>Android官方API文档</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>View的事件机制分析</title>
    <url>/android/view/touchevent/</url>
    <content><![CDATA[<h3 id="为什么要去分析view的事件"><a href="#为什么要去分析view的事件" class="headerlink" title="为什么要去分析view的事件"></a>为什么要去分析view的事件</h3><p>关于view的事件，百度google一搜。一批又一批。但是能让人理解的少之又少。换句话说，不是那些作者不懂。只是说，他懂了，但他讲解后不一定能让别人看得懂。我记得有人问我当初是怎么接触自定义view这东西的。因为他们觉得自定义view这个东西很难。我就回了如下几句话：自定义view你把paint和canvas。弄懂了基本也就差不多了。我这边说的是差不多，不是完全，你们别曲解哈= =当然前提是数学和物理要好= =。对于View来说，我认为，paint和canvas都不是重点，如何分析他的事件处理才是重点。下面我们一步步的来了解。</p>
<h3 id="View的结构"><a href="#View的结构" class="headerlink" title="View的结构"></a>View的结构</h3><p>想要了解view的事件，他的结构我们是需要知道的，我们先放一张view的结构图。然后根据图来一步步分析：<br><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20170803153321208.png" alt="这里写图片描述"><br>最顶层的PhoneWindow是什么呢？通过字面意思，我们知道他是手机窗口。我们需要知道window到底是什么才能分析phonewindow的作用。</p>
<p>简单来说，Window是一个抽象类，是所有视图的最顶层容器，视图的外观和行为都归他管，不论是背景显示，标题栏还是事件处理都是他管理的范畴，虽然能管的事情看似很多，但是没实权，因为抽象类不能直接使用。</p>
<p>而 PhoneWindow 作为 Window 的唯一实现类，PhoneWindow 的权利可是非常大大，不过对于我们来说用处并不大。</p>
<p>下面我们来说说DecorView：<br>这样，我们做个假设，一个跟布局高度是wrap的控件，我们运行之后可以发现，除了那个控件，留下了大量的空白区域，由于我们的手机屏幕不能透明，所以这些空白区域肯定要显示一些东西，那么应该显示什么呢？当然如果你没有设置全屏。我们还会发现标题栏状态栏那些。而这些就是所谓的DecorView。</p>
<h3 id="事件处理的过程"><a href="#事件处理的过程" class="headerlink" title="事件处理的过程"></a>事件处理的过程</h3><p>我们先看下下面的表格：</p>
<table style="word-break:break-all;">
  <thead>

<pre><code>&lt;tr&gt;
  &lt;th style=&quot;text-align: center&quot;&gt;类型&lt;/th&gt;
  &lt;th style=&quot;text-align: center&quot;&gt;相关方法&lt;/th&gt;
  &lt;th style=&quot;text-align: center&quot;&gt;Activity&lt;/th&gt;
  &lt;th style=&quot;text-align: center&quot;&gt;ViewGroup&lt;/th&gt;
  &lt;th style=&quot;text-align: center&quot;&gt;View&lt;/th&gt;
&lt;/tr&gt;</code></pre>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">事件分发</td>
      <td style="text-align: center">dispatchTouchEvent</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">√</td>
    </tr>
    <tr>
      <td style="text-align: center">事件拦截</td>
      <td style="text-align: center">onInterceptTouchEvent</td>
      <td style="text-align: center">X</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">X</td>
    </tr>
    <tr>
      <td style="text-align: center">事件消费</td>
      <td style="text-align: center">onTouchEvent</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">√</td>
    </tr>
  </tbody>
</table>

<p>从上表可以看到 Activity 和 View 都是没有事件拦截的，这是因为：</p>
<pre><code>1. Activity 作为原始的事件分发者，如果 Activity 拦截了事件会导致整个屏幕都无法响应事件，这肯定不是我们想要的效果。
2. View最为事件传递的最末端，要么消费掉事件，要么不处理进行回传，根本没必要进行事件拦截。</code></pre>
<p>所以我们知道了activity是最上层，而view是最底层，那么结合之前view的结构的那张图，我们可以知道view的传递流程应该是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Activity －&gt; PhoneWindow －&gt; DecorView －&gt; ViewGroup －&gt; ... －&gt; View</span><br></pre></td></tr></table></figure>
<p>而view的处理恰恰相反，那就是这样:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Activity &lt;－ PhoneWindow &lt;－ DecorView &lt;－ ViewGroup &lt;－ ... &lt;－ View</span><br></pre></td></tr></table></figure>
<p>如果上面的你理解了，下面这张图，对你来说也就是小意思了。<br><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210204211418.png" alt="这里写图片描述"></p>
<p>如果你已经完全理解了上面的内容。那么对于view的事件处理。你已经懂了50%了。</p>
<h3 id="事件分发和拦截"><a href="#事件分发和拦截" class="headerlink" title="事件分发和拦截"></a>事件分发和拦截</h3><p>事件分发和拦截的流程其实就是上面那张图。《群英传》中举得例子很恰当。我们现在也对所有的流程对应一个职位:</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Activity:</span>公司大boss</span><br><span class="line">RootView：项目经理</span><br><span class="line">ViewGroup：技术组长</span><br><span class="line">View：码农</span><br></pre></td></tr></table></figure>
<p>前面已经知道了处理流程，我们这边在写一次。<br><strong>分发(dispatch)–&gt;拦截(onIntercept)–&gt;消费(ontouch)</strong></p>
<p> <strong>public boolean dispatchTouchEvent(MotionEvent ev)</strong> </p>
<p>用来进行事件分发。如果事件能够传递到当前view。那么此方法一定会调用，返回结果受当前View的ontouch和下级的dispatchtouchevent影响，表示是否消耗当前事件。</p>
<p>   <strong>public boolean onInterceptTouchEvent(MotionEvent ev)</strong></p>
<p>在上述方法内部调用，用来判断是否拦截事件，如果当前view拦截了事件，那么在同一序列中此方法不会在调用，返回结果表示是否拦截事件。</p>
<p>  <strong>public boolean onTouchEvent(MotionEvent event)</strong> </p>
<p>在dispatch方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，那么当前view再也无法接受事件。</p>
<table style="word-break:break-all;">
  <thead>

<pre><code>&lt;tr&gt;
  &lt;th style=&quot;text-align: center&quot;&gt;类型&lt;/th&gt;
  &lt;th style=&quot;text-align: center&quot;&gt;true&lt;/th&gt;
  &lt;th style=&quot;text-align: center&quot;&gt;false&lt;/th&gt;
  &lt;th style=&quot;text-align: center&quot;&gt;方法&lt;/th&gt;
&lt;/tr&gt;</code></pre>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">事件传递</td>
      <td style="text-align: center">拦截，不继续</td>
      <td style="text-align: center">不拦截，继续</td>
      <td style="text-align: center">onIntercept</td>
    </tr>
    <tr>
      <td style="text-align: center">事件处理</td>
      <td style="text-align: center">处理了，无需审核</td>
      <td style="text-align: center">给上级处理</td>
      <td style="text-align: center">ontouch</td>
    </tr>
  </tbody>
</table>

<p>默认情况下，我们都是返回false。</p>
<h4 id="默认的点击事件"><a href="#默认的点击事件" class="headerlink" title="默认的点击事件"></a>默认的点击事件</h4><p>我们先看下整体的效果图，再来进行点击查看结果：<br><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210204211520.png" alt="这里写图片描述"></p>
<p>当然这是一个framelayout。你们只要知道是一层盖一层就对了= = 。那么现在所有的事件我们直接return  super来看下效果图：<br><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210204211556.png" alt="这里写图片描述"></p>
<p>我们通过上面列举的职位可以分析下情况，具体详情如下：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">MainActivity</span> [老板]: dispatchTouchEvent     经理,我准备发展一下电商业务,下周之前做一个淘宝出来.</span><br><span class="line"><span class="symbol">RootView</span>     [经理]: dispatchTouchEvent     呼叫技术部,老板要做淘宝,下周上线.</span><br><span class="line"><span class="symbol">RootView</span>     [经理]: onInterceptTouchEvent  (老板可能疯了,但又不是我做.)</span><br><span class="line"><span class="symbol">ViewGroupA</span>   [组长]: dispatchTouchEvent     老板要做淘宝,下周上线?</span><br><span class="line"><span class="symbol">ViewGroupA</span>   [组长]: onInterceptTouchEvent  (看着不太靠谱,先问问小王怎么看)</span><br><span class="line"><span class="symbol">View1</span>        [码农]: dispatchTouchEvent     做淘宝???</span><br><span class="line"><span class="symbol">View1</span>        [码农]: onTouchEvent           这个真心做不了啊.</span><br><span class="line"><span class="symbol">ViewGroupA</span>   [组长]: onTouchEvent           小王说做不了.</span><br><span class="line"><span class="symbol">RootView</span>     [经理]: onTouchEvent           报告老板, 技术部说做不了.</span><br><span class="line"><span class="symbol">MainActivity</span> [老板]: onTouchEvent           这么简单都做不了,你们都是干啥的(愤怒).</span><br></pre></td></tr></table></figure>
<p>可以从log日志中看出，和我们上面的流程是一模一样的。我们尝试下对某个view的TouchEvent 直接拦截了（return true），然后在看看效果图：<br><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210204211648.png" alt="这里写图片描述"><br>流程应该就是这样：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">MainActivity</span> [老板]: dispatchTouchEvent     把按钮做的好看一点,要有光泽,给人一种点击的欲望.</span><br><span class="line"><span class="symbol">RootView</span>     [经理]: dispatchTouchEvent     技术部,老板说按钮不好看,要加一道光.</span><br><span class="line"><span class="symbol">RootView</span>     [经理]: onInterceptTouchEvent  </span><br><span class="line"><span class="symbol">ViewGroupA</span>   [组长]: dispatchTouchEvent     给按钮加上一道光.</span><br><span class="line"><span class="symbol">ViewGroupA</span>   [组长]: onInterceptTouchEvent  </span><br><span class="line"><span class="symbol">View1</span>        [码农]: dispatchTouchEvent     加一道光.</span><br><span class="line"><span class="symbol">View1</span>        [码农]: onTouchEvent           做好了.</span><br></pre></td></tr></table></figure>
<p>那么我们如果ViewGroup进行拦截处理呢？也就是View的事件不响应了。我们再一次的看看效果图：<br><img src="https://cdn.jsdelivr.net/gh/sw950729/img_cdn/img/20210204211730.png" alt="这里写图片描述"></p>
<p>流程如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">MainActivity</span> <span class="selector-attr">[老板]</span>: <span class="selector-tag">dispatchTouchEvent</span>     现在项目做到什么程度了?</span><br><span class="line"><span class="selector-tag">RootView</span>     <span class="selector-attr">[经理]</span>: <span class="selector-tag">dispatchTouchEvent</span>     技术部,你们的<span class="selector-tag">app</span>快做完了么?</span><br><span class="line"><span class="selector-tag">RootView</span>     <span class="selector-attr">[经理]</span>: <span class="selector-tag">onInterceptTouchEvent</span>  </span><br><span class="line"><span class="selector-tag">ViewGroupA</span>   <span class="selector-attr">[组长]</span>: <span class="selector-tag">dispatchTouchEvent</span>     项目进度?</span><br><span class="line"><span class="selector-tag">ViewGroupA</span>   <span class="selector-attr">[组长]</span>: <span class="selector-tag">onInterceptTouchEvent</span>  </span><br><span class="line"><span class="selector-tag">ViewGroupA</span>   <span class="selector-attr">[组长]</span>: <span class="selector-tag">onTouchEvent</span>           正在测试,明天就测试完了</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上所失，我们可以发现，我们几乎没有在dispatch里面进行任何处理，不是说用不到，只是这个方法用的不多，一般都在拦截和消费里面进行处理，通知上层或者下层是否需要执行。昨天一个小伙伴刚和我说他最近也在重新整理view这块，也是一个功能就要用到了dispatch这个方法。这个具体我就不细说了。你们可以自己理理。</p>
<p>这个篇幅我只是对view做了一个简单的介绍，通过标题“浅析”也知道。不过，如果这篇你们看懂了。对于正常的需求开发已无大碍。后面我尽可能去深入分析一次。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>《android群英传》</p>
<p> <a href="http://www.gcssloop.com/customview/dispatch-touchevent-theory">事件分发机制原理</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>View的事件源码分析</title>
    <url>/android/view/view-event/</url>
    <content><![CDATA[<p>上次刚刚分析了view的事件拦截机制，那么这次我们通过源码来分析一波view的事件，如果对view的事件不了解的，可以先看<a href="http://blog.csdn.net/sw950729/article/details/76662222">View的事件拦截浅析</a></p>
<h3 id="解析View源码"><a href="#解析View源码" class="headerlink" title="解析View源码"></a>解析View源码</h3><p>既然是分析源码，那么我们就要找准入手点，不然几万行代码看完在整理完还是很累的。既然是事件的分析，我们就应该知道从哪入手。就是touchevent了。</p>
<p>首先，我们先了解下下面几个属性，这肯定是和事件有关的。</p>
<p>1.clickable：控制当前view是否可以点击</p>
<p>2.longclickable：控制当前view是否可以长按</p>
<p>3.foucsable：是否可以获取当前view的焦点（一般用于edittext）</p>
<p>4.enable：是否可以选中</p>
<p>5.saveenable：状态保存，和activity的savedInstanceState类似</p>
<p>6.setOnTouchListener：触摸事件</p>
<p>7.setOnLongClickListener：长按事件</p>
<p>8.setClickListener：点击事件</p>
<p>上次我们讲过view的事件是从dispatchtouchevent–&gt;onTouchEvent。这边我就不写自定义view了。普通一个view分别执行三个事件。我们先来看效果图：<br><img src="https://s3.ax1x.com/2021/01/25/sOU2ct.png" alt="这里写图片描述"></p>
<h4 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h4><p>首先我们先来了解最简单的enable属性，首先，我们先放上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enabled == isEnabled()) <span class="keyword">return</span>;</span><br><span class="line">        setFlags(enabled ? ENABLED : DISABLED, ENABLED_MASK);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The View most likely has to change its appearance, so refresh</span></span><br><span class="line"><span class="comment">         * the drawable state.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        refreshDrawableState();</span><br><span class="line">        <span class="comment">// Invalidate too, since the default behavior for views is to be</span></span><br><span class="line">        <span class="comment">// be drawn at 50% alpha rather than to change the drawable.</span></span><br><span class="line">        invalidate(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line">            cancelPendingInputEvents();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们直接看最后一个判断，当enable为false的我们发现他执行了一个方法，字面意思就是取消所有的输入事件。我们仔细看了他到底做了什么处理。</p>
<p>通过层层的调用，我们找到了如下代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onCancelPendingInputEvents</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    removePerformClickCallback();</span><br><span class="line">    cancelLongPress();</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_CALLED_SUPER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面分别执行了，移除所有的事件回调以及取消了长按操作。</p>
<p>于是我们便知道，只要调用这个方法，他的所有事件都将不会执行。</p>
<h4 id="longclickable"><a href="#longclickable" class="headerlink" title="longclickable"></a>longclickable</h4><p>我们把代码改成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">view.setLongClickable(<span class="keyword">false</span>);</span><br><span class="line">view.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View view, MotionEvent motionEvent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (motionEvent.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            Log.i(<span class="string">&quot;--&gt;&quot;</span>, <span class="string">&quot;onTouch: View---&gt;onTouch&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">view.setOnLongClickListener(<span class="keyword">new</span> View.OnLongClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLongClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;--&gt;&quot;</span>, <span class="string">&quot;onLongClick: View---&gt;onLongClick&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">view.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;--&gt;&quot;</span>, <span class="string">&quot;onClick: View---&gt;onClick&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后我们在跑一下，发现了一个问题。<br><img src="https://s3.ax1x.com/2021/01/25/sOUvHU.png" alt="这里写图片描述"><br>我们把longclick事件都禁止了为什么还会执行长按事件呢，我们翻一下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnLongClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnLongClickListener l)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isLongClickable()) &#123;</span><br><span class="line">           setLongClickable(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       getListenerInfo().mOnLongClickListener = l;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>发现他的事件监听中先判断了是否长按如果不是，就强制把它变为ture，然后执行。然后我们往上看，可以发现，咦，onclick也是的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(<span class="meta">@Nullable</span> OnClickListener l)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">         setClickable(<span class="keyword">true</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     getListenerInfo().mOnClickListener = l;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以我们需要在执行事件之后执行这些方法。然后我们在看一下效果：<br><img src="https://s3.ax1x.com/2021/01/25/sOaFjx.png" alt="这里写图片描述"></p>
<p>我们神器的发现，我们把longclickable方法onlongclick事件之后执行，效果依旧是这样。这是为什么呢？我们打开onTouchEvent的源码，看个究竟。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE|| (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)|| (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line">     ...</span><br><span class="line">  <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">  <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">  <span class="keyword">if</span> ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">     handleTooltipUp();</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="keyword">if</span> (!clickable) &#123;</span><br><span class="line">      removeTapCallback();</span><br><span class="line">      removeLongPressCallback();</span><br><span class="line">      mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">      mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">      mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">              ...</span><br><span class="line">      <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">            performClick();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>源码太多，这边我省略了部分源码，留了几个重点，我们可以看下clickable是通过或的关系得到的，也就是只要长按和点击有一个执行，那他为ture。后面还有一段就是当clickable为false的时候移除所有的事件回调。</p>
<p>不过我们还发现了一个问题，onlongclick怎么没有执行，字面意思我们理解下，长按，那肯定是按下的时候执行的，我们来查找下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                  <span class="keyword">if</span> (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;</span><br><span class="line">                      mPrivateFlags3 |= PFLAG3_FINGER_DOWN;</span><br><span class="line">                  &#125;</span><br><span class="line">                  mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">if</span> (!clickable) &#123;</span><br><span class="line">                      checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// Walk up the hierarchy to determine if we&#x27;re inside a scrolling container.</span></span><br><span class="line">                  <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class="line">                  <span class="comment">// For views inside a scrolling container, delay the pressed feedback for</span></span><br><span class="line">                  <span class="comment">// a short period in case this is a scroll.</span></span><br><span class="line">                  <span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">                      mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                      <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                          mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</span><br><span class="line">                      &#125;</span><br><span class="line">                      mPendingCheckForTap.x = event.getX();</span><br><span class="line">                      mPendingCheckForTap.y = event.getY();</span><br><span class="line">                      postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></span><br><span class="line">                      setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                      checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码其实就是判断，视图是否为短时间的滑动/滚动，如果不是的话，我们就去检查长按事件。我们来看下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForLongClick</span><span class="params">(<span class="keyword">int</span> delayOffset, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">         mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">if</span> (mPendingCheckForLongPress == <span class="keyword">null</span>) &#123;</span><br><span class="line">             mPendingCheckForLongPress = <span class="keyword">new</span> CheckForLongPress();</span><br><span class="line">         &#125;</span><br><span class="line">         mPendingCheckForLongPress.setAnchor(x, y);</span><br><span class="line">         mPendingCheckForLongPress.rememberWindowAttachCount();</span><br><span class="line">         mPendingCheckForLongPress.rememberPressedState();</span><br><span class="line">         postDelayed(mPendingCheckForLongPress,</span><br><span class="line">                 ViewConfiguration.getLongPressTimeout() - delayOffset);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>和我们想象的一样，他会先检查longclickable然后在判断是否需要执行我们的长按事件。我们来把长按禁用看下效果：<br><img src="https://s3.ax1x.com/2021/01/25/sOalvt.png" alt="这里写图片描述"></p>
<h4 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h4><p>这样我们差不多把事件分析的源码整理的差不多了。不过呢，我们发现ontouchListener里面有一个事件，如果return  true的话那么他将直接消耗掉事件，这个是如何处理的呢？我们去翻下源码，看看在哪边执行了这个方法。找呀找，嗯，找到了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If the event should be handled by accessibility focus first.</span></span><br><span class="line">        <span class="keyword">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class="line">            <span class="comment">// We don&#x27;t have focus or no virtual descendant has it, do not handle the event.</span></span><br><span class="line">            <span class="keyword">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We have focus and got the event, then use normal event dispatch.</span></span><br><span class="line">            event.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Defensive cleanup for new gesture</span></span><br><span class="line">            stopNestedScroll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></span><br><span class="line">        <span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest</span></span><br><span class="line">        <span class="comment">// of the gesture.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">                actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">                (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">            stopNestedScroll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个这个，源码似乎有点长哈。。不急，我来用几句通俗易懂的话来给你们讲清楚。</p>
<p>如果设置了OnTouchListener，并且当前 View 可点击，就调用监听器的 onTouch 方法， 如果 onTouch 方法返回值为 true，就设置 result 为 true。 如果 result 为 false，则调用自身的 onTouchEvent。如果 onTouchEvent 返回值为 true，则设置 result 为 true。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们可以把View的事件分析总结成如下几句话：</p>
<p>1.view的事件可以理解成一个责任链模式，其实我当时就是因为了解了责任链模式，才会快速的理解view的事件传递的。</p>
<p>2.View的事件的调度顺序是 onTouchListener –&gt; onTouchEvent –&gt; onLongClickListener –&gt; onClickListener 。</p>
<p>3.如果他的enable为false。那他将不执行任何事件，包括ontouch。</p>
<p>4.如果view的ontouch消耗了事件，他不再执行任何点击事件。</p>
<p>5.对于click的处理，如果想只执行longclick不执行的click的方法，只有选择不去监听click，至于为什么，我们前面分析过。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>Android的消息机制</title>
    <url>/android/handler/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>说到Android的消息机制，我们肯定会想到Handler。是的，Android的消息机制主要是指Handler的运行机制以及Handler所附带的MessageQueue和Looper的工作过程。当我们工作的时候我们只要接触到Handler就可以了。</p>
<p>Android的消息机制主要是指handlr的运行机制，handler的运行需要底层的messagequeue和looper来支撑。messagequeue就是消息队列，也就是说它内部存储了一组消息，以队列的形式对外提供插入和删除的工作，虽然叫队列，但其内部是用单链表的数据结构来存储消息列表的。looper意旨循环，在这也就说消息循环。由于messagequeue只是一个消息的存储单元。并不能去处理消息，送一我们就需要looper去填补。looper会以无限循环的形式去遍历messagequeue，如果有消息就取出。否则一直等待着。</p>
<p>提到线程，我们就需要提到threadlocal，threadlocal并不是线程，但它可以在每个线程中存储数据。后面我们会分析threadlocal的源码来解释它是如何在多个线程中存储数据的。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>handler可以说是面试常客了，现在列出几个常问的面试题：</p>
<ul>
<li>handler消息机制流程</li>
<li>什么是ANR？什么情况下会出现ANR？</li>
<li>looper.loop()为什么不阻塞主线程</li>
<li>handler、messagequeue、looper三者的关系</li>
</ul>
<h3 id="threadlocal工作原理"><a href="#threadlocal工作原理" class="headerlink" title="threadlocal工作原理"></a>threadlocal工作原理</h3><p>前面我们说到threadlocal可以在多个线程中存储数据，那么它到底是怎么做到的呢？我们只要弄清楚get和set方法就能理解它的工作原理。<br>首先看看Threadlocal的set方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码我们可以发现这边是通过一个map来存储数据的，而它的key就是当前的线程，也就是我们前面说的它是怎么做多个线程中存储数据的。</p>
<p>下面我们看看get方法，看看它是如何获取这些线程的数据的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       T value = initialValue();</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">           map.set(<span class="keyword">this</span>, value);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           createMap(t, value);</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这边我们可以看出它是通过当前线程去寻找对应的map，通过map在去寻找对应的value。如果map不存在，默认返回一个null。</p>
<h3 id="MessageQueue的工作原理"><a href="#MessageQueue的工作原理" class="headerlink" title="MessageQueue的工作原理"></a>MessageQueue的工作原理</h3><p>messagequeue是以一个单链表去维护一个消息队列。提高删除插入消息等操作的性能。插入和读取的对应方法分别为enqueueMessage和next。前者的作用是往消息队列中插入一条消息，而后者的作用则是从消息队列中取出一条消息并将其从消息队列中移除。下面我们看看enqueueMessage的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">              IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                      msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">              Log.w(TAG, e.getMessage(), e);</span><br><span class="line">              msg.recycle();</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          msg.markInUse();</span><br><span class="line">          msg.when = when;</span><br><span class="line">          Message p = mMessages;</span><br><span class="line">          <span class="keyword">boolean</span> needWake;</span><br><span class="line">          <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">              <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">              msg.next = p;</span><br><span class="line">              mMessages = msg;</span><br><span class="line">              needWake = mBlocked;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">              <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">              <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">              needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">              Message prev;</span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  prev = p;</span><br><span class="line">                  p = p.next;</span><br><span class="line">                  <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                      needWake = <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">              prev.next = msg;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">          <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">              nativeWake(mPtr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码主要是单链表的插入，然后通过对应的标记，设置是否需要唤醒。下面看看next方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">       <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">       <span class="comment">// which is not supported.</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">       <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">       <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">               Binder.flushPendingCommands();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">               Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">               Message msg = mMessages;</span><br><span class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       prevMsg = msg;</span><br><span class="line">                       msg = msg.next;</span><br><span class="line">                   &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                       <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                       nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// Got a message.</span></span><br><span class="line">                       mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           prevMsg.next = msg.next;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           mMessages = msg.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.next = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                       msg.markInUse();</span><br><span class="line">                       <span class="keyword">return</span> msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// No more messages.</span></span><br><span class="line">                   nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           ···</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这边就是一个无限循环的方法，去找出一个异步消息将其返回并且移除，如果没有消息，就一直阻塞在这里。</p>
<h3 id="Looper的工作原理"><a href="#Looper的工作原理" class="headerlink" title="Looper的工作原理"></a>Looper的工作原理</h3><p>looper在消息机制中扮演着消息循环的角色。准确的说它会不停的从messagequeue中查看是否有新消息，如果有新消息就会处理掉。否则一直阻塞在那。我们可以通过looper.prepare()即可为当前线程创建一个looper，然后通过looper.loop()来开启消息循环队列。</p>
<p>looper除了prepare方法之外，还提供了prepareMainLooer方法，这个方法主要是给主线程创建looper使用的。其本质还是通过prepare来实现的。由于主线程的looper比较特殊，looper提供了getMainLooper方法来获取主线程的looper。当然looper也是可以退出的。它提供了quit和quitSafely来退出一个looper。前者会直接退出，而后者只是给了一个标记，当队列中消息处理完毕后，才会安全的退出。looper退出后，handler的sendmessage方法会返回false。</p>
<p>looper中最重要的一个方法是loop。只有调用了loop，才会真正的启动循环系统。下面看看它是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                        msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> start = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> time = end - start;</span><br><span class="line">                <span class="keyword">if</span> (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Dispatch took &quot;</span> + time + <span class="string">&quot;ms on &quot;</span></span><br><span class="line">                            + Thread.currentThread().getName() + <span class="string">&quot;, h=&quot;</span> +</span><br><span class="line">                            msg.target + <span class="string">&quot; cb=&quot;</span> + msg.callback + <span class="string">&quot; msg=&quot;</span> + msg.what);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                        + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此方法也很好理解，loop方法是一个死循环，唯一跳出循环的方法是messagequeue的next方法返回null，也就是looper的quit方法被调用后，会将messagequeue来通知消息队列退出。此时，它的next方法就会返回null，也就是说looper必须退出，否则它将一直循环下去。如果messagequeue的next方法返回了新消息，looper就会处理这条消息，它会将这条消息交给handler去处理。</p>
<h3 id="handler工作原理"><a href="#handler工作原理" class="headerlink" title="handler工作原理"></a>handler工作原理</h3><p>handler主要是用来发送消息和接受消息的。消息的发送可以通过post去发送，不过最后还是通过send去实现的。下面我们看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           delayMillis = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       MessageQueue queue = mQueue;</span><br><span class="line">       <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">           RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">           Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       msg.target = <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，handler发送消息仅仅是向消息队列中插入一条消息，然后messagequeue的next方法就会将消息返回给looper，looper收到消息后又把它交给handler处理。也就是会调用dispatchMessage方法。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">           handleCallback(msg);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>handler处理消息的过程如下：<br>首先，检查message的callback是否为null，不为null就通过handlecallback来处理消息，message的callback是一个runnable对象，实际上就是handler的post方法所传的runnable参数。<br>其次，检查mcallback是否为null，不为null就调用mcallback的handlemessage方法来处理消息。<br>最后，调用handler的hanldemessage方法来处理消息。</p>
<h3 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h3><p>Android的主线程就是ActivityThread。主线程的入口是main，在mian方法中我们通过looper.prepareMainLooper()来创建主线程的looper以及messagequeue，并通过looper.loop()去开启主线程的消息循环。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">       <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">       <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">       CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">       EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">       <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">       TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">       Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">       ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">       thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">           sMainThreadHandler = thread.getHandler();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">           Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                   LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">       Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">       Looper.loop();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主线程的消息循环开启之后，activitythread还需要一个handler来和消息队列进行交互，也就是activitythread.H。其内部定义了一组消息的类型，主要是四大组件的停止和启动。</p>
<p>activitythread通过applicationthread和ams进行进程间通信。ams以进程间通信的方式完成activitythread的请求后会回调applicationthread中的binder方法。然后applicationthread会向H发送消息，H收到消息后会将applicationthread的逻辑切换到activitythread中去执行，即切换到主线程执行。这个过程就是主线程的消息循环模型。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>Android的线程和线程池</title>
    <url>/android/thread_pool/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>线程中Android中是很重要的一个概念。从用途上来说，线程分为主线程和子线程。主线程主要用于界面上的交互，而子线程主要用于一些耗时操作。除了thread之外，在Android中可以扮演线程角色的还有很多。例如Asnyctask、IntentService以及handlerthread。对于asnyctask，它的底层用了线程池，对于intentservice和handlerthread来说，它们的底层则是用了线程。</p>
<h3 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h3><p>主线程数指进程所拥有的线程，在Java 中默认情况下，一个进程只有一个主线程。主线程主要用于处理界面的交互，因为用户随时会和界面发生交互，因此主线程主任何时候都需要有较高的响应速度。否则就会产生界面卡顿。这就要求主线程不能执行耗时任务，所以我们就需要子线程。除了工作线程以外的线程都是子线程。子线程也称工作线程，用于执行一些耗时任务，比如网络请求、I/O操作等。</p>
<h3 id="AsyncTask的工作原理"><a href="#AsyncTask的工作原理" class="headerlink" title="AsyncTask的工作原理"></a>AsyncTask的工作原理</h3><p>AsyncTask是一个抽象的范型类，它提供了Params、Progress和Result这三个范型参数，其中Params表示参数的类型，Progress表示后台执行的任务的进度的类型，而Result表示返回结果的类型。如果不需要传具体的参数可以用Void代替。</p>
<p>AsyncTask提供了四个核心方法，具体如下：</p>
<ul>
<li>onPreExcute()，在主线程中执行，在异步任务开始前执行，此方法会被调用，一般可以用于一些准备工作。</li>
<li>doInBackground(Params… params)，在线程池中执行，此方法用于执行异步任务，params表示异步任务输入的参数。在此方法中可以通过publishProgress方法来更新任务进度。publishProgress方法会调用onProgressUpdate方法。另外此方法需要返回结果给onPostExcute方法。</li>
<li>onProgressUpdate(Progress… values)，在主线程中执行，当后台任务的执行进度发生改变时，此方法会被调用。</li>
<li>onPostExcute(Result result)，在主线程中执行，在异步任务执行之后，此方法会被调用，其中result时后台任务的返回值。</li>
</ul>
<p>首先看看asynctask的一些变量到底是干什么的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CPU_COUNT为手机中的CPU核数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">//将手机中的CPU核数加1作为AsyncTask所使用的线程池的核心线程数的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//将CPU_COUNT * 2 + 1作为AsyncTask所使用的线程池的最大线程数的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化线程工厂ThreadFactory，sThreadFactory用于在后面创建线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="comment">//mCount为AtomicInteger类型，AtomicInteger是一个提供原子操作的Integer类，</span></span><br><span class="line">    <span class="comment">//确保了其getAndIncrement方法是线程安全的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写newThread方法的目的是为了将新增线程的名字以&quot;AsyncTask #&quot;标识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;AsyncTask #&quot;</span> + mCount.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化阻塞式队列BlockingQueue，队列中存放Runnable，容量为128</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据上面定义的参数实例化线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</span><br><span class="line">        = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</span><br><span class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</span><br></pre></td></tr></table></figure>
<p>通过以上代码和注释我们可以知道，AsyncTask初始化了一些参数，并用这些参数实例化了一个线程池THREAD_POOL_EXECUTOR，需要注意的是该线程池被定义为public static final，由此我们可以看出AsyncTask内部维护了一个静态的线程池，默认情况下，AsyncTask的实际工作就是通过该THREAD_POOL_EXECUTOR完成的。</p>
<p>我们继续，在执行完上面的代码后，AsyncTask又有如下一条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();</span><br></pre></td></tr></table></figure>
<p>上面的代码实例化了一个SerialExecutor类型的实例SERIAL_EXECUTOR，它也是public static final的。SerialExecutor是AsyncTask的一个内部类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SerialExecutor实现了Executor接口中的execute方法，该类用于串行执行任务，</span></span><br><span class="line">    <span class="comment">//即一个接一个地执行任务，而不是并行执行任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="comment">//mTasks是一个维护Runnable的双端队列，ArrayDeque没有容量限制，其容量可自增长</span></span><br><span class="line">        <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">        <span class="comment">//mActive表示当前正在执行的任务Runnable</span></span><br><span class="line">        Runnable mActive;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//execute方法会传入一个Runnable类型的变量r</span></span><br><span class="line">            <span class="comment">//然后我们会实例化一个Runnable类型的匿名内部类以对r进行封装，</span></span><br><span class="line">            <span class="comment">//通过队列的offer方法将封装后的Runnable添加到队尾</span></span><br><span class="line">            mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//执行r的run方法，开始执行任务</span></span><br><span class="line">                        <span class="comment">//此处r的run方法是在线程池中执行的</span></span><br><span class="line">                        r.run();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//当任务执行完毕的时候，通过调用scheduleNext方法执行下一个Runnable任务</span></span><br><span class="line">                        scheduleNext();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//只有当前没有执行任何任务时，才会立即执行scheduleNext方法</span></span><br><span class="line">            <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduleNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//通过mTasks的poll方法进行出队操作，删除并返回队头的Runnable，</span></span><br><span class="line">            <span class="comment">//将返回的Runnable赋值给mActive，</span></span><br><span class="line">            <span class="comment">//如果不为空，那么就让将其作为参数传递给THREAD_POOL_EXECUTOR的execute方法进行执行</span></span><br><span class="line">            <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过以上代码和注释我们可以知道：</p>
<ul>
<li>SerialExecutor实现了Executor接口中的execute方法，该类用于串行执行任务，即一个接一个地执行任务，而不是并行执行任务。</li>
<li>SerialExecutor内部维护了一个存放Runnable的双端队列mTasks。当执行SerialExecutor的execute方法时，会传入一个Runnable变量r，但是mTasks并不直接存储r，而是又新new了一个匿名Runnable对象，其内部会调用r，这样就对r进行了封装，将该封装后的Runnable对象通过队列的offer方法入队，添加到mTasks的队尾。</li>
<li>SerialExecutor内部通过mActive存储着当前正在执行的任务Runnable。当执行SerialExecutor的execute方法时，首先会向mTasks的队尾添加进一个Runnable。然后判断如果mActive为null，即当前没有任务Runnable正在运行，那么就会执行scheduleNext()方法。当执行scheduleNext方法的时候，会首先从mTasks中通过poll方法出队，删除并返回队头的Runnable，将返回的Runnable赋值给mActive，如果不为空，那么就让将其作为参数传递给THREAD_POOL_EXECUTOR的execute方法进行执行。由此，我们可以看出SerialExecutor实际上是通过之前定义的线程池THREAD_POOL_EXECUTOR进行实际的处理的。</li>
<li>当将mTasks中的Runnable作为参数传递给THREAD_POOL_EXECUTOR执行execute方法时，会在线程池的工作线程中执行匿名内部类Runnable中的try-finally代码段，即先在工作线程中执行r.run()方法去执行任务，无论任务r正常完成还是抛出异常，都会在finally中执行scheduleNext方法，用于执行mTasks中的下一个任务。从而在此处我们可以看出SerialExecutor是一个接一个执行任务，是串行执行任务，而不是并行执行。</li>
</ul>
<p>除了上述的那些字段，还有如下几个字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于通过Handler发布result的Message Code</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_RESULT = <span class="number">0x1</span>;</span><br><span class="line"><span class="comment">//用于通过Handler发布progress的Message Code</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_POST_PROGRESS = <span class="number">0x2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sDefaultExecutor表示AsyncTask默认使用SERIAL_EXECUTOR作为Executor，</span></span><br><span class="line"><span class="comment">//即默认情况下AsyncTask是串行执行任务，而不是并行执行任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InternalHandler是AsyncTask中定义的一个静态内部类，其绑定了主线程的Looper和消息队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InternalHandler sHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mWorker是一个实现了Callable接口的对象，其实现了Callable接口的call方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WorkerRunnable&lt;Params, Result&gt; mWorker;</span><br><span class="line"><span class="comment">//根据mFuture是一个FutureTask对象，需要用mWorker作为参数实例化mFuture</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;Result&gt; mFuture;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AsyncTask的初始状态位PENDING</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Status mStatus = Status.PENDING;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mCancelled标识当前任务是否被取消了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean mCancelled = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"><span class="comment">//mTaskInvoked标识当前任务是否真正开始执行了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean mTaskInvoked = <span class="keyword">new</span> AtomicBoolean();</span><br></pre></td></tr></table></figure>
<p>我们对以上代码再进行一下说明：</p>
<ul>
<li><p>sDefaultExecutor表示AsyncTask执行任务时默认所使用的线程池，sDefaultExecutor的初始值为SERIAL_EXECUTOR，表示默认情况下AsyncTask是串行执行任务，而不是并行执行任务。</p>
</li>
<li><p>InternalHandler是AsyncTask中定义的一个静态内部类，其部分源码如下所示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Looper类的getMainLooper方法是个静态方法，该方法返回主线程的Looper</span></span><br><span class="line">        <span class="comment">//此处用主线程的Looper初始化InternalHandler，表示InternalHandler绑定了主线程</span></span><br><span class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                <span class="comment">//发布最后结果</span></span><br><span class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                <span class="comment">//发布阶段性处理结果</span></span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过InternalHandler的构造函数我们可以发现，用主线程的Looper初始化了InternalHandler，说明InternalHandler绑定了主线程。</p>
<p>下面我们看一下asynctask的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AsyncTask的构造函数需要在UI线程上调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实例化mWorker，实现了Callable接口的call方法</span></span><br><span class="line">        mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">//call方法是在线程池的某个线程中执行的，而不是运行在主线程中</span></span><br><span class="line">                <span class="comment">//call方法开始执行后，就将mTaskInvoked设置为true，表示任务开始执行</span></span><br><span class="line">                mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//将执行call方法的线程设置为后台线程级别</span></span><br><span class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                <span class="comment">//在线程池的工作线程中执行doInBackground方法，执行实际的任务，并返回结果</span></span><br><span class="line">                Result result = doInBackground(mParams);</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">                <span class="comment">//将执行完的结果传递给postResult方法</span></span><br><span class="line">                <span class="keyword">return</span> postResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用mWorker实例化mFuture</span></span><br><span class="line">        <span class="comment">//在run方法中会调用mWorkder的call方法，具体看FutureTask源码</span></span><br><span class="line">     mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//任务执行完毕或取消任务都会执行done方法</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//任务正常执行完成</span></span><br><span class="line">                    postResultIfNotInvoked(get());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//任务出现中断异常</span></span><br><span class="line">                    android.util.Log.w(LOG_TAG, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    <span class="comment">//任务执行出现异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;An error occurred while executing doInBackground()&quot;</span>,</span><br><span class="line">                            e.getCause());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                    <span class="comment">//任务取消</span></span><br><span class="line">                    postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>mWorker<br>我们之前提到，mWorker其实是一个Callable类型的对象。实例化mWorker，实现了Callable接口的call方法。call方法是在线程池的某个线程中执行的，而不是运行在主线程中。在线程池的工作线程中执行doInBackground方法，执行实际的任务，并返回结果。当doInBackground执行完毕后，将执行完的结果传递给postResult方法。</p>
</li>
<li><p>mFuture<br>mFuture是一个FutureTask类型的对象，用mWorker作为参数实例化了mFuture。在这里，其实现了FutureTask的done方法，我们之前提到，当FutureTask的任务执行完成或任务取消的时候会执行FutureTask的done方法。</p>
</li>
</ul>
<p>在实例化了AsyncTask对象之后，我们就可以调用AsyncTask的execute方法执行任务，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@MainThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></span><br><span class="line"><span class="function"><span class="params">          Params... params)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">          <span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">              <span class="keyword">case</span> RUNNING:</span><br><span class="line">                  <span class="comment">//如果当前AsyncTask已经处于运行状态，那么就抛出异常，不再执行新的任务</span></span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                          + <span class="string">&quot; the task is already running.&quot;</span>);</span><br><span class="line">              <span class="keyword">case</span> FINISHED:</span><br><span class="line">                  <span class="comment">//如果当前AsyncTask已经把之前的任务运行完成，那么也抛出异常，不再执行新的任务</span></span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot execute task:&quot;</span></span><br><span class="line">                          + <span class="string">&quot; the task has already been executed &quot;</span></span><br><span class="line">                          + <span class="string">&quot;(a task can be executed only once)&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将AsyncTask的状态置为运行状态</span></span><br><span class="line">      mStatus = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//在真正执行任务前，先调用onPreExecute方法</span></span><br><span class="line">      onPreExecute();</span><br><span class="line"></span><br><span class="line">      mWorker.mParams = params;</span><br><span class="line">      <span class="comment">//Executor的execute方法接收Runnable参数，由于mFuture是FutureTask的实例，</span></span><br><span class="line">      <span class="comment">//且FutureTask同时实现了Callable和Runnable接口，所以此处可以让exec执行mFuture</span></span><br><span class="line">      exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//最后将AsyncTask自身返回</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面对以上代码进行一下说明：</p>
<ul>
<li><p>一个AsyncTask实例执行执行一次任务，当第二次执行任务时就会抛出异常。executeOnExecutor方法一开始就检查AsyncTask的状态是不是PENDING，只有PENDING状态才往下执行，如果是其他状态表明现在正在执行另一个已有的任务或者已经执行完成了一个任务，这种情况下都会抛出异常。</p>
</li>
<li><p>如果开始是PENDING状态，那么就说明该AsyncTask还没执行过任何任务，代码可以继续执行，然后将状态设置为RUNNING，表示开始执行任务。</p>
</li>
<li><p>在真正执行任务前，先调用onPreExecute方法。由于executeOnExecutor方法应该运行在主线程上，所以此处的onPreExecute方法也会运行在主线程上，可以在该方法中做一些UI上的处理操作。</p>
</li>
<li><p>Executor的execute方法接收Runnable参数，由于mFuture是FutureTask的实例，且FutureTask同时实现了Callable和Runnable接口，所以此处可以让exec通过execute方法在执行mFuture。在执行了exec.execute(mFuture)之后，后面会在exec的工作线程中执行mWorker的call方法，我们之前在介绍mWorker的实例化的时候也介绍了call方法内部的执行过程，会首先在工作线程中执行doInBackground方法，并返回结果，然后将结果传递给postResult方法。</p>
</li>
</ul>
<p>下面我们看一下postResult方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="comment">//通过getHandler获取InternalHandler，InternalHandler绑定主线程</span></span><br><span class="line">        <span class="comment">//根据InternalHandler创建一个Message Code为MESSAGE_POST_RESULT的Message</span></span><br><span class="line">        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">        <span class="comment">//将该message发送给InternalHandler</span></span><br><span class="line">        message.sendToTarget();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在postResult方法中，通过getHandler获取InternalHandle,在得到InternalHandler对象之后，会根据InternalHandler创建一个Message Code为MESSAGE_POST_RESULT的Message，此处还将doInBackground返回的result通过new AsyncTaskResult<Result>(this, result)封装成了AsyncTaskResult，将其作为message的obj属性。构建完成之一，它会发送给InternalHanlder。handler接受如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>(looper);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">          AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">          <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">              <span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">                  <span class="comment">// There is only one result</span></span><br><span class="line">                  result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">                  result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看看finish的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">            <span class="comment">//如果任务被取消了，那么执行onCancelled方法</span></span><br><span class="line">            onCancelled(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将结果发传递给onPostExecute方法</span></span><br><span class="line">            onPostExecute(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后将AsyncTask的状态设置为完成状态</span></span><br><span class="line">        mStatus = Status.FINISHED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>finish方法内部会首先判断AsyncTask是否被取消了，如果被取消了执行onCancelled(result)，否则执行onPostExecute(result)方法。需要注意的是InternalHandler是指向主线程的，所以其handleMessage方法是在主线程中执行的，从而此处的finish方法也是在主线程中执行的，进而onPostExecute也是在主线程中执行的。</p>
<p>上面我们知道了任务从开始执行到onPostExecute的过程。我们知道，doInBackground方法是在工作线程中执行比较耗时的操作，这个操作时间可能比较长，而我们的任务有可能分成多个部分，每当我完成其中的一部分任务时，我们可以在doInBackground中多次调用AsyncTask的publishProgress方法，将阶段性数据发布出去。</p>
<p>publishProgress方法代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishProgress</span><span class="params">(Progress... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                    <span class="keyword">new</span> AsyncTaskResult&lt;Progress&gt;(<span class="keyword">this</span>, values)).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们需要将阶段性处理的结果传入publishProgress，其中values是不定长数组，如果任务没有被取消，就会通过InternalHandler创建一个Message对象，该message的Message Code标记为MESSAGE_POST_PROGRESS，并且会根据传入的values创建AsyncTaskResult，将其作为message的obj属性。然后再将该message发送给InternalHandler，然后InternalHandler会执行handleMessage方法，接收并处理该message。</p>
<p>无论任务正常执行完成还是任务取消，都会执行postResultIfNotInvoked方法。postResultIfNotInvoked代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();</span><br><span class="line">        <span class="keyword">if</span> (!wasTaskInvoked) &#123;</span><br><span class="line">            <span class="comment">//只有mWorker的call没有被调用才会执行postResult方法</span></span><br><span class="line">            postResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果在调用了AsyncTask的execute方法后立马就执行了AsyncTask的cancel方法（实际执行mFuture的cancel方法），那么会执行done方法，且捕获到CancellationException异常，从而执行语句postResultIfNotInvoked(null)，由于此时还没有来得及执行mWorker的call方法，所以mTaskInvoked还未false，这样就可以把null传递给postResult方法。</p>
<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p>handlerthread继承了thread，它说一种可以使用handler的thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过<br>Looper.loop()来开启消息循环，它的run方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mTid = Process.myTid();</span><br><span class="line">       Looper.prepare();</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           mLooper = Looper.myLooper();</span><br><span class="line">           notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">       Process.setThreadPriority(mPriority);</span><br><span class="line">       onLooperPrepared();</span><br><span class="line">       Looper.loop();</span><br><span class="line">       mTid = -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>IntentService继承于Service。如果我们需要在Service中执行一些耗时操作，就需要用到IntentService。这样我们的工作线程就可以放入到IntentService的onHandleIntent回到方法中。当服务启动时，他会自动执行回掉内的方法。并且，当工作线程执行完成后，他会调用onDestory()方法销毁服务，并不需要我们主动停止服务。(当有多个任务执行的时，它会按照顺序执行完任务，当最后一个任务执行完成之后，它才会停止服务。)</p>
<h3 id="android中的线程池"><a href="#android中的线程池" class="headerlink" title="android中的线程池"></a>android中的线程池</h3><p>使用线程池可以给我们带来很多好处，首先通过线程池中线程的重用，减少创建和销毁线程的性能开销。其次，能控制线程池中的并发数，否则会因为大量的线程争夺CPU资源造成阻塞。最后，线程池能够对线程进行管理，比如使用ScheduledThreadPool来设置延迟N秒后执行任务，并且每隔M秒循环执行一次。</p>
<h4 id="ThreadPoolExcutor"><a href="#ThreadPoolExcutor" class="headerlink" title="ThreadPoolExcutor"></a>ThreadPoolExcutor</h4><p>Executor作为一个接口，它的具体实现就ThreadPoolExecutor。<br>Android中的线程池都是直接或间接通过配ThreadPoolExecutor来实现不同特性的线程池。先介绍ThreadPoolExecutor的一个常用的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">//核心线程数，除非allowCoreThreadTimeOut被设置为<span class="keyword">true</span>，否则它闲着也不会死</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> corePoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">//最大线程数，活动线程数量超过它，后续任务就会排队                   </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> maximumPoolSize, </span></span></span><br><span class="line"><span class="function"><span class="params">//超时时长，作用于非核心线程（allowCoreThreadTimeOut被设置为<span class="keyword">true</span>时也会同时作用于核心线程），闲置超时便被回收           </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> keepAliveTime,                          </span></span></span><br><span class="line"><span class="function"><span class="params">//枚举类型，设置keepAliveTime的单位，有TimeUnit.MILLISECONDS（ms）、TimeUnit. SECONDS（s）等</span></span></span><br><span class="line"><span class="function"><span class="params">TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">//缓冲任务队列，线程池的execute方法会将Runnable对象存储起来</span></span></span><br><span class="line"><span class="function"><span class="params">BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">//线程工厂接口，只有一个new Thread(Runnable r)</span>方法，可为线程池创建新线程</span></span><br><span class="line"><span class="function">ThreadFactory threadFactory)</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor的各个参数所代表的特性注释中已经写的很清楚了，那么ThreadPoolExecutor执行任务时的心路历程是什么样的呢？（以下用currentSize表示线程池中当前线程数量）</p>
<ul>
<li><p>当currentSize&lt;corePoolSize时，没什么好说的，直接启动一个核心线程并执行任务。</p>
</li>
<li><p>当currentSize&gt;=corePoolSize、并且workQueue未满时，添加进来的任务会被安排到workQueue中等待执行。</p>
</li>
<li><p>当workQueue已满，但是currentSize&lt;maximumPoolSize时，会立即开启一个非核心线程来执行任务。</p>
</li>
<li><p>当currentSize&gt;=corePoolSize、workQueue已满、并且currentSize&gt;maximumPoolSize时，调用handler默认抛出RejectExecutionExpection异常。</p>
</li>
</ul>
<h4 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h4><p>Android中最常见的四类具有不同特性的线程池分别为FixThreadPool、CachedThreadPool、ScheduleThreadPool以及SingleThreadExecutor。</p>
<h5 id="FixThreadPool（一堆人排队上公厕）"><a href="#FixThreadPool（一堆人排队上公厕）" class="headerlink" title="FixThreadPool（一堆人排队上公厕）"></a>FixThreadPool（一堆人排队上公厕）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Executors.newFixThreadPool(<span class="number">5</span>).execute(r);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>从配置参数来看，FixThreadPool只有核心线程，并且数量固定的，也不会被回收，所有线程都活动时，因为队列没有限制大小，新任务会等待执行。</p>
</li>
<li><p>【前方高能，笔者脑洞】FixThreadPool其实就像一堆人排队上公厕一样，可以无数多人排队，但是厕所位置就那么多，而且没人上时，厕所也不会被拆迁，哈哈o(∩_∩)o ，很形象吧。</p>
</li>
<li><p>由于线程不会回收，FixThreadPool会更快地响应外界请求，这也很容易理解，就好像有人突然想上厕所，公厕不是现用现建的。</p>
</li>
</ul>
<h5 id="SingleThreadPool（公厕里只有一个坑位）"><a href="#SingleThreadPool（公厕里只有一个坑位）" class="headerlink" title="SingleThreadPool（公厕里只有一个坑位）"></a>SingleThreadPool（公厕里只有一个坑位）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadPool</span> <span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService ( <span class="keyword">new</span> ThreadPoolExecutor (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit. MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Executors.newSingleThreadPool ().execute(r);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>从配置参数可以看出，SingleThreadPool只有一个核心线程，确保所有任务都在同一线程中按顺序完成。因此不需要处理线程同步的问题。</p>
</li>
<li><p>【前方高能，笔者脑洞】可以把SingleThreadPool简单的理解为FixThreadPool的参数被手动设置为1的情况，即Executors.newFixThreadPool(1).execute(r)。所以SingleThreadPool可以理解为公厕里只有一个坑位，先来先上。为什么只有一个坑位呢，因为这个公厕是收费的，收费的大爷上年纪了，只能管理一个坑位，多了就管不过来了（线程同步问题）。</p>
</li>
</ul>
<h5 id="CachedThreadPool（一堆人去一家很大的咖啡馆喝咖啡）"><a href="#CachedThreadPool（一堆人去一家很大的咖啡馆喝咖啡）" class="headerlink" title="CachedThreadPool（一堆人去一家很大的咖啡馆喝咖啡）"></a>CachedThreadPool（一堆人去一家很大的咖啡馆喝咖啡）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit. SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Executors.newCachedThreadPool().execute(r);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>CachedThreadPool只有非核心线程，最大线程数非常大，所有线程都活动时，会为新任务创建新线程，否则利用空闲线程（60s空闲时间，过了就会被回收，所以线程池中有0个线程的可能）处理任务。</p>
</li>
<li><p>任务队列SynchronousQueue相当于一个空集合，导致任何任务都会被立即执行。</p>
</li>
<li><p>【前方高能，笔者脑洞】CachedThreadPool就像是一堆人去一个很大的咖啡馆喝咖啡，里面服务员也很多，随时去，随时都可以喝到咖啡。但是为了响应国家的“光盘行动”，一个人喝剩下的咖啡会被保留60秒，供新来的客人使用，哈哈哈哈哈，好恶心啊。如果你运气好，没有剩下的咖啡，你会得到一杯新咖啡。但是以前客人剩下的咖啡超过60秒，就变质了，会被服务员回收掉。</p>
</li>
<li><p>比较适合执行大量的耗时较少的任务。喝咖啡人挺多的，喝的时间也不长。</p>
</li>
</ul>
<h5 id="ScheduledThreadPool（4个里面唯一一个有延迟执行和周期重复执行的线程池）"><a href="#ScheduledThreadPool（4个里面唯一一个有延迟执行和周期重复执行的线程池）" class="headerlink" title="ScheduledThreadPool（4个里面唯一一个有延迟执行和周期重复执行的线程池）"></a>ScheduledThreadPool（4个里面唯一一个有延迟执行和周期重复执行的线程池）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedQueue ());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用，延迟1秒执行，每隔2秒执行一次Runnable r</span></span><br><span class="line">Executors. newScheduledThreadPool (<span class="number">5</span>).scheduleAtFixedRate(r, <span class="number">1000</span>, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>核心线程数固定，非核心线程（闲着没活干会被立即回收）数没有限制。</p>
</li>
<li><p>从上面代码也可以看出，ScheduledThreadPool主要用于执行定时任务以及有固定周期的重复任务。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>如何理解Window和WindowManager</title>
    <url>/android/window_manager/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Window表示一个窗口，但在日常开发中我们接触的不多。我们常见的如Toast和PopWindow都是属于Window。Window是一个抽象类，而Window的具体实现类是PhoneWindow。如果我们需要创建一个Window，只需要通过WindowManager去实现。而它的具体实现是在WindowManagerService中。我们需要知道Android所有的视图都是附加在Window上的，换句话说Window是View的直接管理者。</p>
<h3 id="Window与WindowManager"><a href="#Window与WindowManager" class="headerlink" title="Window与WindowManager"></a>Window与WindowManager</h3><p>在分析Window得工作机制之前，我们先看看如何添加一个Window，具体的我们可以通过WindowManager去添加，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TextView text = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</span><br><span class="line">text.setText(<span class="string">&quot;just a test&quot;</span>);</span><br><span class="line">WindowManager.LayoutParams layoutParams = <span class="keyword">new</span> WindowManager.LayoutParams(</span><br><span class="line">        WindowManager.LayoutParams.WRAP_CONTENT,</span><br><span class="line">        WindowManager.LayoutParams.WRAP_CONTENT,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        PixelFormat.TRANSPARENT</span><br><span class="line">);</span><br><span class="line"><span class="comment">// flag 设置 Window 属性</span></span><br><span class="line">layoutParams.flags= WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;</span><br><span class="line"><span class="comment">// type 设置 Window 类别（层级）</span></span><br><span class="line">layoutParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY;</span><br><span class="line">layoutParams.gravity = Gravity.CENTER;</span><br><span class="line">WindowManager windowManager = getWindowManager();</span><br><span class="line">windowManager.addView(text, layoutParams);</span><br></pre></td></tr></table></figure>
<p>代码中我们并没有通过setContentView去设置布局，而是直接通过WindowManager去addView实现的。同时，我们需要去添加一个窗口的权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Window的分类"><a href="#Window的分类" class="headerlink" title="Window的分类"></a>Window的分类</h3><p>在上述代码中，我们可以设置Window的级别。Window有三种级别，分别为：应用Window、系统Window和子Window。应用Window对应一个Activity，子Window必须要依附在一个父Window上。</p>
<table>
<thead>
<tr>
<th>Window</th>
<th>层级</th>
</tr>
</thead>
<tbody><tr>
<td>应用 Window</td>
<td>1~99</td>
</tr>
<tr>
<td>子 Window</td>
<td>1000~1999</td>
</tr>
<tr>
<td>系统Window</td>
<td>2000~2999</td>
</tr>
</tbody></table>
<p>我们可以通过WindowManager.LayoutParams的type去设置，如果设置系统Window则需要加上上面的权限，否则会出现异常。</p>
<h3 id="WindowManager的内部机制"><a href="#WindowManager的内部机制" class="headerlink" title="WindowManager的内部机制"></a>WindowManager的内部机制</h3><p>在开发中，我们无法直接使用Window，所有对Window的操作都是经过WindowManager去操作的。WindowManager所提供的功能很简单，即添加View，删除View和更新View。这三个的方法是在ViewManager接口中。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重上述代码可以看出，我们只需要传入对应的view以及view的layoutparms属性即可进行添加和更新，如果需要删除，只需传入需要删除的view即可。</p>
<h3 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h3><h4 id="Window的添加过程"><a href="#Window的添加过程" class="headerlink" title="Window的添加过程"></a>Window的添加过程</h4><p>前面说到如果需要对Window操作都需要通过WindowManager去实现，不过WindowManager只是一个接口，而它的真正实现类是WindowManagerImpl，在WindowManagerImpl的三大操作代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">     applyDefaultToken(params);</span><br><span class="line">     mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">     applyDefaultToken(params);</span><br><span class="line">     mGlobal.updateViewLayout(view, params);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">     mGlobal.removeView(view, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看出，WindowManagerImpl并没有去处理，而是交给WindowManagerGlobal去处理。WindowManagerGlobal的addView主要是如下几个步骤：</p>
<p>1、检查参数;如果是子Window就去做相应的调整：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;view must not be null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;display must not be null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Params must be WindowManager.LayoutParams&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line"><span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">    parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、创建 ViewRootImpl 并将 View 添加到集合中：<br>在WindowManagerGlobal中有如下几个集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> ArraySet&lt;View&gt;();</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>集合</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>mViews</td>
<td>Window 所对应的 View</td>
</tr>
<tr>
<td>mRoots</td>
<td>Window 所对应的 ViewRootImpl</td>
</tr>
<tr>
<td>mParams</td>
<td>Window 所对应的布局参数</td>
</tr>
<tr>
<td>mDyingViews</td>
<td>正在被删除还没完全移除的 View 对象</td>
</tr>
<tr>
<td>addView 操作时会将相关对象添加到对应集合中：</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">view.setLayoutParams(wparams);</span><br><span class="line">mViews.add(view);</span><br><span class="line">mRoots.add(root);</span><br><span class="line">mParams.add(wparams);</span><br></pre></td></tr></table></figure>
<p>3、通过 ViewRootImpl 来更新界面并完成 Window 的添加过程：<br>最后通过如下代码进行addView：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">root.setView(view, wparams, panelParentView);</span><br></pre></td></tr></table></figure>
<p>在setView内部，我们会通过requsetLayout去异步刷新UI，requsetLayout代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">          checkThread();</span><br><span class="line">          mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">          scheduleTraversals();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这是View的绘制入口，我们接着往下看，后面它会调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">            mAttachInfo.mOutsets, mInputChannel);</span><br></pre></td></tr></table></figure>
<p>它是通过WindowSession去完成最后的添加。WindowSession是一个Binder对象，最终实现类是Session，我们继续看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">           Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">               outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，最后是通过调用WMS的addWindow去添加的。具体细节不做深入~~</p>
<h4 id="Window的删除过程"><a href="#Window的删除过程" class="headerlink" title="Window的删除过程"></a>Window的删除过程</h4><p>删除过程和添加过程类似，我们直接看WindowManagerGlobal的removeView方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;view must not be null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">           <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">           View curView = mRoots.get(index).getView();</span><br><span class="line">           removeViewLocked(index, immediate);</span><br><span class="line">           <span class="keyword">if</span> (curView == view) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Calling with view &quot;</span> + view</span><br><span class="line">                   + <span class="string">&quot; but the ViewAncestor is attached to &quot;</span> + curView);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这边会通过调用findViewLocked方法去拿到待删除View的索引。然后通过removeViewLocked去实现删除逻辑，具体看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">       ViewRootImpl root = mRoots.get(index);</span><br><span class="line">       View view = root.getView();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">           InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">           <span class="keyword">if</span> (imm != <span class="keyword">null</span>) &#123;</span><br><span class="line">               imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">boolean</span> deferred = root.die(immediate);</span><br><span class="line">       <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">           view.assignParent(<span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">               mDyingViews.add(view);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这边会调用ViewRootImpl的die方法去处理，我们继续看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123; <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">           doDie();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ···</span><br><span class="line">       mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这边会判断同步还是异步，如果是同步就直接调用doDie方法，否则会通过Handler发送消息调用doDie方法去处理，在doDie方法中真正实现删除逻辑的是dispatchDetachedFromWindow方法。主要是做了如下几件事：</p>
<ul>
<li>GC回收相关</li>
<li>一个IPC过程：mWindowSession.remove(mWindow);</li>
<li>调用WindowManagerGlobal.getInstance().doRemoveView(this);去移除关于当前Windows的数据。</li>
</ul>
<h4 id="Window的更新过程"><a href="#Window的更新过程" class="headerlink" title="Window的更新过程"></a>Window的更新过程</h4><p>过程基本和添加和删除类似，我们来看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;view must not be null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Params must be WindowManager.LayoutParams&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line"></span><br><span class="line">       view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">           <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">           ViewRootImpl root = mRoots.get(index);</span><br><span class="line">           mParams.remove(index);</span><br><span class="line">           mParams.add(index, wparams);</span><br><span class="line">           root.setLayoutParams(wparams, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要做了如下几件事：</p>
<ul>
<li>更新view的layoutparms属性</li>
<li>找到view的索引</li>
<li>移除之前的view</li>
<li>添加当前的view</li>
<li>设置view的layoutparms属性</li>
</ul>
<h3 id="Window的创建过程"><a href="#Window的创建过程" class="headerlink" title="Window的创建过程"></a>Window的创建过程</h3><p>我们知道View是依附在Window上的。换句话说有View的地方就有Window。所以Activity、Dialog和Toast都是依附在Window之上的。所以我们来看看这三者的创建过程。</p>
<h4 id="Activity的Window创建过程"><a href="#Activity的Window创建过程" class="headerlink" title="Activity的Window创建过程"></a>Activity的Window创建过程</h4><p>Activity的Window的创建过程会牵扯到Activity的启动流程。启动流程比较复杂，最后会通过ActivityThread得performLaunchActivity去启动Activity。在此方法中会调用attach方法，为其关联一系列的上下文变量。我们来看看Activity的attch方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">   `···</span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">    mWindow.setColorMode(info.colorMode);</span><br></pre></td></tr></table></figure>
<p>可以看出Window的具体实现类是PhoneWindow。到这边其实Window就已经创建完成了，Activity会调用setContentView将Window显示出来。</p>
<h4 id="Dialog的Window创建过程"><a href="#Dialog的Window创建过程" class="headerlink" title="Dialog的Window创建过程"></a>Dialog的Window创建过程</h4><p>Dialog的创建过程基本和Activity类似，具体我们来看Window的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dialog(<span class="meta">@NonNull</span> Context context, <span class="meta">@StyleRes</span> <span class="keyword">int</span> themeResId, <span class="keyword">boolean</span> createContextThemeWrapper) &#123;</span><br><span class="line">      <span class="keyword">if</span> (createContextThemeWrapper) &#123;</span><br><span class="line">          <span class="keyword">if</span> (themeResId == ResourceId.ID_NULL) &#123;</span><br><span class="line">              <span class="keyword">final</span> TypedValue outValue = <span class="keyword">new</span> TypedValue();</span><br><span class="line">              context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, <span class="keyword">true</span>);</span><br><span class="line">              themeResId = outValue.resourceId;</span><br><span class="line">          &#125;</span><br><span class="line">          mContext = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mContext = context;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Window w = <span class="keyword">new</span> PhoneWindow(mContext);</span><br><span class="line">      mWindow = w;</span><br><span class="line">      w.setCallback(<span class="keyword">this</span>);</span><br><span class="line">      w.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">      w.setOnWindowSwipeDismissedCallback(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (mCancelable) &#123;</span><br><span class="line">              cancel();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      w.setWindowManager(mWindowManager, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      w.setGravity(Gravity.CENTER);</span><br><span class="line"></span><br><span class="line">      mListenersHandler = <span class="keyword">new</span> ListenersHandler(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这边同样是通过PhoneWindow去创建的，创建完成后，依旧是通过setContentView去添加指定布局。我们在来看看show方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">···</span><br><span class="line">  mDecor = mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mActionBar == <span class="keyword">null</span> &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">            <span class="keyword">final</span> ApplicationInfo info = mContext.getApplicationInfo();</span><br><span class="line">            mWindow.setDefaultIcon(info.icon);</span><br><span class="line">            mWindow.setDefaultLogo(info.logo);</span><br><span class="line">            mActionBar = <span class="keyword">new</span> WindowDecorActionBar(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WindowManager.LayoutParams l = mWindow.getAttributes();</span><br><span class="line">        <span class="keyword">if</span> ((l.softInputMode</span><br><span class="line">                &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == <span class="number">0</span>) &#123;</span><br><span class="line">            WindowManager.LayoutParams nl = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">            nl.copyFrom(l);</span><br><span class="line">            nl.softInputMode |=</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">            l = nl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindowManager.addView(mDecor, l);</span><br><span class="line">        mShowing = <span class="keyword">true</span>;</span><br><span class="line">···</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看出，在show的时候，它会拿到decorView，然后将DecorView添加到WindowManager中去。</p>
<h4 id="Toast的Window创建过程"><a href="#Toast的Window创建过程" class="headerlink" title="Toast的Window创建过程"></a>Toast的Window创建过程</h4><p>Toast和Window、Activity的区别就是它具有定时取消的功能，所以其内部有两组IPC过程，一个是INotificationManager，其通过getService拿到一个NotificationManagerService也就是NMS。第二这是NMS的回调也就是TN。具体的实现，我们来看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mNextView == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;setView must have been called&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       INotificationManager service = getService();</span><br><span class="line">       String pkg = mContext.getOpPackageName();</span><br><span class="line">       TN tn = mTN;</span><br><span class="line">       tn.mNextView = mNextView;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           service.enqueueToast(pkg, tn, mDuration);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">           <span class="comment">// Empty</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mTN.cancel();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这边主要是通过NMS像TN进行一个回调。我们来看看TN的handler处理了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mHandler = <span class="keyword">new</span> Handler(looper, <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SHOW: &#123;</span><br><span class="line">                        IBinder token = (IBinder) msg.obj;</span><br><span class="line">                        handleShow(token);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> HIDE: &#123;</span><br><span class="line">                        handleHide();</span><br><span class="line">                        <span class="comment">// Don&#x27;t do this in handleHide() because it is also invoked by</span></span><br><span class="line">                        <span class="comment">// handleShow()</span></span><br><span class="line">                        mNextView = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> CANCEL: &#123;</span><br><span class="line">                        handleHide();</span><br><span class="line">                        <span class="comment">// Don&#x27;t do this in handleHide() because it is also invoked by</span></span><br><span class="line">                        <span class="comment">// handleShow()</span></span><br><span class="line">                        mNextView = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            getService().cancelToast(mPackageName, TN.<span class="keyword">this</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以发现其通过handleShow以及handleHide去显示和影藏，我们可以看到在handleShow中他会将Toast的视图去添加到Window中去，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">···</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mWM.addView(mView, mParams);</span><br><span class="line">    trySendAccessibilityEvent();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WindowManager.BadTokenException e) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而在handleHide方法中，它会将当前窗口给移除掉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mView.getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Log.v(TAG, <span class="string">&quot;REMOVE! &quot;</span> + mView + <span class="string">&quot; in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">        mWM.removeViewImmediate(mView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>任何 View 都是附属在一个Window上面的，Window表示一个窗口的概念，也是一个抽象的概念，Window 并不是实际存在的，它是以View的形式存在的。WindowManager 是外界也就是我们访问Window的入口，Window的具体实现位于WindowManagerService 中，WindowManagerService 和 WindowManager 的交互是一个 IPC 过程。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/data_structure/red_and_black_tree/</url>
    <content><![CDATA[<p>红黑树和平衡二叉树的思想是类似的，都是在插入过程中对二叉排序树进行调整，从而提升性能，它的增删改查均可以在O(lg n)内完成。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>红黑树是一棵二叉排序树。且满足以下特点：</p>
<ul>
<li><p>节点是红色或黑色。</p>
</li>
<li><p>根节点是黑色。</p>
</li>
<li><p>每个叶子节点都是黑色的空节点（NIL节点）。</p>
</li>
<li><p>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。</p>
</li>
<li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
</li>
</ul>
<p>下图就是一棵简单的红黑树示例：<br><img src="https://img-blog.csdnimg.cn/20200604234313694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>示例中每个结点最后都是一个NIL结点，它是黑色的，不过我们画图时通常会省略它。所以下文以及后续文章中绘制时都会省略NIL结点，大家记得还有它就可以。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>红黑树的插入与删除和AVL树类似，也是每插入一个结点，都检查是否破坏了树的结构，然后进行调整。红黑树每个结点插入时默认都为红色，这样做可以降低黑高，也可以减少调整的次数。</p>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>红黑树的概念理解起来较为复杂，我们以一个简单的示例，看看如何构造一棵红黑树。</p>
<p>现有数组int[] a = {1, 10, 9, 2, 3, 8, 7, 4, 5, 6};我们要将其变为一棵红黑树。</p>
<p>首先插入1，此时树是空的，1就是根结点，根结点是黑色的：<br><img src="https://img-blog.csdnimg.cn/202006042343549.png"><br>然后插入元素10，此时依然符合规则，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200604234426203.png"><br>当插入元素9时，这时是需要调整的第一种情况，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200604234604991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>红黑树规则4中强调不能有两个相邻的红色结点，所以此时我们需要对其进行调整。调整的原则有多个相关因素，这里的情况是，父结点10是其祖父结点1（父结点的父结点）的右孩子，当前结点9是其父结点10的左孩子，且没有叔叔结点（父结点的兄弟结点），此时需要进行两次旋转，第一次，以父结点10右旋：<br><img src="https://img-blog.csdnimg.cn/20200604234653898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>然后将父结点（此时是9）染为黑色，祖父结点1染为红色，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604234726279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>然后以祖父结点1左旋：<br><img src="https://img-blog.csdnimg.cn/20200604234801183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>下一步，插入元素2，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200604234831311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>此时情况与上一步类似，区别在于父结点1是祖父结点9的左孩子，当前结点2是父结点的右孩子，且叔叔结点10是红色的。这时需要先将叔叔结点10染为黑色，再进行下一步操作，具体做法是将父结点1和叔叔结点10染为黑色，祖父结点9染为红色，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604234913248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>由于结点9是根节点，必须为黑色，将它染为黑色即可：<br><img src="https://img-blog.csdnimg.cn/20200604234945664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>下一步，插入元素3，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604235026982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>这和我们之前插入元素10的情况一模一样，需要将父结点2染为黑色，祖父结点1染为红色，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604235106297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>然后左旋：<br><img src="https://img-blog.csdnimg.cn/20200604235140766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>下一步，插入元素8，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200604235214237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70">  </p>
<p>此时和插入元素2有些类似，区别在于父结点3是右孩子，当前结点8也是右孩子，这时也需要先将叔叔结点1染为黑色，具体操作是先将1和3染为黑色，再将祖父结点2染为红色，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604235250905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>此时树已经平衡了，不需要再进行其他操作了，现在插入元素7，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604235321982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>这时和之前插入元素9时一模一样了，先将7和8右旋，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604235351319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>然后将7染为黑色，3染为红色，再进行左旋，结果如下：<br><img src="https://img-blog.csdnimg.cn/2020060423542296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>下一步要插入的元素是4，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200604235451208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>这里和插入元素2是类似的，先将3和8染为黑色，7染为红色，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604235525247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>但此时2和7相邻且颜色均为红色，我们需要对它们继续进行调整。这时情况变为了父结点2为红色，叔叔结点10为黑色，且2为左孩子，7为右孩子，这时需要以2左旋。这时左旋与之前不同的地方在于结点7旋转完成后将有三个孩子，结果类似于下图：<br><img src="https://img-blog.csdnimg.cn/20200604235609567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>这种情况处理起来也很简单，只需要把7原来的左孩子3，变成2的右孩子即可，结果如下：<br><img src="https://img-blog.csdnimg.cn/2020060423563965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>然后再把2的父结点7染为黑色，祖父结点9染为红色。结果如下所示：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200604235709284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>此时又需要右旋了，我们要以9右旋，右旋完成后7又有三个孩子，这种情况和上述是对称的，我们把7原有的右孩子8，变成9的左孩子即可，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604235738345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>下一个要插入的元素是5，插入后如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604235833460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>有了上述一些操作，处理5变得十分简单，将3染为红色，4染为黑色，然后左旋，结果如下所示：  </p>
<p><img src="https://img-blog.csdnimg.cn/2020060423590063.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>最后插入元素6，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200604235928699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>又是叔叔结点3为红色的情况，这种情况我们处理过多次了，首先将3和5染为黑色，4染为红色，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200604235957745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70">  </p>
<p>此时问题向上传递到了元素4，我们看2、4、7、9的颜色和位置关系，这种情况我们也处理过，先将2和9染为黑色，7染为红色，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200605000037707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>最后7是根结点，染为黑色即可，最终结果如下所示：<br><img src="https://img-blog.csdnimg.cn/2020060500011633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>可以看到，在插入元素时，叔叔结点是主要影响因素，待插入结点与父结点的关系决定了是否需要多次旋转。可以总结为以下几种情况：  </p>
<ul>
<li><p>如果父结点是黑色，插入即可，无需调整。  </p>
</li>
<li><p>如果叔叔结点是红色，就把父结点和叔叔结点都转为黑色，祖父结点转为红色，将不平衡向上传递。  </p>
</li>
<li><p>如果叔叔结点是黑色或者没有叔叔结点，就看父结点和待插入结点的关系。如果待插入结点和父结点的关系，与父结点与祖父结点的关系一致，比如待插入结点是父结点的左孩子，父结点也是祖父结点的左孩子，就无需多次旋转。否则就先通过相应的旋转将其关系变为一致。  </p>
</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>要从一棵红黑树中删除一个元素，主要分为三种情况。  </p>
<h4 id="待删除元素没有孩子"><a href="#待删除元素没有孩子" class="headerlink" title="待删除元素没有孩子"></a>待删除元素没有孩子</h4><p>没有孩子指的是没有值不为NIL的孩子。这种情况下，如果删除的元素是红色的，可以直接删除，如果删除的元素是黑色的，就需要进行调整了。</p>
<p>例如我们从下图中删除元素1：<br><img src="https://img-blog.csdnimg.cn/20200605000144385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>删除元素1后，2的左孩子为NIL，这条支路上的黑色结点数就比其他支路少了，所以需要进行调整。  </p>
<p>这时，我们的关注点从叔叔结点转到兄弟结点，也就是结点4，此时4是红色的，就把它染为黑色，把父结点2染为红色，如下所示：<br><img src="https://img-blog.csdnimg.cn/2020060500022268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>然后以2左旋，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200605000305280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>此时兄弟结点为3，且它没有红色的孩子，这时只需要把它染为红色，父结点2染为黑色即可。结果如下所示：<br><img src="https://img-blog.csdnimg.cn/20200605000338313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70">  </p>
<h4 id="待删除元素有一个孩子"><a href="#待删除元素有一个孩子" class="headerlink" title="待删除元素有一个孩子"></a>待删除元素有一个孩子</h4><p>这应该是删除操作中最简单的一种情况了，根据红黑树的定义，我们可以推测，如果一个元素仅有一个孩子，那么这个元素一定是黑色的，而且其孩子是红色的。  </p>
<p>假设我们有一个红色节点，它是树中的某一个节点，且仅有一个孩子，那么根据红色节点不能相邻的条件，它的孩子一定是黑色的，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200605000410994.png">  </p>
<p>但这个子树的黑高却不再平衡了（注意每个节点的叶节点都是一个NIL节点），因此红色节点不可能只有一个孩子。  </p>
<p>而若是一个黑色节点仅有一个孩子，如果其孩子是黑色的，同样会打破黑高的平衡，所以其孩子只能是红色的，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200605000440111.png"><br>只有这一种情况符合红黑树的定义，这时要删除这个元素，只需要使用其孩子代替它，仅代替值而不代替颜色即可，上图的情况删除完后变为：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200605000513512.png"><br>可以看到，树的黑高并没有发生变化，因此也不需要进行调整。  </p>
<h4 id="待删除元素有两个孩子"><a href="#待删除元素有两个孩子" class="headerlink" title="待删除元素有两个孩子"></a>待删除元素有两个孩子</h4><p>我们在讨论二叉排序树时说过，如果删除一个有两个孩子的元素，可以使用它的前驱或者后继结点代替它。因为它的前驱或者后继结点最多只会有一个孩子，所以这种情况可以转为情况1或情况2处理。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>删除元素最复杂的是情况1，这主要由其兄弟结点以及兄弟结点的孩子颜色共同决定。这里简要做下总结。</p>
<p>我们以N代表当前待删除节点，以P代表父结点，以S代表兄弟结点，以SL代表兄弟结点的左孩子，SR代表兄弟结点的右孩子，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200605000548232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>根据红黑树定义，这种情况下S要么有红色的子结点，要么只有NIL结点，以下对S有黑色结点的情况均表示NIL  </p>
<p>主要有以下几种：</p>
<p>1、S是红色，P一定是黑色，S也不会有红色的孩子，如下：<br><img src="https://img-blog.csdnimg.cn/20200605000620842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>此时把P和S颜色变换，再左旋，如下：<br><img src="https://img-blog.csdnimg.cn/20200605000651129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>这样变换后，N支路上的黑色结点并没有增加，所以依然少一个。  </p>
<p>2、P，S以及S的全部孩子都是黑色<br>无论S有几个孩子，或者没有孩子，只要不是红色都是这种情况，此时情况如下：<br><img src="https://img-blog.csdnimg.cn/20200605000719213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>我们把S染为红色，这样一来，N和S两个支路都少了一个黑色结点，所以可以把问题向父结点转移，通过递归解决。染色后如下：<br><img src="https://img-blog.csdnimg.cn/20200605000752525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70">  </p>
<p>3、P为红（S一定为黑），S的孩子都为黑<br>这种情况最为简单，只需要把P和S颜色交换即可。这样N支路多了一个黑色元素，而S支路没有减少，所以达到了平衡。<br><img src="https://img-blog.csdnimg.cn/20200605000827894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200605000900335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70">  </p>
<p>4、P任意色，S为黑，N是P的左孩子，S的右孩子SR为红，S的左孩子任意<br>如下所示<br><img src="https://img-blog.csdnimg.cn/20200605000930320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>此时将S改为P的颜色，SR和P改为黑色，然后左旋，结果如下：  </p>
<p><img src="https://img-blog.csdnimg.cn/20200605001000461.png"><br>可以发现，此时N支路多了一个黑色结点，而其余支路均没有收到影响，所以调整完毕。  </p>
<p>5、P任意色，S为黑，N是P的左孩子，S的左孩子SL为红，S的右孩子SR为黑，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200605001037305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>此时变换S和SL的颜色，然后右旋，结果如下：<br><img src="https://img-blog.csdnimg.cn/20200605001108965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N3OTUwNzI5,size_16,color_FFFFFF,t_70"><br>这时，所有分支的黑色结点数均没有改变，但情况5转为了情况4，再进行一次操作即可。  </p>
<p>还有一些情况与上述是对称的，我们进行相应的转换即可。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>红黑树的操作比较复杂，插入元素可能需要多次变色与旋转，删除也是。这些操作的目的都是为了保证红黑树的结构不被破坏。这些复杂的插入与删除操作希望大家可以亲手尝试一下，以加深理解。  </p>
<p>红黑树是JDK中TreeMap、TreeSet的底层数据结构，在JDK1.8中HashMap也用到了红黑树，所以掌握它对我们后续的分析十分重要。  </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>ViewGroup的源码解读</title>
    <url>/android/view/viewgroup-event/</url>
    <content><![CDATA[<p>我们之前刚刚分析完事件传递机制和view的源码，如果没有看过的，建议看完<a href="http://blog.csdn.net/sw950729/article/details/76662222">View的事件拦截机制浅析</a>以及<a href="http://blog.csdn.net/sw950729/article/details/77649990">View的事件源码解析</a>。这次我们来分析下viewgroup的。</p>
<p>可能有人会想，怎么又是源码分析，肯定又是一大通。其实没你想的那么复杂。仔细分析一波就行了。</p>
<h3 id="解读ViewGroup"><a href="#解读ViewGroup" class="headerlink" title="解读ViewGroup"></a>解读ViewGroup</h3><p>我们都知道，一个事件完整的流程是从dispatchTouchevent–&gt;onInterceptTouchevent–&gt;onTouchEvent。我们先不说事件监听的问题。上述三个步骤就是正常一个点击的流程。前面我们分析view的时候发现它并没有onInterceptTouchevent这个方法。这个我之前有提到，view已经是最底层了，所以就不需要拦截了。而这一整套的机制就是在ViewGroup中体现出来的。我们先来看一张图：<br><img src="https://github.com/LittleFriendsGroup/AndroidSdkSourceAnalysis/raw/master/article/images/viewgroup_touchevent.png" alt="这里写图片描述"></p>
<p>触摸事件发生后，在Activity内最先接收到事件的是Activity自身的dispatchTouchEvent，然后Activity传递给Activity的Window。接着Window传递给最顶端的View，也就是DecorView。接下来才是我们熟悉的触摸事件流程：首先是最顶端的ViewGroup(这边便是DecorView)的dispatchTouchEvent接收到事件。并通过onInterceptTouchEvent判断是否需要拦截。如果拦截则分配到ViewGroup自身的onTouchEvent，如果不拦截则查找位于点击区域的子View(当事件是ACTION_DOWN的时候，会做一次查找并根据查找到的子View设定一个TouchTarget，有了TouchTarget以后，后续的对应id的事件如果不被拦截都会分发给这一个TouchTarget)。查找到子View以后则调用dispatchTransformedTouchEvent把MotionEvent的坐标转换到子View的坐标空间，这不仅仅是x，y的偏移，还包括根据子View自身矩阵的逆矩阵对坐标进行变换(这就是使用setTranslationX,setScaleX等方法调用后，子View的点击区域还能保持和自身绘制内容一致的原因。使用Animation做变换点击区域不同步是因为Animation使用的是Canvas的矩阵而不是View自身的矩阵来做变换)。</p>
<h3 id="dispatchTouchevent分析"><a href="#dispatchTouchevent分析" class="headerlink" title="dispatchTouchevent分析"></a>dispatchTouchevent分析</h3><p>我们先放上dispatchTouchevent的源码，然后一步一步来分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// If the event targets the accessibility focused view and this is it, start</span></span><br><span class="line">       <span class="comment">// normal event dispatch. Maybe a descendant is what will handle the click.</span></span><br><span class="line">       <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">           ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">           <span class="comment">// Handle an initial down.</span></span><br><span class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">               <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">               <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">               <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">               cancelAndClearTouchTargets(ev);</span><br><span class="line">               resetTouchState();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Check for interception.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                   || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                   intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                   ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   intercepted = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">               <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">               intercepted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// If intercepted, start normal event dispatch. Also if there is already</span></span><br><span class="line">           <span class="comment">// a view that is handling the gesture, do normal event dispatch.</span></span><br><span class="line">           <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Check for cancelation.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                   || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">           <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">           TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">               <span class="comment">// If the event is targeting accessiiblity focus we give it to the</span></span><br><span class="line">               <span class="comment">// view that has accessibility focus and if it does not handle it</span></span><br><span class="line">               <span class="comment">// we clear the flag and dispatch the event to all children as usual.</span></span><br><span class="line">               <span class="comment">// We are looking up the accessibility focused host to avoid keeping</span></span><br><span class="line">               <span class="comment">// state since these events are very rare.</span></span><br><span class="line">               View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                       ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                       || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                       || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                           : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line">                   <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                   <span class="comment">// have become out of sync.</span></span><br><span class="line">                   removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                   <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                       <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                       <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                       <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                               &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                       <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                           <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                   childrenCount, i, customOrder);</span><br><span class="line">                           <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                   preorderedList, children, childIndex);</span><br><span class="line">                           <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">                           <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">                           <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">                           <span class="comment">// safer given the timeframe.</span></span><br><span class="line">                           <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                   <span class="keyword">continue</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                               i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                   || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                               ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                               <span class="keyword">continue</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           newTouchTarget = getTouchTarget(child);</span><br><span class="line">                           <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                               <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                               newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           resetCancelNextUpFlag(child);</span><br><span class="line">                           <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                               <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                               mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                               <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                       <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                           mLastTouchDownIndex = j;</span><br><span class="line">                                           <span class="keyword">break</span>;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                   mLastTouchDownIndex = childIndex;</span><br><span class="line">                               &#125;</span><br><span class="line">                               mLastTouchDownX = ev.getX();</span><br><span class="line">                               mLastTouchDownY = ev.getY();</span><br><span class="line">                               newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                               alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// The accessibility focus didn&#x27;t handle the event, so clear</span></span><br><span class="line">                           <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                           ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                       <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                       newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                       <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           newTouchTarget = newTouchTarget.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">           <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                       TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">               <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">               TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">               TouchTarget target = mFirstTouchTarget;</span><br><span class="line">               <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                   <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                       handled = <span class="keyword">true</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                               || intercepted;</span><br><span class="line">                       <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                               target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                           handled = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               mFirstTouchTarget = next;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               predecessor.next = next;</span><br><span class="line">                           &#125;</span><br><span class="line">                           target.recycle();</span><br><span class="line">                           target = next;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   predecessor = target;</span><br><span class="line">                   target = next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">           <span class="keyword">if</span> (canceled</span><br><span class="line">                   || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                   || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">               resetTouchState();</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">               removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> handled;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>是不是整个人都蒙蔽了，这么长一串。其实整段代码可以缩减成几句话，就是这样：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">public</span> boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    <span class="attribute">boolean</span> result = <span class="literal">false</span>;             </span><br><span class="line">    <span class="attribute">if</span> (!<span class="literal">on</span>InterceptTouchEvent(ev)) &#123; </span><br><span class="line">        <span class="attribute">result</span> = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (!result) &#123;                    </span><br><span class="line">        <span class="attribute">result</span> = <span class="literal">on</span>TouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认不消耗事件，如果本身没有拦截，就交给子类的dispatch事件，如果事件没有消费，就调用自身的onTouchEvent事件。你们仔细想想，流程是不是这样的？</p>
<p>好了，我们现在开始分析整个dispatch事件。具体说明和代码，你们自己对应= =因为太长了。</p>
<p><strong>对action_down的处理：</strong><br>我们发现，刚进方法的时候有个判断，第一次按下的时候，他会通过 cancelAndClearTouchTargets(ev)取消并且清除所有的手势操作，并且通过resetTouchState()把手势状态设置成默认状态。</p>
<p>接下来的操作，当然就是检查是否需要拦截事件拉。既然是拦截，当然就会走onInterceptTouchEvent这个方法了。我们来看看，viewgroup的onInterceptTouchEvent方法是怎么处理的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public boolean on<span class="constructor">InterceptTouchEvent(MotionEvent <span class="params">ev</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (ev.is<span class="constructor">FromSource(InputDevice.SOURCE_MOUSE)</span></span><br><span class="line"><span class="operator">               &amp;&amp; </span>ev.get<span class="constructor">Action()</span><span class="operator"> == </span>MotionEvent.ACTION_DOWN</span><br><span class="line"><span class="operator">               &amp;&amp; </span>ev.is<span class="constructor">ButtonPressed(MotionEvent.BUTTON_PRIMARY)</span></span><br><span class="line"><span class="operator">               &amp;&amp; </span>is<span class="constructor">OnScrollbarThumb(<span class="params">ev</span>.<span class="params">getX</span>()</span>, ev.get<span class="constructor">Y()</span>)) &#123;</span><br><span class="line">           return <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       return <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，他默认就是false的。那么我们继续回到dispatch看。判断是否拦截后，我们发现他还执行了一句话<code> ev.setAction(action)</code> 官方说明是恢复操作，防止被更改。</p>
<p><strong>事件处理</strong><br>接下来就是检查事件是否取消咯。如果没有取消并且没有拦截就执行正常的事件处理。</p>
<p> 如果事件是针对可访问性焦点视图，我们将其提供给具有可访问性焦点的视图。如果它不处理它，我们清除该标志并像往常一样将事件分派给所有的 ChildView。我们检测并避免保持这种状态，因为这些事非常罕见。这段是官方的解释。我们继续向下看，他执行这样一个方法removePointersFromTouchTargets(idBitsToAssign)。是为了防止指针不同步，清除之前的触摸标识。自我认为可能会和多指触控有关，先不管他，我们继续向下分析。</p>
<p>接下来就是打造了，他会先得到触摸点的坐标位置，然后在当前位置查找可接触的ChildView。然后重点！！！他的查找顺序是从后向前查找。什么意思呢？就是如果A和B有重叠的部分，并且B在A的上面，那么他处理的便是B的事件了。而不处理A的事件。</p>
<p>如果子View可以接受事件，那么我们就给他一个触摸的标识。接下来他会通过调用dispatchTransformedTouchEvent把事件分配给子View。</p>
<p>最后他会判断是否有touchtarget。如果没有的话，那就处理子view的事件。否则就会遍历touchtarget处理事件，也就是之前说的多点触控。在往后就是对action_up和cancel做的一些处理了，譬如：重置手势状态，移除多指操作等等。</p>
<h3 id="dispatchTransformedTouchEvent分析"><a href="#dispatchTransformedTouchEvent分析" class="headerlink" title="dispatchTransformedTouchEvent分析"></a>dispatchTransformedTouchEvent分析</h3><p>前面我们说到了，会通过这个方法把事件分发给子view。我们还是先来看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="comment">// Canceling motions is a special case.  We don&#x27;t need to perform any transformations</span></span><br><span class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Calculate the number of pointers to deliver.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line">    <span class="comment">// If for some reason we ended up in an inconsistent state where it looks like we</span></span><br><span class="line">    <span class="comment">// might produce a motion event with no pointers in it, then drop the event.</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the number of pointers is the same and we don&#x27;t need to perform any fancy</span></span><br><span class="line">    <span class="comment">// irreversible transformations, then we can reuse the motion event for this</span></span><br><span class="line">    <span class="comment">// dispatch as long as we are careful to revert any changes we make.</span></span><br><span class="line">    <span class="comment">// Otherwise we need to make a copy.</span></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就比之前简单很多了。我们会发现，他先判断状态是否取消，如果取消了，把当前事件变成取消状态，然后在判断是否有子view。如果有子view的话直接调用子view的dispatch事件。下面就是多指了，一个pointer对应一个ID，防止处理冲突。我印象中能简单粗暴的处理多指，应该是ViewDragHelper了。具体，你们可以自己去看。后面就如之前一样，判断child是否为null。然后得到是执行自身的事件还是child的事件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.ViewGroup包涵多个子view的时候，我们是从后遍历，判断当前view是否可以点击，然后分发给需要处理的子view。<br>2.我们可以在onInterceptTouchEvent中进行事件拦截。<br>3.我们可以发现ViewGroup没有onTouchEvent事件，说明他的处理逻辑和View是一样的。<br>4.子view如果消耗了事件，那么ViewGroup就不会在接受到事件了。</p>
<p>最后我放上<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/view/ViewGroup.java">ViewGroup源码</a>，你们可以自己去了解。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title>OkHttp源码分析</title>
    <url>/android/okhttp/</url>
    <content><![CDATA[<blockquote>
<p>本文基于OkHttp 4.9.0分析</p>
</blockquote>
<h3 id="OkHttp是什么？"><a href="#OkHttp是什么？" class="headerlink" title="OkHttp是什么？"></a>OkHttp是什么？</h3><p>众所周知，OkHttp是一个客户端用来发送HTTP消息并对服务器的响应做出处理的应用层框架。而且现在流行的Retrofit的底层同样也是基于Okhttp的。那么OkHttp有什么优点呢？我们来看下：</p>
<ul>
<li>无缝的支持GZIP减少数据流量</li>
<li>缓存响应数据减少重复的网络请求</li>
<li>请求失败自动重试主机的其他ip，自动重定向。</li>
<li>如果 HTTP/2 不可用, 使用连接池复用减少请求延迟。</li>
<li>……</li>
</ul>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"><span class="comment">//同步</span></span><br><span class="line">Response response = client.newCall(request).execute()；</span><br><span class="line"><span class="comment">//异步</span></span><br><span class="line">Response response = client.newCall(request).enqueue()；</span><br></pre></td></tr></table></figure>
<p>我们可以看到同步和异步是调用Call的execute和enqueue方法，我们来看下具体的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">   check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">   timeout.enter()</span><br><span class="line">   callStart()</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">     <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">   check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line">   callStart()</span><br><span class="line">   client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，不管是同步还是异步，都会使用dispatcher，也就是任务分发器。</p>
<h3 id="Dispatcher分发器"><a href="#Dispatcher分发器" class="headerlink" title="Dispatcher分发器"></a>Dispatcher分发器</h3><p>前面我们说到了不管同步还是异步，都会使用dispatcher，dispatcher内部会有一个线程池，也就是使用异步请求的时候我们会用到的。我们先来看下Dispatcher内部基本的成员变量：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步请求的最大数量</span></span><br><span class="line"><span class="keyword">var</span> maxRequests = <span class="number">64</span></span><br><span class="line"><span class="comment">//每个主机同时请求的最大数量</span></span><br><span class="line"><span class="keyword">var</span> maxRequestsPerHost = <span class="number">5</span></span><br><span class="line"><span class="comment">//闲置任务</span></span><br><span class="line"><span class="keyword">var</span> idleCallback: Runnable? = <span class="literal">null</span></span><br><span class="line"><span class="comment">//异步请求线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> executorServiceOrNull: ExecutorService? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> executorService: ExecutorService</span><br><span class="line"><span class="comment">//异步请求等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">//异步请求执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"><span class="comment">//同步请求执行队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()</span><br></pre></td></tr></table></figure>
<h4 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">executed</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">   runningSyncCalls.add(call)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>因为是同步请求，所以无需做任何操作，只需要把执行的callback放入同步队列中即可。</p>
<h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      readyAsyncCalls.add(call)</span><br><span class="line">      <span class="keyword">if</span> (!call.call.forWebSocket) &#123;</span><br><span class="line">        <span class="keyword">val</span> existingCall = findExistingCallWithHost(call.host)</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到执行异步请求的时候，我们先把请求放入等待队列中，然后调用promoteAndExecute。我们看下这段代码是用来干什么的？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">promoteAndExecute</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.assertThreadDoesntHoldLock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">    <span class="keyword">val</span> isRunning: <span class="built_in">Boolean</span></span><br><span class="line">    synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> i = readyAsyncCalls.iterator()</span><br><span class="line">      <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> asyncCall = i.next()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size &gt;= <span class="keyword">this</span>.maxRequests) <span class="keyword">break</span> <span class="comment">// Max capacity.</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCall.callsPerHost.<span class="keyword">get</span>() &gt;= <span class="keyword">this</span>.maxRequestsPerHost) <span class="keyword">continue</span> <span class="comment">// Host max capacity.</span></span><br><span class="line">        </span><br><span class="line">        i.remove()</span><br><span class="line">        asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">        executableCalls.add(asyncCall)</span><br><span class="line">        runningAsyncCalls.add(asyncCall)</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until executableCalls.size) &#123;</span><br><span class="line">      <span class="keyword">val</span> asyncCall = executableCalls[i]</span><br><span class="line">      asyncCall.executeOn(executorService)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当正在执行的请求没有超过最大请求数64个时，并且同一个host的请求没有超过5个时，将它加入到执行队列。开始执行。 </p>
<p>当请求执行完成后，还会调用分发器当finish方法，我们看下finish方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Used by [AsyncCall.run] to signal completion. */</span></span><br><span class="line"> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">AsyncCall</span>)</span></span> &#123;</span><br><span class="line">   call.callsPerHost.decrementAndGet()</span><br><span class="line">   finished(runningAsyncCalls, call)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** Used by [Call.execute] to signal completion. */</span></span><br><span class="line"> <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">finished</span><span class="params">(call: <span class="type">RealCall</span>)</span></span> &#123;</span><br><span class="line">   finished(runningSyncCalls, call)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">finished</span><span class="params">(calls: <span class="type">Deque</span>&lt;<span class="type">T</span>&gt;, call: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> idleCallback: Runnable?</span><br><span class="line">   synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> AssertionError(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>)</span><br><span class="line">     idleCallback = <span class="keyword">this</span>.idleCallback</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> isRunning = promoteAndExecute()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">     idleCallback.run()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>不管同步还是异步，执行完成后，都需要从队列中移除，然后判断是否有正在执行的任务，如果没有的话，就执行闲置任务。</p>
<h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><p>前面梳理了分发器的同步和异步操作，但是真正的请求流程还是在RealCall中。我们来看下它的同步和异步方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">   check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">   timeout.enter()</span><br><span class="line">   callStart()</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">     <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到同步请求直接return了<code>getResponseWithInterceptorChain()</code>方法。我们在看看异步的请求：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(responseCallback: <span class="type">Callback</span>)</span></span> &#123;</span><br><span class="line">    check(executed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123; <span class="string">&quot;Already Executed&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    callStart()</span><br><span class="line">    client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在异步请求的时候丢给了AsyncCall去处理。而AsyncCall是一个Runnable。我们直接看看它的run方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">     threadName(<span class="string">&quot;OkHttp <span class="subst">$&#123;redactedUrl()&#125;</span>&quot;</span>) &#123;</span><br><span class="line">       <span class="keyword">var</span> signalledCallback = <span class="literal">false</span></span><br><span class="line">       timeout.enter()</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">val</span> response = getResponseWithInterceptorChain()</span><br><span class="line">         signalledCallback = <span class="literal">true</span></span><br><span class="line">         responseCallback.onResponse(<span class="keyword">this</span><span class="symbol">@RealCall</span>, response)</span><br><span class="line">       &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">         <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">           <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">           Platform.<span class="keyword">get</span>().log(<span class="string">&quot;Callback failure for <span class="subst">$&#123;toLoggableString()&#125;</span>&quot;</span>, Platform.INFO, e)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, e)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (t: Throwable) &#123;</span><br><span class="line">         cancel()</span><br><span class="line">         <span class="keyword">if</span> (!signalledCallback) &#123;</span><br><span class="line">           <span class="keyword">val</span> canceledException = IOException(<span class="string">&quot;canceled due to <span class="variable">$t</span>&quot;</span>)</span><br><span class="line">           canceledException.addSuppressed(t)</span><br><span class="line">           responseCallback.onFailure(<span class="keyword">this</span><span class="symbol">@RealCall</span>, canceledException)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> t</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里也是<code>getResponseWithInterceptorChain()</code>去拿到它的response。而OkHttp中最核心的也就是这个方法，处理了各种拦截器的逻辑。</p>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>无论同异步请求都会调用到<code>getResponseWithInterceptorChain()</code>，这个方法主要使用责任链模式将整个请求分为几个拦截器调用，简化了各自的责任和逻辑，而且还可以扩展一些自定义的拦截器。如果不清楚责任链模式，请先查看<a href="https://silence.blog.csdn.net/article/details/85005112">设计模式之责任链模式</a>。</p>
<h4 id="如何进行拦截"><a href="#如何进行拦截" class="headerlink" title="如何进行拦截"></a>如何进行拦截</h4><p>前面说到了责任链模式，那我们看下RealCall中是如何进行责任链形式的调用，其实主要方法是在RealInterceptorChain中。我们看下这个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">proceed</span><span class="params">(request: <span class="type">Request</span>)</span></span>: Response &#123;</span><br><span class="line">  check(index &lt; interceptors.size)</span><br><span class="line"></span><br><span class="line">  calls++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">    check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must retain the same host and port&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(calls == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="subst">$&#123;interceptors[index - <span class="number">1</span>]&#125;</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//注释1</span></span><br><span class="line">  <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">  <span class="keyword">val</span> next = copy(index = index + <span class="number">1</span>, request = request)</span><br><span class="line">  <span class="keyword">val</span> interceptor = interceptors[index]</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Suppress(<span class="meta-string">&quot;USELESS_ELVIS&quot;</span>)</span></span><br><span class="line">  <span class="keyword">val</span> response = interceptor.intercept(next) ?: <span class="keyword">throw</span> NullPointerException(</span><br><span class="line">      <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned null&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">    check(index + <span class="number">1</span> &gt;= interceptors.size || next.calls == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="string">&quot;network interceptor <span class="variable">$interceptor</span> must call proceed() exactly once&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check(response.body != <span class="literal">null</span>) &#123; <span class="string">&quot;interceptor <span class="variable">$interceptor</span> returned a response with no body&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到注释1处，拿到下一级的拦截器，不断执行它的intercept方法，最后return response 然后一层一层向上反馈数据。</p>
<h4 id="拦截器分析"><a href="#拦截器分析" class="headerlink" title="拦截器分析"></a>拦截器分析</h4><p>现在我们来看下拦截器具体的逻辑，直接查看<code>getResponseWithInterceptorChain()</code>这个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">  <span class="comment">//自定义的拦截器</span></span><br><span class="line">  interceptors += client.interceptors</span><br><span class="line">  <span class="comment">//处理重定向的后续请求和失败重试</span></span><br><span class="line">  interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">  <span class="comment">//补全请求，处理网络桥接的</span></span><br><span class="line">  interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">  <span class="comment">//处理缓存的</span></span><br><span class="line">  interceptors += CacheInterceptor(client.cache)</span><br><span class="line">  <span class="comment">//处理tcp链接的</span></span><br><span class="line">  interceptors += ConnectInterceptor</span><br><span class="line">  <span class="comment">//处理网络的</span></span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors += client.networkInterceptors</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理服务器通信，并封装请求数据与解析响应数据</span></span><br><span class="line">  interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">      call = <span class="keyword">this</span>,</span><br><span class="line">      interceptors = interceptors,</span><br><span class="line">      index = <span class="number">0</span>,</span><br><span class="line">      exchange = <span class="literal">null</span>,</span><br><span class="line">      request = originalRequest,</span><br><span class="line">      connectTimeoutMillis = client.connectTimeoutMillis,</span><br><span class="line">      readTimeoutMillis = client.readTimeoutMillis,</span><br><span class="line">      writeTimeoutMillis = client.writeTimeoutMillis</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> calledNoMoreExchanges = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">    <span class="keyword">if</span> (isCanceled()) &#123;</span><br><span class="line">      response.closeQuietly()</span><br><span class="line">      <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">throw</span> noMoreExchanges(e) <span class="keyword">as</span> Throwable</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      noMoreExchanges(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h5><p>这个拦截器主要处理重试以及重定向的，一般情况下，第一次请求不会涉及到，我们先来看下重试的方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      response = realChain.proceed(request)</span><br><span class="line">      newExchangeFinder = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">      <span class="comment">// 尝试通过路由链接失败，请求不会发送</span></span><br><span class="line">      <span class="keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        recoveredFailures += e.firstConnectException</span><br><span class="line">      &#125;</span><br><span class="line">      newExchangeFinder = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      <span class="comment">// 与服务器通信的时候发生了异常，请求可能已经发送了</span></span><br><span class="line">      <span class="keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="keyword">is</span> ConnectionShutdownException)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.withSuppressed(recoveredFailures)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        recoveredFailures += e</span><br><span class="line">      &#125;</span><br><span class="line">      newExchangeFinder = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到两个异常都是根据recover方法判断是否能够进行重试，如果返回true，则表示允许重试。那么我们来看下recover方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">( e: <span class="type">IOException</span>, call: <span class="type">RealCall</span>, userRequest: <span class="type">Request</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    requestSendStarted: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 本身设置了不允许重试</span></span><br><span class="line">    <span class="keyword">if</span> (!client.retryOnConnectionFailure) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没法再次发送请求</span></span><br><span class="line">    <span class="keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是重试的异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有其他路径进行链接</span></span><br><span class="line">    <span class="keyword">if</span> (!call.retryAfterFailure()) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// For failure recovery, use the same route selector with a new connection.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果请求结束没有出现异常，不代表当前的响应就是最终交互的，因为我们还需要判断是否需要重定向，而重定向的方法是followUpRequest。我们来看一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">followUpRequest</span><span class="params">(userResponse: <span class="type">Response</span>, exchange: <span class="type">Exchange</span>?)</span></span>: Request? &#123;</span><br><span class="line">   <span class="keyword">val</span> route = exchange?.connection?.route()</span><br><span class="line">   <span class="keyword">val</span> responseCode = userResponse.code</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> method = userResponse.request.method</span><br><span class="line">   <span class="keyword">when</span> (responseCode) &#123;</span><br><span class="line">   <span class="comment">//407：使用了代理服务器，让代理服务器授权</span></span><br><span class="line">     HTTP_PROXY_AUTH -&gt; &#123;</span><br><span class="line">       <span class="keyword">val</span> selectedProxy = route!!.proxy</span><br><span class="line">       <span class="keyword">if</span> (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">         <span class="keyword">throw</span> ProtocolException(<span class="string">&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> client.proxyAuthenticator.authenticate(route, userResponse)</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//401：未经授权，进行授权</span></span><br><span class="line">     HTTP_UNAUTHORIZED -&gt; <span class="keyword">return</span> client.authenticator.authenticate(route, userResponse)</span><br><span class="line">   <span class="comment">//300，301，302，303，307，308： 需要重定向，进行重定向操作。</span></span><br><span class="line">     HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT, HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -&gt; &#123;</span><br><span class="line">       <span class="keyword">return</span> buildRedirectRequest(userResponse, method)</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">// 408 ：请求超时</span></span><br><span class="line">     HTTP_CLIENT_TIMEOUT -&gt; &#123;</span><br><span class="line">     <span class="comment">//如果客户端不允许，直接返回null</span></span><br><span class="line">       <span class="keyword">if</span> (!client.retryOnConnectionFailure) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果尝试了，还是失败，就不管了，返回null</span></span><br><span class="line">       <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">       <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">       <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_CLIENT_TIMEOUT) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果服务器告诉我们重试时间，我们也不管了，返回null</span></span><br><span class="line">       <span class="keyword">if</span> (retryAfter(userResponse, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> userResponse.request</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//503：服务不可用，但是只在服务器告诉你 Retry-After：0（意思就是立即重试） 才重请求</span></span><br><span class="line">     HTTP_UNAVAILABLE -&gt; &#123;</span><br><span class="line">       <span class="keyword">val</span> priorResponse = userResponse.priorResponse</span><br><span class="line">       <span class="keyword">if</span> (priorResponse != <span class="literal">null</span> &amp;&amp; priorResponse.code == HTTP_UNAVAILABLE) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (retryAfter(userResponse, Integer.MAX_VALUE) == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> userResponse.request</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">     &#125;</span><br><span class="line">   <span class="comment">//421：即使域名不同，Okhttp还是可以合并Http2链接，当返回421时，可以用其他链接进行重试。</span></span><br><span class="line">     HTTP_MISDIRECTED_REQUEST -&gt; &#123;</span><br><span class="line">       <span class="keyword">val</span> requestBody = userResponse.request.body</span><br><span class="line">       <span class="keyword">if</span> (requestBody != <span class="literal">null</span> &amp;&amp; requestBody.isOneShot()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (exchange == <span class="literal">null</span> || !exchange.isCoalescedConnection) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       exchange.connection.noCoalescedConnections()</span><br><span class="line">       <span class="keyword">return</span> userResponse.request</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">else</span> -&gt; <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>讲了这么多，其实就是如果此方法返回空，那就表示不需要再重定向了，直接返回响应；但是如果返回非空，那就要重新请求返回的Request。</p>
<h5 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h5><p>桥接拦截器，其实就是http的请求头，每个网络请求都会有相关请求头才会最终到达服务器。这里不过多介绍。当前拦截器用到的请求头说明如下：</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Type</td>
<td>请求体类型</td>
</tr>
<tr>
<td>Content-Length/Transfer-Encoding</td>
<td>请求体解析方式</td>
</tr>
<tr>
<td>Host</td>
<td>请求的主机站点</td>
</tr>
<tr>
<td>Connection: Keep-Alive</td>
<td>保持长连接</td>
</tr>
<tr>
<td>Accept-Encoding: gzip</td>
<td>接受响应支持gzip压缩</td>
</tr>
<tr>
<td>Cookie</td>
<td>cookie身份辨别</td>
</tr>
<tr>
<td>User-Agent</td>
<td>请求的用户信息</td>
</tr>
</tbody></table>
<h5 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h5><p>缓存拦截器，主要是做缓存相关的处理，如果本地存在缓存，并且发送时命中了缓存逻辑，就可以直接使用缓存的response。那么我们看下它的intercept方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">val</span> call = chain.call()</span><br><span class="line">    <span class="keyword">val</span> cacheCandidate = cache?.<span class="keyword">get</span>(chain.request())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">    <span class="keyword">val</span> networkRequest = strategy.networkRequest</span><br><span class="line">    <span class="keyword">val</span> cacheResponse = strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">    cache?.trackResponse(strategy)</span><br><span class="line">    <span class="keyword">val</span> listener = (call <span class="keyword">as</span>? RealCall)?.eventListener ?: EventListener.NONE</span><br><span class="line">    <span class="comment">//如果缓存的request不为空，缓存的response为空，则就不适用。直接关闭</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果网络request为空，缓存response为空，则算是禁用了网络，直接返回504，超时</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Response.Builder()</span><br><span class="line">          .request(chain.request())</span><br><span class="line">          .protocol(Protocol.HTTP_1_1)</span><br><span class="line">          .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">          .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.satisfactionFailure(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果网络request为空，缓存response不为空，直接使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cacheResponse!!.newBuilder()</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .build().also &#123;</span><br><span class="line">            listener.cacheHit(call, it)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果网络request不为空，缓存也不为空，通知命中缓存，如果缓存为空，并且Cache不为空，通知缓存丢失。</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheConditionalHit(call, cacheResponse)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">      listener.cacheMiss(call)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> networkResponse: Response? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      networkResponse = chain.proceed(networkRequest)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;　　　　  </span><br><span class="line">      <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheCandidate.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果网络请求的response拿到的code是304，则证明未修改，更新至缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">        <span class="keyword">val</span> response = cacheResponse.newBuilder()</span><br><span class="line">            .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">        networkResponse.body!!.close()</span><br><span class="line">        cache!!.trackConditionalCacheHit()</span><br><span class="line">        cache.update(cacheResponse, response)</span><br><span class="line">        <span class="keyword">return</span> response.also &#123;</span><br><span class="line">          listener.cacheHit(call, it)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cacheResponse.body?.closeQuietly()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> response = networkResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//判断是否具有主体 并且 是否可以缓存供后续使用</span></span><br><span class="line">      <span class="keyword">if</span> (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">        <span class="comment">//加入缓存</span></span><br><span class="line">        <span class="keyword">val</span> cacheRequest = cache.put(response)</span><br><span class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response).also &#123;</span><br><span class="line">          <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">            listener.cacheMiss(call)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//如果请求方法无效 就从缓存中remove掉</span></span><br><span class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cache.remove(networkRequest)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (_: IOException) &#123;</span><br><span class="line">          <span class="comment">// The cache cannot be written.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>缓存拦截器的操作相对来说比较简单，只是稍微有点绕。真正是否可以缓存还是请求服务端都是通过CacheStrategy去判断的。也就是缓存拦截器中的这行代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br></pre></td></tr></table></figure>
<p>我们直接进去看看：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeCandidate</span><span class="params">()</span></span>: CacheStrategy &#123;</span><br><span class="line">      <span class="comment">// 不存在缓存，直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果缺少必要的握手，直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (request.isHttps &amp;&amp; cacheResponse.handshake == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据响应头判断是否需要返回</span></span><br><span class="line">      <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> requestCaching = request.cacheControl</span><br><span class="line">      <span class="comment">//如果没有缓存，或者用户没有指定缓存，就直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> responseCaching = cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获得缓存的响应从创建到现在的时间</span></span><br><span class="line">      <span class="keyword">val</span> ageMillis = cacheResponseAge()</span><br><span class="line">      <span class="comment">//获取这个响应有效缓存的时长</span></span><br><span class="line">      <span class="keyword">var</span> freshMillis = computeFreshnessLifetime()</span><br><span class="line">      <span class="comment">//如果请求中指定了 max-age 表示指定了能拿的缓存有效时长，就需要综合响应有效缓存时长与请求能拿缓存的时长，获得最小的能够使用响应缓存的时长</span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.maxAgeSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        freshMillis = minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> minFreshMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="comment">//请求认为的缓存有效时间</span></span><br><span class="line">      <span class="keyword">if</span> (requestCaching.minFreshSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Cache-Control:must-revalidate 可缓存但必须再向源服务器进行确认</span></span><br><span class="line">    <span class="comment">//Cache-Control:max-stale 缓存过期后还能使用指定的时长，如果未指定多少秒，则表示无论过期多长时间都可以；如果指定了，则只要是指定时间内就能使用缓存</span></span><br><span class="line">	<span class="comment">// 前者会忽略后者，所以判断了不必须向服务器确认，再获得请求头中的max-stale</span></span><br><span class="line">      <span class="keyword">var</span> maxStaleMillis: <span class="built_in">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds != -<span class="number">1</span>) &#123;</span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//不需要与服务器验证有效性 &amp;&amp; 响应存在的时间+请求认为的缓存有效时间 &lt; 缓存有效时长+过期后还可以使用的时间</span></span><br><span class="line">      <span class="comment">//可以使用缓存</span></span><br><span class="line">      <span class="keyword">if</span> (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = cacheResponse.newBuilder()</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span></span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">          builder.addHeader(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CacheStrategy(<span class="literal">null</span>, builder.build())</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">val</span> conditionName: String</span><br><span class="line">      <span class="keyword">val</span> conditionValue: String?</span><br><span class="line">      <span class="keyword">when</span> &#123;</span><br><span class="line">        etag != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-None-Match&quot;</span></span><br><span class="line">          conditionValue = etag</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastModified != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">          conditionValue = lastModifiedString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        servedDate != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">          conditionName = <span class="string">&quot;If-Modified-Since&quot;</span></span><br><span class="line">          conditionValue = servedDateString</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">return</span> CacheStrategy(request, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> conditionalRequestHeaders = request.headers.newBuilder()</span><br><span class="line">      conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> conditionalRequest = request.newBuilder()</span><br><span class="line">          .headers(conditionalRequestHeaders.build())</span><br><span class="line">          .build()</span><br><span class="line">      <span class="keyword">return</span> CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h5><p>此拦截器负责建⽴连接。包含了⽹络请求所需要的TCP连接(HTTP)，或者TCP之前的TLS连接(HTTPS)，并且会创建出对应的HttpCodec对象(⽤于编码解码HTTP请求)。我们来看下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line"><span class="keyword">val</span> exchange = realChain.call.initExchange(chain)</span><br><span class="line"><span class="keyword">val</span> connectedChain = realChain.copy(exchange = exchange)</span><br><span class="line"><span class="keyword">return</span> connectedChain.proceed(realChain.request)</span><br></pre></td></tr></table></figure>
<p>嗯？怎么就四行代码，我们继续往下看RealCall的initExchange方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">initExchange</span><span class="params">(chain: <span class="type">RealInterceptorChain</span>)</span></span>: Exchange &#123;</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    check(expectMoreExchanges) &#123; <span class="string">&quot;released&quot;</span> &#125;</span><br><span class="line">    check(!responseBodyOpen)</span><br><span class="line">    check(!requestBodyOpen)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> exchangeFinder = <span class="keyword">this</span>.exchangeFinder!!</span><br><span class="line">  <span class="keyword">val</span> codec = exchangeFinder.find(client, chain)</span><br><span class="line">  <span class="keyword">val</span> result = Exchange(<span class="keyword">this</span>, eventListener, exchangeFinder, codec)</span><br><span class="line">  <span class="keyword">this</span>.interceptorScopedExchange = result</span><br><span class="line">  <span class="keyword">this</span>.exchange = result</span><br><span class="line">  synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.requestBodyOpen = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.responseBodyOpen = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要是用来查找新的或者合并后的链接以进行即将到来的请求和响应。我们来看一下查找逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(client: <span class="type">OkHttpClient</span>,chain: <span class="type">RealInterceptorChain</span>)</span></span>: ExchangeCodec &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> resultConnection = findHealthyConnection(</span><br><span class="line">          connectTimeout = chain.connectTimeoutMillis,</span><br><span class="line">          readTimeout = chain.readTimeoutMillis,</span><br><span class="line">          writeTimeout = chain.writeTimeoutMillis,</span><br><span class="line">          pingIntervalMillis = client.pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled = client.retryOnConnectionFailure,</span><br><span class="line">          doExtensiveHealthChecks = chain.request.method != <span class="string">&quot;GET&quot;</span></span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span> resultConnection.newCodec(client, chain)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: RouteException) &#123;</span><br><span class="line">      trackFailure(e.lastConnectException)</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">      trackFailure(e)</span><br><span class="line">      <span class="keyword">throw</span> RouteException(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其内部调用了findHealthyConnection，也就是查找一个可用的链接，我们接着往下看：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findHealthyConnection</span><span class="params">(connectTimeout: <span class="type">Int</span>, readTimeout: <span class="type">Int</span>, writeTimeout: <span class="type">Int</span>, pingIntervalMillis: <span class="type">Int</span>, connectionRetryEnabled: <span class="type">Boolean</span>, doExtensiveHealthChecks: <span class="type">Boolean</span> )</span></span>: RealConnection &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//查找链接</span></span><br><span class="line">      <span class="keyword">val</span> candidate = findConnection(</span><br><span class="line">          connectTimeout = connectTimeout,</span><br><span class="line">          readTimeout = readTimeout,</span><br><span class="line">          writeTimeout = writeTimeout,</span><br><span class="line">          pingIntervalMillis = pingIntervalMillis,</span><br><span class="line">          connectionRetryEnabled = connectionRetryEnabled</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确定找到的链接可用并返回</span></span><br><span class="line">      <span class="keyword">if</span> (candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        <span class="keyword">return</span> candidate</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      candidate.noNewExchanges()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> routesLeft = routeSelection?.hasNext() ?: <span class="literal">true</span></span><br><span class="line">      <span class="keyword">if</span> (routesLeft) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> routesSelectionLeft = routeSelector?.hasNext() ?: <span class="literal">true</span></span><br><span class="line">      <span class="keyword">if</span> (routesSelectionLeft) <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> IOException(<span class="string">&quot;exhausted all routes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们看下查找链接的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IOException::class)</span></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   connectTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">   readTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">   writeTimeout: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">   pingIntervalMillis: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">   connectionRetryEnabled: <span class="type">Boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"> )</span></span>: RealConnection &#123;</span><br><span class="line">   <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 尝试重用call的链接</span></span><br><span class="line">   <span class="keyword">val</span> callConnection = call.connection </span><br><span class="line">   <span class="keyword">if</span> (callConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> toClose: Socket? = <span class="literal">null</span></span><br><span class="line">     synchronized(callConnection) &#123;</span><br><span class="line">       <span class="keyword">if</span> (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;</span><br><span class="line">         toClose = call.releaseConnectionNoEvents()</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果不为null，就返回</span></span><br><span class="line">     <span class="keyword">if</span> (call.connection != <span class="literal">null</span>) &#123;</span><br><span class="line">       check(toClose == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span> callConnection</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     toClose?.closeQuietly()</span><br><span class="line">     eventListener.connectionReleased(call, callConnection)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   refusedStreamCount = <span class="number">0</span></span><br><span class="line">   connectionShutdownCount = <span class="number">0</span></span><br><span class="line">   otherFailureCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 尝试从连接池中找一个连接，如果找到就返回连接</span></span><br><span class="line">   <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">     <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">     eventListener.connectionAcquired(call, result)</span><br><span class="line">     <span class="keyword">return</span> result</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果连接池没有，找到下一步需要尝试的连接</span></span><br><span class="line">   <span class="keyword">val</span> routes: List&lt;Route&gt;?</span><br><span class="line">   <span class="keyword">val</span> route: Route</span><br><span class="line">   <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">     routes = <span class="literal">null</span></span><br><span class="line">     route = nextRouteToTry!!</span><br><span class="line">     nextRouteToTry = <span class="literal">null</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (routeSelection != <span class="literal">null</span> &amp;&amp; routeSelection!!.hasNext()) &#123;</span><br><span class="line">     routes = <span class="literal">null</span></span><br><span class="line">     route = routeSelection!!.next()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> localRouteSelector = routeSelector</span><br><span class="line">     <span class="keyword">if</span> (localRouteSelector == <span class="literal">null</span>) &#123;</span><br><span class="line">       localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)</span><br><span class="line">       <span class="keyword">this</span>.routeSelector = localRouteSelector</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">val</span> localRouteSelection = localRouteSelector.next()</span><br><span class="line">     routeSelection = localRouteSelection</span><br><span class="line">     routes = localRouteSelection.routes</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (call.isCanceled()) <span class="keyword">throw</span> IOException(<span class="string">&quot;Canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">       <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">       eventListener.connectionAcquired(call, result)</span><br><span class="line">       <span class="keyword">return</span> result</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     route = localRouteSelection.next()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 进行连接</span></span><br><span class="line">   <span class="keyword">val</span> newConnection = RealConnection(connectionPool, route)</span><br><span class="line">   call.connectionToCancel = newConnection</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     newConnection.connect(</span><br><span class="line">         connectTimeout,</span><br><span class="line">         readTimeout,</span><br><span class="line">         writeTimeout,</span><br><span class="line">         pingIntervalMillis,</span><br><span class="line">         connectionRetryEnabled,</span><br><span class="line">         call,</span><br><span class="line">         eventListener</span><br><span class="line">     )</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     call.connectionToCancel = <span class="literal">null</span></span><br><span class="line">   &#125;</span><br><span class="line">   call.client.routeDatabase.connected(newConnection.route())</span><br><span class="line">   <span class="comment">//确定是不是多路复用，如果是就进行连接合并。</span></span><br><span class="line">   <span class="keyword">if</span> (connectionPool.callAcquirePooledConnection(address, call, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">     <span class="keyword">val</span> result = call.connection!!</span><br><span class="line">     nextRouteToTry = route</span><br><span class="line">     newConnection.socket().closeQuietly()</span><br><span class="line">     eventListener.connectionAcquired(call, result)</span><br><span class="line">     <span class="keyword">return</span> result</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//丢到缓存池里面去</span></span><br><span class="line">   synchronized(newConnection) &#123;</span><br><span class="line">     connectionPool.put(newConnection)</span><br><span class="line">     call.acquireConnectionNoEvents(newConnection)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   eventListener.connectionAcquired(call, newConnection)</span><br><span class="line">   <span class="keyword">return</span> newConnection</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们继续往下看看它到底是怎么建立连接的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">connect</span><span class="params">( connectTimeout: <span class="type">Int</span>, readTimeout: <span class="type">Int</span>, writeTimeout: <span class="type">Int</span>, pingIntervalMillis: <span class="type">Int</span>, connectionRetryEnabled: <span class="type">Boolean</span>, call: <span class="type">Call</span>, eventListener: <span class="type">EventListener</span>)</span></span> &#123;</span><br><span class="line">    check(protocol == <span class="literal">null</span>) &#123; <span class="string">&quot;already connected&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> routeException: RouteException? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">val</span> connectionSpecs = route.address.connectionSpecs</span><br><span class="line">    <span class="keyword">val</span> connectionSpecSelector = ConnectionSpecSelector(connectionSpecs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (route.address.sslSocketFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ConnectionSpec.CLEARTEXT !<span class="keyword">in</span> connectionSpecs) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RouteException(UnknownServiceException(</span><br><span class="line">            <span class="string">&quot;CLEARTEXT communication not enabled for client&quot;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> host = route.address.url.host</span><br><span class="line">      <span class="keyword">if</span> (!Platform.<span class="keyword">get</span>().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RouteException(UnknownServiceException(</span><br><span class="line">            <span class="string">&quot;CLEARTEXT communication to <span class="variable">$host</span> not permitted by network security policy&quot;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Protocol.H2_PRIOR_KNOWLEDGE <span class="keyword">in</span> route.address.protocols) &#123;</span><br><span class="line">        <span class="keyword">throw</span> RouteException(UnknownServiceException(</span><br><span class="line">            <span class="string">&quot;H2_PRIOR_KNOWLEDGE cannot be used with HTTPS&quot;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果需要建立通讯隧道，就建立隧道。也就是通过http代理访问https</span></span><br><span class="line">        <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">          <span class="keyword">if</span> (rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//建立socket连接。</span></span><br><span class="line">          connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">        &#125;</span><br><span class="line">        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">        socket?.closeQuietly()</span><br><span class="line">        rawSocket?.closeQuietly()</span><br><span class="line">        socket = <span class="literal">null</span></span><br><span class="line">        rawSocket = <span class="literal">null</span></span><br><span class="line">        source = <span class="literal">null</span></span><br><span class="line">        sink = <span class="literal">null</span></span><br><span class="line">        handshake = <span class="literal">null</span></span><br><span class="line">        protocol = <span class="literal">null</span></span><br><span class="line">        http2Connection = <span class="literal">null</span></span><br><span class="line">        allocationLimit = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        eventListener.connectFailed(call, route.socketAddress, route.proxy, <span class="literal">null</span>, e)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (routeException == <span class="literal">null</span>) &#123;</span><br><span class="line">          routeException = RouteException(e)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          routeException.addConnectException(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> routeException</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (route.requiresTunnel() &amp;&amp; rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> RouteException(ProtocolException(</span><br><span class="line">          <span class="string">&quot;Too many tunnel connections attempted: <span class="variable">$MAX_TUNNEL_ATTEMPTS</span>&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleAtNs = System.nanoTime()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这里，整个连接流程结束。</p>
<h5 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h5><p>此拦截器主要负责具体的请求与响应的I/O操作，即往Socket⾥写⼊请求数据，和从Socket⾥读取响应数据。也就是发送请求到服务器然后直到数据解析生成response。话不多说，直接上代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercept</span><span class="params">(chain: <span class="type">Interceptor</span>.<span class="type">Chain</span>)</span></span>: Response &#123;</span><br><span class="line">  <span class="keyword">val</span> realChain = chain <span class="keyword">as</span> RealInterceptorChain</span><br><span class="line">  <span class="keyword">val</span> exchange = realChain.exchange!!</span><br><span class="line">  <span class="keyword">val</span> request = realChain.request</span><br><span class="line">  <span class="keyword">val</span> requestBody = request.body</span><br><span class="line">  <span class="keyword">val</span> sentRequestMillis = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> invokeStartEvent = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> responseBuilder: Response.Builder? = <span class="literal">null</span></span><br><span class="line">  <span class="comment">//判断请求头是不是POST</span></span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果请求头包含&quot;100-continue&quot;的响应，就等待它完成响应，在执行正文，如果没有得到，返回正常的结果。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equals(request.header(<span class="string">&quot;Expect&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">      exchange.flushRequest()</span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">true</span>)</span><br><span class="line">      exchange.responseHeadersStart()</span><br><span class="line">      invokeStartEvent = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (requestBody.isDuplex()) &#123;</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">true</span>).buffer()</span><br><span class="line">        requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> bufferedRequestBody = exchange.createRequestBody(request, <span class="literal">false</span>).buffer()</span><br><span class="line">        requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        bufferedRequestBody.close()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">      <span class="keyword">if</span> (!exchange.connection.isMultiplexed) &#123;</span><br><span class="line">        exchange.noNewExchangesOnConnection()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    exchange.noRequestBody()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (requestBody == <span class="literal">null</span> || !requestBody.isDuplex()) &#123;</span><br><span class="line">    exchange.finishRequest()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">    responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">    <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">      exchange.responseHeadersStart()</span><br><span class="line">      invokeStartEvent = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> response = responseBuilder</span><br><span class="line">      .request(request)</span><br><span class="line">      .handshake(exchange.connection.handshake())</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build()</span><br><span class="line">  <span class="keyword">var</span> code = response.code</span><br><span class="line">  <span class="comment">//如果响应是100，这代表了是请求Expect: 100-continue成功的响应，需要再读取一份响应头</span></span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">    responseBuilder = exchange.readResponseHeaders(expectContinue = <span class="literal">false</span>)!!</span><br><span class="line">    <span class="keyword">if</span> (invokeStartEvent) &#123;</span><br><span class="line">      exchange.responseHeadersStart()</span><br><span class="line">    &#125;</span><br><span class="line">    response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    code = response.code</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">  response = <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">    response.newBuilder()</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .build()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response.newBuilder()</span><br><span class="line">        .body(exchange.openResponseBody(response))</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equals(response.request.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>) ||</span><br><span class="line">      <span class="string">&quot;close&quot;</span>.equals(response.header(<span class="string">&quot;Connection&quot;</span>), ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">    exchange.noNewExchangesOnConnection()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body?.contentLength() ?: -<span class="number">1L</span> &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ProtocolException(</span><br><span class="line">        <span class="string">&quot;HTTP <span class="variable">$code</span> had non-zero Content-Length: <span class="subst">$&#123;response.body?.contentLength()&#125;</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，已经完成了HTTP协议报文的封装与解析。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个OkHttp功能的实现就在这五个默认的拦截器中。具体的小结如下：</p>
<ul>
<li><p>addInterceptor(Interceptor)，这是由开发者设置的，会按照开发者的要求，在所有的拦截器处理之前进行最早的拦截处理，比如一些公共参数，Header都可以在这里添加。</p>
</li>
<li><p>RetryAndFollowUpInterceptor，这里会对连接做一些初始化工作，以及请求失败的充实工作，重定向的后续请求工作。跟他的名字一样，就是做重试工作还有一些连接跟踪工作。</p>
</li>
<li><p>BridgeInterceptor，这里会为用户构建一个能够进行网络访问的请求，同时后续工作将网络请求回来的响应Response转化为用户可用的Response，比如添加文件类型，content-length计算添加，gzip解包。</p>
</li>
<li><p>CacheInterceptor，这里主要是处理cache相关处理，会根据OkHttpClient的配置以及缓存策略对请求值进行缓存，而且如果本地有了可⽤的Cache，就可以在没有网络交互的情况下就返回缓存结果。</p>
</li>
<li><p>ConnectInterceptor，这里主要就是负责建立连接了，会建立TCP连接或者TLS连接，以及负责编码解码的HttpCodec。</p>
</li>
<li><p>networkInterceptors，这里也是开发者自己设置的，所以本质上和第一个拦截器差不多，但是由于位置不同，所以用处也不同。这个位置添加的拦截器可以看到请求和响应的数据了，所以可以做一些网络调试。</p>
</li>
<li><p>CallServerInterceptor，这里就是进行网络数据的请求和响应了，也就是实际的网络I/O操作，通过socket读写数据。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
</search>
